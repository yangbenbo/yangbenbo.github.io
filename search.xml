<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Latex</title>
      <link href="2024/04/19/Latex/"/>
      <url>2024/04/19/Latex/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#简介">简介</a><ul><li><a href="#vscode-配置latex环境">vscode 配置Latex环境</a><ul><li><a href="#安装latex工具">安装LaTeX工具</a></li><li><a href="#安装latex插件">安装LaTeX插件</a></li><li><a href="#配置latex环境">配置LaTeX环境</a></li></ul></li><li><a href="#伪代码">伪代码</a><ul><li><a href="#algorithm2e4">algorithm2e</a></li><li><a href="#基本语法">基本语法</a></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>LaTeX (/ˈlɑːtɛk/ LAH-tek or /ˈleɪtɛk/ LAY-tek)<sup><a href="#fn_1" id="reffn_1">1</a></sup>是一种用于排版文档的软件系统. 很多论文排版使用, 这里主要介绍伪代码</p><h2 id="vscode-配置Latex环境"><a href="#vscode-配置Latex环境" class="headerlink" title="vscode 配置Latex环境"></a>vscode 配置Latex环境</h2><h3 id="安装LaTeX工具"><a href="#安装LaTeX工具" class="headerlink" title="安装LaTeX工具"></a>安装LaTeX工具</h3><p>安装TeX发行版, 这里选择的MiKTeX</p><h3 id="安装LaTeX插件"><a href="#安装LaTeX插件" class="headerlink" title="安装LaTeX插件"></a>安装LaTeX插件</h3><p>安装LaTeX插件：在VSCode中安装插件如”LaTeX Workshop”</p><h3 id="配置LaTeX环境"><a href="#配置LaTeX环境" class="headerlink" title="配置LaTeX环境"></a>配置LaTeX环境</h3><p>这里参考文章<a href="https://zhuanlan.zhihu.com/p/166523064" target="_blank" rel="noopener">Visual Studio Code (vscode)配置LaTeX</a><br>打开vscode配置(<code>ctrl+,</code>),增加即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">//------------------------------LaTeX 配置----------------------------------</span><br><span class="line">// 设置是否自动编译</span><br><span class="line">&quot;latex-workshop.latex.autoBuild.run&quot;: &quot;never&quot;,</span><br><span class="line">// 右键菜单</span><br><span class="line">&quot;latex-workshop.showContextMenu&quot;: true,</span><br><span class="line">// 从使用的包中自动补全命令和环境</span><br><span class="line">&quot;latex-workshop.intellisense.package.enabled&quot;: true,</span><br><span class="line">// 编译出错时设置是否弹出气泡设置</span><br><span class="line">&quot;latex-workshop.message.error.show&quot;: false,</span><br><span class="line">&quot;latex-workshop.message.warning.show&quot;: false,</span><br><span class="line">// 编译工具和命令</span><br><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;xelatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;xelatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex=1&quot;,</span><br><span class="line">            &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;%DOCFILE%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;pdflatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;pdflatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex=1&quot;,</span><br><span class="line">            &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;%DOCFILE%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;latexmk&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;latexmk&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex=1&quot;,</span><br><span class="line">            &quot;-interaction=nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;-pdf&quot;,</span><br><span class="line">            &quot;-outdir=%OUTDIR%&quot;,</span><br><span class="line">            &quot;%DOCFILE%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;bibtex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;bibtex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;%DOCFILE%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">// 用于配置编译链</span><br><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;XeLaTeX&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;xelatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;PDFLaTeX&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;pdflatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;BibTeX&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;bibtex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;LaTeXmk&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;latexmk&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;xelatex&quot;,</span><br><span class="line">            &quot;bibtex&quot;,</span><br><span class="line">            &quot;xelatex&quot;,</span><br><span class="line">            &quot;xelatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;pdflatex&quot;,</span><br><span class="line">            &quot;bibtex&quot;,</span><br><span class="line">            &quot;pdflatex&quot;,</span><br><span class="line">            &quot;pdflatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">// 文件清理。此属性必须是字符串数组</span><br><span class="line">&quot;latex-workshop.latex.clean.fileTypes&quot;: [</span><br><span class="line">    &quot;*.aux&quot;,</span><br><span class="line">    &quot;*.bbl&quot;,</span><br><span class="line">    &quot;*.blg&quot;,</span><br><span class="line">    &quot;*.idx&quot;,</span><br><span class="line">    &quot;*.ind&quot;,</span><br><span class="line">    &quot;*.lof&quot;,</span><br><span class="line">    &quot;*.lot&quot;,</span><br><span class="line">    &quot;*.out&quot;,</span><br><span class="line">    &quot;*.toc&quot;,</span><br><span class="line">    &quot;*.acn&quot;,</span><br><span class="line">    &quot;*.acr&quot;,</span><br><span class="line">    &quot;*.alg&quot;,</span><br><span class="line">    &quot;*.glg&quot;,</span><br><span class="line">    &quot;*.glo&quot;,</span><br><span class="line">    &quot;*.gls&quot;,</span><br><span class="line">    &quot;*.ist&quot;,</span><br><span class="line">    &quot;*.fls&quot;,</span><br><span class="line">    &quot;*.log&quot;,</span><br><span class="line">    &quot;*.fdb_latexmk&quot;</span><br><span class="line">],</span><br><span class="line">// 设置为onFaild 在构建失败后清除辅助文件</span><br><span class="line">&quot;latex-workshop.latex.autoClean.run&quot;: &quot;onFailed&quot;,</span><br><span class="line">// 使用上次的recipe编译组合</span><br><span class="line">&quot;latex-workshop.latex.recipe.default&quot;: &quot;lastUsed&quot;,</span><br><span class="line">// 用于反向同步的内部查看器的键绑定。ctrl/cmd +点击(默认)或双击</span><br><span class="line">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;,</span><br><span class="line">// 使用 SumatraPDF 预览编译好的PDF文件</span><br><span class="line">// 设置VScode内部查看生成的pdf文件</span><br><span class="line">&quot;latex-workshop.view.pdf.viewer&quot;: &quot;external&quot;,</span><br><span class="line">// PDF查看器用于在\ref上的[View on PDF]链接</span><br><span class="line">&quot;latex-workshop.view.pdf.ref.viewer&quot;: &quot;auto&quot;,</span><br><span class="line">// 使用外部查看器时要执行的命令。此功能不受官方支持。</span><br><span class="line">&quot;latex-workshop.view.pdf.external.viewer.command&quot;: &quot;F:/SumatraPDF/SumatraPDF.exe&quot;, // 注意修改路径</span><br><span class="line">// 使用外部查看器时，latex-workshop.view.pdf.external.view .command的参数。此功能不受官方支持。%PDF%是用于生成PDF文件的绝对路径的占位符。</span><br><span class="line">&quot;latex-workshop.view.pdf.external.viewer.args&quot;: [</span><br><span class="line">    &quot;%PDF%&quot;</span><br><span class="line">],</span><br><span class="line">// 将synctex转发到外部查看器时要执行的命令。此功能不受官方支持。</span><br><span class="line">&quot;latex-workshop.view.pdf.external.synctex.command&quot;: &quot;F:/SumatraPDF/SumatraPDF.exe&quot;, // 注意修改路径</span><br><span class="line">// latex-workshop.view.pdf.external.synctex的参数。当同步到外部查看器时。%LINE%是行号，%PDF%是生成PDF文件的绝对路径的占位符，%TEX%是触发syncTeX的扩展名为.tex的LaTeX文件路径。</span><br><span class="line">&quot;latex-workshop.view.pdf.external.synctex.args&quot;: [</span><br><span class="line">    &quot;-forward-search&quot;,</span><br><span class="line">    &quot;%TEX%&quot;,</span><br><span class="line">    &quot;%LINE%&quot;,</span><br><span class="line">    &quot;-reuse-instance&quot;,</span><br><span class="line">    &quot;-inverse-search&quot;,</span><br><span class="line">    &quot;\&quot;F:/Microsoft VS Code/Code.exe\&quot; \&quot;F:/Microsoft VS Code/resources/app/out/cli.js\&quot; -r -g \&quot;%f:%l\&quot;&quot;, // 注意修改路径</span><br><span class="line">    &quot;%PDF%&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>Latex伪代码一般会接触到的包有algorithm、algorithmic、algorithmicx、algorithm2e这四种包<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><ul><li>algorithm用于给伪代码提供一个浮动体环境，防止其换页或其他因素导致的内容中断，从而跨页显示。</li><li>algorithmic用于编辑伪代码的内容，一些for、while、if等语句通过该包中的命令进行编写。</li><li>algorithmicx可以看作algorithmic的升级版，提供了一些自定义命令</li><li>algorithm2e则是独立于algorithmic和algorithmicx的另一套伪代码环境，两套环境语法、排版上均不相同;自定义功能更多</li></ul><p>这里主要介绍algorithm2e, 可以使用网页overleaf<sup><a href="#fn_3" id="reffn_3">3</a></sup>在线高效快速编译</p><h3 id="algorithm2e4"><a href="#algorithm2e4" class="headerlink" title="algorithm2e4"></a>algorithm2e<sup><a href="#fn_4" id="reffn_4">4</a></sup></h3><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>算法引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage[options ]&#123;algorithm2e&#125;</span><br></pre></td></tr></table></figure></p><p>具体选项很多</p><ul><li>ruled 是让标题显示在上面, 否则算法的标题在下面</li><li>linesnumbered 显示行号</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>代码</td><td>含义</td></tr><tr><td>\\;</td><td>在行末添加分号，并自动换行</td></tr><tr><td>\caption{}</td><td>插入标题</td></tr><tr><td>\KwData</td><td>效果为：“Data:输入信息”</td></tr><tr><td>\Kwln</td><td>效果为：“ln:输入信息”</td></tr><tr><td>\KwOut</td><td>效果为：“Out:输出信息”</td></tr><tr><td>\KwResult</td><td>效果为：“Result:输出信息”</td></tr><tr><td>\For {条件}</td><td></td></tr><tr><td>\If {条件}</td><td></td></tr><tr><td>\While {条件}</td><td></td></tr><tr><td>\tcc</td><td>/<em>注释</em>/</td></tr><tr><td>\tcp</td><td>//注释</td></tr><tr><td>\elf {条件}{肯定语句}</td></tr></tbody></table></div><p><strong>if-then-else macros</strong></p><ul><li>\If, \Else, \ElseIf都是会以end结尾</li><li>\uIf, \uElse, \uElseIf, 是不以end结尾的块级元素</li><li>\lIf, \lElse, \lElseIf 是不以end为结尾的行内元素<br>在If-else结构中，\eIf 自带else（即 if 和 else 共用一个 end），而只是用 \If 和 \Else 的话则会多出一个end给Else。</li></ul><p>示例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[11pt,a4paper]&#123;article&#125;</span><br><span class="line">\usepackage[margin=3cm]&#123;geometry&#125;</span><br><span class="line">\usepackage[ruled,linesnumbered]&#123;algorithm2e&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% H: algorithms cannot be cut</span><br><span class="line">\begin&#123;algorithm&#125;[H]</span><br><span class="line">\caption&#123;An algorithm test&#125; \label&#123;alg:test&#125;</span><br><span class="line">%% This is needed if you want to add comments in</span><br><span class="line">%% your algorithm with \Comment</span><br><span class="line">\SetKwComment&#123;Comment&#125;&#123;/* &#125;&#123; */&#125;</span><br><span class="line"></span><br><span class="line">\KwIn&#123;$x,n$&#125;</span><br><span class="line">\KwOut&#123;$y = x^n$&#125;</span><br><span class="line">$y \gets 1$\;</span><br><span class="line">$X \gets x$\;</span><br><span class="line">$N \gets n$\;</span><br><span class="line">\While&#123;$N \neq 0$&#125;</span><br><span class="line">&#123;</span><br><span class="line">    \uIf&#123;$N$ is even&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        $X \gets X \times X$\;</span><br><span class="line">        $N \gets \frac&#123;N&#125;&#123;2&#125; $ \Comment*[r]&#123;This is a comment&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    \ElseIf&#123;$N$ is odd&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        $y \gets y \times X$\;</span><br><span class="line">        $N \gets N - 1$\;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">\end&#123;algorithm&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test ref Algorithm~\ref&#123;alg:test&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>算法标签<code>\label{alg:test}</code>, 方便在文章中引用, 引用<code>Algorithm~\ref{alg:test}</code></p><blockquote id="fn_1"><sup>1</sup>. <a href="https://en.wikipedia.org/wiki/LaTeX" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/LaTeX</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://en.wikibooks.org/wiki/LaTeX/Algorithms" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/LaTeX/Algorithms</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://www.overleaf.com/project" target="_blank" rel="noopener">https://www.overleaf.com/project</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://mirror.ox.ac.uk/sites/ctan.org/macros/latex/contrib/algorithm2e/doc/algorithm2e.pdf" target="_blank" rel="noopener">https://mirror.ox.ac.uk/sites/ctan.org/macros/latex/contrib/algorithm2e/doc/algorithm2e.pdf</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刚体运动</title>
      <link href="2024/04/04/%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"/>
      <url>2024/04/04/%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#旋转矩阵">旋转矩阵</a><ul><li><a href="#基本性质">基本性质</a><ul><li><a href="#矩阵左乘和右乘">矩阵左乘和右乘</a></li></ul></li><li><a href="#so3性质">SO(3)性质</a><ul><li><a href="#so3">so(3)</a></li><li><a href="#姿态指数坐标">姿态指数坐标</a></li></ul></li></ul></li><li><a href="#齐次矩阵">齐次矩阵</a><ul><li><a href="#基本性质-1">基本性质</a><ul><li><a href="#齐次矩阵左右乘">齐次矩阵左右乘</a></li></ul></li><li><a href="#se3性质">SE(3)性质</a><ul><li><a href="#se3">se(3)</a></li></ul></li></ul></li><li><a href="#正运动学">正运动学</a></li><li><a href="#微分运动学">微分运动学</a><ul><li><a href="#空间雅可比">空间雅可比</a></li><li><a href="#物体雅可比">物体雅可比</a></li><li><a href="#速度雅可比">速度雅可比</a></li><li><a href="#力映射">力映射</a></li><li><a href="#奇异分析">奇异分析</a></li></ul></li></ul><!-- /code_chunk_output --><p>主要参考<strong>现代机器人学(MODERN ROBOTICS MECHANICS, PLANNING, AND CONTROL)</strong><sup><a href="#fn_1" id="reffn_1">1</a></sup></p><h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><p>3个主要作用如下:</p><ul><li>参考系($\{s\}$)下目标坐标系的表示</li><li>改变向量或坐标系的参考坐标系</li><li>旋转向量或坐标系</li></ul><p>平面旋转只有1个自由度, 表示简单直观, 3维空间旋转3自由度,使用3个较度不够值观,可以隐式表示,即在高维空间中的面.比如3维度空间的球面只有2自由度, 隐式表示使用3个变量1个约束为$[x,y,z],x^2+y^2+z^2=r^2$, 很直观就知道是球面.如果只使用2自由度即经纬度则坐标变成$[r\cos \phi \cos \theta ,r\cos \phi \sin \theta ,r\sin \phi]$.同样的针对3个旋转角度可以使用9个参数表示,$[x_b,y_b,z_b]=[x_s,y_s,z_s]^{s}_bR$<br>其中$^s_bR$第1-3列分别为$\{b\}$中$x,y,z$轴在$\{s\}$中的表示,可以简单理解成坐标轴在基坐标系下线性组合,即<strong>旋转矩阵本身为一个坐标系在参考系下表示</strong>.同样的有$[x_c,y_c,z_c]=[x_b,y_b,z_b]^{b}_cR$所以有</p><script type="math/tex; mode=display">[x_c,y_c,z_c]=[x_b,y_b,z_b]^{b}_cR=[x_s,y_s,z_s]^{s}_bR^{b}_cR=[x_s,y_s,z_s]^{s}_cR</script><p>对应$^{s}_bR$可以看成改变了$^{b}_cR$参考系, 即<strong>旋转矩阵改变了原本向量或矩阵的参考系</strong><br><img src="/2024/04/04/刚体运动/改变参考系.png" alt="改变坐标系"></p><p>初始$\{s\},\{d\}$重合,$\{c\}$相对$\{d\}$固连(刚体), $\{d\}$旋转到$\{d’\}$后求对应的$\{c’\}$, 即</p><script type="math/tex; mode=display">^{s}_{c'}R=^{s}_{b'}R^{b'}_{c'}R=^{s}_{b'}R^{b}_{c}R=^{s}_{b'}R^{s}_{c}R</script><p>对应$^{s}_{b’}R$旋转$\{c\}$到$\{c’\}$, 即<strong>旋转矩阵可以表示对向量或者坐标系的旋转</strong><br><img src="/2024/04/04/刚体运动/旋转运动.png" alt="旋转运动"></p><h3 id="矩阵左乘和右乘"><a href="#矩阵左乘和右乘" class="headerlink" title="矩阵左乘和右乘"></a>矩阵左乘和右乘</h3><p>$^{s}_{c’}R=e^{[w_s]\theta} \cdot ^{s}_{c}R=^{s}_{b’}R^{s}_{c}R$, 这里其实是相对基坐标系的旋转,即$[w_s]$为基坐标系下轴,使用相对于物体坐标系则是右乘</p><script type="math/tex; mode=display">^{s}_{c'}R=e^{[w_s]\theta} \cdot ^{s}_{c}R=e^{[^s_cRw_c]\theta} \cdot ^{s}_{c}R=e^{^s_cR[w_c]^s_cR^T\theta} \cdot ^{s}_{c}R=^s_cRe^{[w_c]\theta}</script><h2 id="SO-3-性质"><a href="#SO-3-性质" class="headerlink" title="SO(3)性质"></a>SO(3)性质</h2><p>旋转矩阵$R=[a,b,c]$9个元素表示3个自由度姿态,对应6个约束, 列向量模长=1, 两列垂直,对应$R^TR=I$, $\det |R|=c^T(a\times b)=1$,对应右手坐标系,左手坐标系$\det|R|=-1$<br>旋转矩阵属于特殊正交群(special orthogonal group, SO(3)),即$R\in SO(3)$, 位姿属于特殊欧几里得群(special Euclidean group, SE(3))</p><script type="math/tex; mode=display">SO(3)=\left\{\boldsymbol{C}\in\mathbb{R}^{3\times3}|\boldsymbol{C}\boldsymbol{C}^\mathrm{T}=\boldsymbol{1},\det\boldsymbol{C}=1\right\}</script><p>群$SO(n)$:</p><ul><li>封闭性 (closure): $AB$ is also in the group</li><li>结合律 (associativity): $(AB)C=A(BC)$</li><li>存在幺元 (identity): $\exists I \in SO(n), AI=IA=A$</li><li>存在逆 (invertibility): $\exists A^{-1} \in SO(n), A^{-1}A=AA^{-1}=I$</li></ul><p>旋转矩阵是$SO(3)$群证明如下:<br>closure<br>$A,B\in SO(3)$, 有$(AB)^TAB=I$, $\det|AB|=\det|A|\det|B|=1$, 所以$AB\in SO(3)$</p><p>associativity<br>矩阵乘法决定, 简单通过线性组合证明:$A(BC)=A(B[c_1,\cdots, c_n])=A[Bc_1,\cdots, Bc_n]=[ABc_1,\cdots, ABc_n]=(AB)[c_1,\cdots, c_n]=(AB)C$<br>其中$A(Bc_i)=ABc_i$证明参考<a href="/2023/07/30/线性代数/" title="线性代数概览">线性代数概览</a>    </p><p>identity<br>单位阵$I$</p><p>invertibility<br>对于满秩矩阵(可逆)$A$, 若$A^{-1}A=I$, 则$AA^{-1}=USV^T(USV^T)^{-1}=I$. 对于$R^TR=I$, 得到$R^{-1}=R^T$(可以证明$RR^T=I$)</p><h3 id="so-3"><a href="#so-3" class="headerlink" title="so(3)"></a>so(3)</h3><p>主要性质</p><ul><li>$[w_s]=\dot R R^{-1}$, 基坐标系$\{s\}$下姿态矩阵变化对应的角速度</li><li>$[w_b]=R^{-1} \dot R$, 物体坐标系$\{b\}$下姿态矩阵变化对应的角速度,实际在$\{s\}$系观测,然后在$\{b\}$系表示, 这里的$\{b\}$相当于与$\{s\}$瞬时固连,同时与物体坐标系重合</li></ul><p>姿态变化对应角速度求解,旋转矩阵各轴都是单位向量, 求导即对应点的线速度为$w\times r$</p><script type="math/tex; mode=display">\dot R=w_s \times [r_1, r_2,r_3]=[w_s]R=\begin{bmatrix}0  & -z & y & \\z  & 0 & -x & \\-y  & x &  0&\end{bmatrix}R</script><p>即$[w_s]=\dot RR^{-1}$,$[w_s] \in so(3)$为基坐标系下转轴对应反对称矩阵<br>重要性质$R[\omega]R^{T}=[R\omega]$证明如下</p><script type="math/tex; mode=display">\begin{aligned}&R[\omega]R^{T} \left.=\quad\left[\begin{array}{ccc}r_1^T(\omega\times r_1)&r_1^T(\omega\times r_2)&r_1^T(\omega\times r_3)\\r_2^T(\omega\times r_1)&r_2^T(\omega\times r_2)&r_2^T(\omega\times r_3)\\r_3^T(\omega\times r_1)&r_3^T(\omega\times r_2)&r_3^T(\omega\times r_3)\end{array}\right.\right] \\&=\quad\left[\begin{array}{ccc}0&-r_3^T\omega&r_2^T\omega\\r_3^T\omega&0&-r_1^T\omega\\-r_2^T\omega&r_1^T\omega&0\end{array}\right] \\&=\quad[R\omega],\end{aligned}</script><p>同时因为$w_s=^s_bRw_b$, 则有$[w_b]=<sup><a href="#fn_s_bR^{-1}w_s" id="reffn_s_bR^{-1}w_s">s_bR^{-1}w_s</a></sup>=^s_bR^{-1}[w_s]^s_bR=^s_bR^{-1} \dot R$</p><h3 id="姿态指数坐标"><a href="#姿态指数坐标" class="headerlink" title="姿态指数坐标"></a>姿态指数坐标</h3><p>如下图中绕轴转动的$p$点,对应有$\dot p=[w]p$, 参考标定微分方程求解, 向量也可以证明解为$p_t=e^{[w]t}p_0=Rp_0$, 替换得到$p_{\theta}=e^{[w]\theta}p_0=Rp_0$<br><img src="/2024/04/04/刚体运动/rotation.png" alt="姿态矩阵指数表示"></p><script type="math/tex; mode=display">\begin{aligned}R(w,\theta)&=e^{[\hat{\omega}]\theta}\\&=I+[\hat{\omega}]\theta+[\hat{\omega}]^2\frac{\theta^2}{2!}+[\hat{\omega}]^3\frac{\theta^3}{3!}+\ldots\\&=I+\left(\theta-\frac{\theta^3}{3!}+\frac{\theta^5}{5!}-\cdots\right)[\hat{\omega}]+\left(\frac{\theta^2}{2!}-\frac{\theta^4}{4!}+\frac{\theta^6}{6!}-\cdots\right)[\hat{\omega}]^2\\&=I+\sin\theta [\hat{\omega}]+(1-\cos\theta)[\hat{\omega}]^2\in SO(3)\end{aligned}</script><p>其中$[w]^3=-[w]$,对应Rodrigues’ formula<br>证明$(e^{A})^{-1}=e^{-A}$, 首先利用分解$A=Q\Lambda Q^T$, 则$(e^{A})^{-1}e^{-A}=Qe^{\Lambda}Q^TQe^{-\Lambda}Q^T=I$, 原式得证明</p><p>有指数运算当然也有对数反运算,具体不再详细推导</p><script type="math/tex; mode=display">\begin{array}{rcll}\exp:&[\hat\omega]\theta\in so(3)&\to&R\in SO(3)\\\log:&R\in SO(3)&\to&[\hat\omega]\theta\in so(3)\end{array}</script><p>这里使用点的速度,同时也可以求角速度(或者理解成3个点同时求速度)</p><ul><li>$\dot R=[w_s]R$, 得到$R_{\theta}=e^{[w_s]{\theta}}R_0$</li><li>$\dot R=R[w_b]$, 得到$R_{\theta}=R_0e^{[w_b]{\theta}}$<br>从这里也可以看到同一个角速度不同表示, 可以是相对初始姿态基坐标系旋转左乘,也可以是相对同一个轴(但是在物体坐标系表示)右乘</li></ul><h1 id="齐次矩阵"><a href="#齐次矩阵" class="headerlink" title="齐次矩阵"></a>齐次矩阵</h1><h2 id="基本性质-1"><a href="#基本性质-1" class="headerlink" title="基本性质"></a>基本性质</h2><p>齐次矩阵表示空间中6个自由度,具体证明属于$SE(3)$群的4个性质容易证明就不再推导, 推导三维向量一般用$Tx=Rx+p$</p><script type="math/tex; mode=display">T=\left[\begin{array}{cc}R&p\\0&1\end{array}\right] = \begin{bmatrix}I  & p\\0  &1\end{bmatrix}\begin{bmatrix}R  & 0\\0  &1\end{bmatrix}\in SE(3)</script><p>齐次矩阵对整个空间中点进行旋转和平移,不改变点之间的相互关系,即旋转和平移相对整个刚体,刚体选择3个不共线的点即可定义坐标系完全表示</p><ul><li>$|Tx-Ty|=|x-y|$, 点之间的距离保持不变</li><li>$\langle Tx-Tz,Ty-Tz\rangle=\langle x-z,y-z\rangle $ 向量之间的夹角保持不变</li></ul><p>同姿态坐标系类似, 齐次矩阵也有3种功能,类似姿态坐标系即可证明</p><ul><li>参考系下目标坐标系的表示</li><li>改变向量或坐标系的参考坐标系</li><li>旋转向量或坐标系</li></ul><h3 id="齐次矩阵左右乘"><a href="#齐次矩阵左右乘" class="headerlink" title="齐次矩阵左右乘"></a>齐次矩阵左右乘</h3><p>齐次矩阵左/右乘分别相对基坐标系和物体坐标系进行线性变换</p><script type="math/tex; mode=display">\begin{gathered}T_{sb^{\prime}} =TT_{sb}=\mathrm{Trans}(p)\operatorname{Rot}(\hat{\omega},\theta)T_{sb}\quad\mathrm{(fixed~frame)} \\=\left[\begin{array}{cc}R&p\\0&1\end{array}\right]\left[\begin{array}{cc}R_{sb}&p_{sb}\\0&1\end{array}\right]=\left[\begin{array}{cc}RR_{sb}&Rp_{sb}+p\\0&1\end{array}\right] \\T_{sb''} =T_{sb}T=T_{sb}\text{ Trans}(p)\operatorname{Rot}(\hat{\omega},\theta)\quad\text{(body frame)} \\=\left[\begin{array}{cc}R_{sb}&p_{sb}\\0&1\end{array}\right]\left[\begin{array}{cc}R&p\\0&1\end{array}\right]=\left[\begin{array}{cc}R_{sb}R&R_{sb}p+p_{sb}\\0&1\end{array}\right]. \end{gathered}</script><h2 id="SE-3-性质"><a href="#SE-3-性质" class="headerlink" title="SE(3)性质"></a>SE(3)性质</h2><p>类似求角速度,这里求解body twist$[\mathcal{V}_b]$(twist 空间速度)和spatial twist$[\mathcal{V}_s]$:</p><script type="math/tex; mode=display">\begin{aligned}T^{-1}\dot{T}& =\left[\begin{array}{cc}R^T&-R^Tp\\0&1\end{array}\right]\left[\begin{array}{cc}\dot{R}&\dot{p}\\0&0\end{array}\right] \\&=\left[\begin{array}{cc}R^T\dot{R}&R^T\dot p\\0&0\end{array}\right] \\&=\left[\begin{array}{cc}[\omega_b]&v_b\\0&0\end{array}\right]\\&=[\mathcal{V} _b]\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}\dot{T}T^{-1}& =\left[\begin{array}{cc}\dot{R}&\dot{p}\\0&0\end{array}\right]\left[\begin{array}{cc}R^T&-R^Tp\\0&1\end{array}\right] \\&=\left[\begin{array}{cc}\dot{R}R^T&\dot{p}-\dot{R}R^Tp\\0&0\end{array}\right] \\&=\left[\begin{array}{cc}[\omega_s]&v_s\\0&0\end{array}\right]\\&=[\mathcal{V} _s]\end{aligned}</script><ul><li>$w_b$ is the angular velocity expressed in $\{b\}$, and $w_s$ is the angular velocity expressed in $\{s\}$. </li><li>$v_b$ is the linear velocity of a point at the origin of $\{b\}$} expressed in $\{b\}$, and $v_s$ is the linear velocity of a point at the origin of $\{s\}$ expressed in $\{s\}$.<br>这里含义都是基于基坐标系观测目标刚体运动,分别是物体坐标系,以及与物体坐标系固连同时和基坐标系瞬时重合的坐标系,最后分别在两个坐标系下表示线速度和角速度</li></ul><p>推导不同坐标系下twist转换关系</p><script type="math/tex; mode=display">[\mathcal{V}_s ]=\dot TT^{-1}=^s_bT[\mathcal{V}_b ]^s_bT^{-1}=\begin{bmatrix}R[w_b]R^T  & -R[w_b]R^Tp+Rv_b\\0  &0\end{bmatrix}</script><p>从这里也可以得到前面使用的结论$[w_s]=[Rw_b]=R[w_b]R^T$, 同时可以得到</p><script type="math/tex; mode=display">\mathcal{V}_s=\begin{bmatrix}w_s \\v_s\end{bmatrix} =\begin{bmatrix}R  & 0\\[p]R  &R\end{bmatrix}\mathcal{V}_b=[Ad_T]\mathcal{V}_b</script><p>其中$[Ad_T]$为伴随矩阵<br>容易证明:</p><ul><li>$[\mathrm{Ad}_{T_1}][\mathrm{Ad}_{T_2}]\mathcal{V}=[\mathrm{Ad}_{T_1T_2}]\mathcal{V}$</li><li>$[\mathrm{Ad}_T]^{-1}=[\mathrm{Ad}_{T^{-1}}]$, 可以对$\mathcal{V}$取2次变换$T,T^{-1}$即可证明</li></ul><h3 id="se-3"><a href="#se-3" class="headerlink" title="se(3)"></a>se(3)</h3><p>从上面推导可以得到$\dot T=[\mathcal{V_s}]T$, 同姿态一致,微分方程求解为$T_{\theta}=e^{[\mathcal{V_s}]\theta}T_0$. 同时也有$\dot T=T[\mathcal{V_b}]$, $T_{\theta}=T_0e^{[\mathcal{V_b}]\theta}$即左右乘分别相对基坐标系以及物体坐标系.<br>对应可以使用指数坐标$\mathcal{S}=\begin{bmatrix}w \\ v\end{bmatrix}$, 即$\mathcal{V}=\mathcal{S}\theta$</p><ul><li>$ω \ne 0$: $\mathcal{S} = \mathcal{V}/‖ω‖ = (ω/‖ω‖, v/‖ω‖)$. The screw axis $\mathcal{S}$ is simply $\mathcal{V}$ normalized by the length of the angular velocity vector. The angular velocity about the screw axis is  $ θ = ‖ω‖$, such that $\mathcal{S}θ = \mathcal{V}$.</li><li>$ω = 0$: $\mathcal{S} = \mathcal{V}/‖v‖ = (0, v/‖v‖)$. The screw axis $\mathcal{S}$ is simply $\mathcal{V}$ normalized by the length of the linear velocity vector. The linear velocity along the screw axis is  ̇ $θ = ‖v‖$, such that $\mathcal{S} θ = \mathcal{V}$.<br>指数运算得到位姿,如果是纯移动, 则$e^{[\mathcal{S}]\theta}=\left[\begin{array}{cc}I&amp;v\theta\\0&amp;1\end{array}\right]$, 如果有转动则如下<script type="math/tex; mode=display">\left.e^{[\mathcal{S}]\theta}=\left[\begin{array}{cc}e^{[\omega]\theta}&\left(I\theta+(1-\cos\theta)[\omega]+(\theta-\sin\theta)[\omega]^2\right)v\\0&1\end{array}\right.\right]</script>同样的有对数运算<script type="math/tex; mode=display">\begin{array}{rcll}\exp:&[\mathcal{S}]\theta\in se(3)&\to&T\in SE(3)\\\log:&T\in SE(3)&\to&[\mathcal{S}]\theta\in se(3)\end{array}</script></li></ul><p>推导wrench变换坐标系, $\mathcal{F}=\begin{bmatrix}r\times f \\f\end{bmatrix}=\begin{bmatrix}m \\f\end{bmatrix}$<br>利用能量守恒定理有</p><script type="math/tex; mode=display">\mathcal{V_b}^T\mathcal{F_b} =\mathcal{V_s}^T\mathcal{F_s} =(Ad_{^s_bT}\mathcal{V_b})^T\mathcal{F_s}=\mathcal{V_b}^T(Ad_{^s_bT})^T\mathcal{F_s}</script><p>即$\mathcal{F_b} =(Ad_{^s_bT})^T\mathcal{F_s}$</p><h1 id="正运动学"><a href="#正运动学" class="headerlink" title="正运动学"></a>正运动学</h1><p>根据公式$T_{\theta}=e^{[\mathcal{V_s}]\theta}T_0$(这里的$\mathcal{V_s}$相对于单位化后的旋量,和$\mathcal{S}等价$),可以很容易得到正运动学</p><script type="math/tex; mode=display">T_{\theta}=e^{[\mathcal{S}_1]\theta_1}\cdots e^{[\mathcal{S}_n]\theta_n}T_0</script><p>其中$T_0$是各个关节零位是工具相对基坐标系位姿,$\mathcal{S_i}$为关节$i$在基坐标系下旋量. 注意先后顺序,后面的关节不影响前面关节旋量, 所以从后开始</p><p>同理可以得到物体坐标系下推导</p><script type="math/tex; mode=display">T_{\theta}=T_0e^{[\mathcal{B}_1]\theta_1}\cdots e^{[\mathcal{B}_n]\theta_n}</script><p>其中$\mathcal{B}$为物体坐标系下关节旋量,当然也可以由基坐标系下正运动学进行推导替换$e^{M^{-1}PM}=M^{-1}e^PM$.前面关节不影响后面关节的物体旋量,所以从前开始</p><h1 id="微分运动学"><a href="#微分运动学" class="headerlink" title="微分运动学"></a>微分运动学</h1><h2 id="空间雅可比"><a href="#空间雅可比" class="headerlink" title="空间雅可比"></a>空间雅可比</h2><p>基坐标系下使用$[\mathcal{V_s}]=\dot TT^{-1}$推导得到</p><script type="math/tex; mode=display">[\mathcal{V_s}]=J_s \dot \theta</script><p>其中第$i$列为$J_{si}(\theta)=\mathrm{Ad}_{e^{[\mathcal{S}_1]\theta_1}\cdots e^{[\mathcal{S}_{i-1}]\theta_{i-1}}}\left(\mathcal{S}_i\right)$, 即当前构型下关节$i$在基坐标系下的空间速度(旋量)</p><h2 id="物体雅可比"><a href="#物体雅可比" class="headerlink" title="物体雅可比"></a>物体雅可比</h2><p>同理也可以推导物体坐标系下雅可比</p><script type="math/tex; mode=display">[\mathcal{V_b}]=J_b \dot \theta</script><p>其中第$i$列为$J_{bi}(\theta)=\mathrm{Ad}_{e^{-[\mathcal{B}_n]\theta_n}…e^{-[\mathcal{B}_{i+1}]\theta_{i+1}}}(\mathcal{B}_i)$, 即当前构型下关节$i$在物体坐标系下的空间速度(旋量)<br>可视化参考下图, 求关节12转动之后当前构型关节3的旋量,即需要把零位下旋量(即当前构型下相对$\{s’’\}$)转换到$\{s\}$系, 即$[\mathcal{S_3’}]=Ad_{e^{\mathcal{S_1}\theta_1}e^{\mathcal{S_2}\theta_2}}[\mathcal{S_3}]$<br><img src="/2024/04/04/刚体运动/jacobian.png" alt="Jacobian"><br>那么两个雅可比之间转换其实就是不同坐标系下旋量之间的转换,即</p><script type="math/tex; mode=display">J_s(\theta)=[\mathrm{Ad}_{T_{sb}}]J_b(\theta)</script><h2 id="速度雅可比"><a href="#速度雅可比" class="headerlink" title="速度雅可比"></a>速度雅可比</h2><p>速度和角速度都是基坐标系观察物体坐标系,且在基坐标系下表示</p><script type="math/tex; mode=display">\begin{bmatrix}w \\v\end{bmatrix}=\begin{bmatrix}^s_bR  &0 \\0  &^s_bR\end{bmatrix}\begin{bmatrix}w_b \\v_b\end{bmatrix}=\begin{bmatrix}^s_bR  &0 \\0  &^s_bR\end{bmatrix}J_b\dot \theta=J_v\dot \theta</script><p>即$J_v=\begin{bmatrix}<br>^s_bR  &amp;0 \\<br>0  &amp;^s_bR<br>\end{bmatrix}J_b$</p><h2 id="力映射"><a href="#力映射" class="headerlink" title="力映射"></a>力映射</h2><p>根据能量守恒定理推导,这里主要针对非冗余机械臂,$\tau^T\dot{\theta}=\mathcal{F}_b^T\mathcal{V}_b$, 得到</p><script type="math/tex; mode=display">\tau=J_s^T(\theta)\mathcal{F}_s\\\tau=J_b^T(\theta)\mathcal{F}_b</script><h2 id="奇异分析"><a href="#奇异分析" class="headerlink" title="奇异分析"></a>奇异分析</h2><p>雅可比奇异与在某个坐标系下表示无关,不同坐标系下雅可比转换通过伴随矩阵,即$J_s=Ad_{^s_bT}J_b$, 伴随矩阵可逆,所以分析奇异时可以把参考坐标系任意放置.主要奇异构型如下</p><ul><li>2旋转轴共线: 2列雅可比相同</li><li>3旋转轴平行且共面: 3列雅可比线性相关</li><li>4旋转轴交于1个点: 参考坐标系原点选在交点, 4列雅可比线性相关</li><li>4旋转轴共面: 参考坐标系z轴垂直于对应面, 4列雅可线性相关</li><li>6旋转轴交于1条线: 参考坐标系z轴为对应线, 6列雅可线性相关</li></ul><blockquote id="fn_1"><sup>1</sup>. <a href="https://hades.mech.northwestern.edu/index.php/Modern_Robotics" target="_blank" rel="noopener">https://hades.mech.northwestern.edu/index.php/Modern_Robotics</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位姿变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GTest</title>
      <link href="2023/12/17/GTest/"/>
      <url>2023/12/17/GTest/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>GoogleTest<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><p>test suite 包含1个或多个 tests. 可以把tests组织成test suites以反映测试代码的结构, 当多个测试需要共享数据或流程时可以放在1个类里面</p><h2 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h2><p><code>EXPECT_*</code>返回非致命错误,会继续运行,推荐使用<br><code>ASSERT_*</code>从当前函数马上返回,可能跳过它之后的clean-up code, 造成内存泄漏</p><p>可在断言处增加自定义打印信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_EQ(x[i], y[i]) &lt;&lt; &quot;Vectors x and y differ at index &quot; &lt;&lt; i;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">简单例子</span><br></pre></td></tr></table></figure></p><p>TEST(TestSuiteName, TestName) {<br>  … test body …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**TestSuiteName, TestName不要使用下划线**</span><br><span class="line"></span><br><span class="line">## ubuntu安装gtest</span><br><span class="line">参考[[Ubuntu]GTest安装和测试](https://blog.csdn.net/Swallow_he/article/details/120065786)</span><br><span class="line">ubuntu的开发环境比较友好,可以直接通过命令行下载对应软件包,针对gtest,可以直接在[packages 官网](https://packages.ubuntu.com/search?suite=default&amp;section=all&amp;arch=any&amp;keywords=gtest&amp;searchon=names)搜索, 然后使用`apt`,进行安装, 找到源文件阅读`README.txt`, 进行编译和安装, `make install`把需要的库文件和头文件放在了系统目录</span><br></pre></td></tr></table></figure></p><p>sudo apt-get install libgtest-dev<br>cd /usr/src/gtest</p><p>sudo mkdir build # 如果没有文件夹就创建<br>cd build<br>sudo cmake ..  #一定要以sudo的方式运行，否则没有写入权限<br>sudo make      #这个也一样要以sudo的方式<br>make install<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">创建`hello.txt`文件</span><br></pre></td></tr></table></figure></p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <gtest gtest.h></gtest></h1><p>// The fixture for testing class Foo.<br>class FooTest : public testing::Test<br>{<br>protected:<br>    // You can remove any or all of the following functions if their bodies would<br>    // be empty.</p><pre><code>FooTest(){    // You can do set-up work for each test here.}~FooTest() override{    // You can do clean-up work that doesn&#39;t throw exceptions here.}// If the constructor and destructor are not enough for setting up// and cleaning up each test, you can define the following methods:void SetUp() override{    // Code here will be called immediately after the constructor (right    // before each test).}void TearDown() override{    // Code here will be called immediately after each test (right    // before the destructor).}// Class members declared here can be used by all tests in the test suite// for Foo.</code></pre><p>};</p><p>// Tests that the Foo::Bar() method does Abc.<br>TEST_F(FooTest, MethodBarDoesAbc)<br>{<br>    EXPECT_EQ(1, 0) &lt;&lt; “1 not equal 0”;<br>}</p><p>int main(int argc, char **argv)<br>{<br>    std::cout &lt;&lt; “hello gtest” &lt;&lt; std::endl;<br>    testing::InitGoogleTest(&amp;argc, argv);<br>    return RUN_ALL_TESTS();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写`CMakeLists.txt`文件</span><br></pre></td></tr></table></figure></p><p>cmake_minimum_required(VERSION 3.10.0)<br>project(test VERSION 0.1.0 LANGUAGES C CXX)</p><p>add_executable(<br>  hello<br>  hello.cpp<br>)</p><p>target_link_libraries(<br>  hello<br>  gtest<br>  pthread<br>)<br>```<br>不用CMakelist.txt可以直接终端运行</p><h2 id="VScode-配置Gtest"><a href="#VScode-配置Gtest" class="headerlink" title="VScode 配置Gtest"></a>VScode 配置Gtest</h2><p>使用插件C++ TestMate, 并设置UT匹配格式,例如<code>&quot;testMate.cpp.test.executables&quot;: &quot;{build,Build,BUILD,out,Out,OUT}/*{UT,test,Test,TEST}*&quot;</code>, UI设置中也可以找到, 即可在侧边栏找到,实现单个UT运行, 否则直接进入debug则会从第一个UT运行到断点所在UT</p><blockquote id="fn_1"><sup>1</sup>. <a href="https://google.github.io/googletest/" target="_blank" rel="noopener">https://google.github.io/googletest/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SVD分解</title>
      <link href="2023/10/14/SVD%E5%88%86%E8%A7%A3/"/>
      <url>2023/10/14/SVD%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="SVD理解"><a href="#SVD理解" class="headerlink" title="SVD理解"></a>SVD理解</h2><p>借助矩阵$A$的4个子空间可以更好理解实际含义, $rank(A)=r$</p><ul><li>选取$v_1,\cdots,v_r$为$C(A^T)$的单位正交基</li><li>选取$v_{r+1},\cdots,v_n$为$N(A)$的单位正交基. 因为$C(A^T)\bot N(A)$, $v_1,\cdots,v_n$为$\mathbb{R}^n$的一组正交基,即$V^TV=I$</li><li>选取$u_1,\cdots,u_r$为$C(A)$中单位向量, 根据映射关系确定$\sigma_i u_i=Av_i$. 后面可以证明, $u_1,\cdots,u_r$为$C(A)$的一组正交基</li><li>选取$u_{r+1},\cdots,u_m$为$N(A^T)$的一组单位正交基, 后面证明所以$u_1,\cdots,u_m$为$\mathbb{R}^m$的一组正交基</li></ul><p>可以得到</p><script type="math/tex; mode=display">A\left[\boldsymbol{v}_{1} \cdots \boldsymbol{v}_{r}\right]=\left[\boldsymbol{u}_{1} \cdots \boldsymbol{u}_{r}\right]\left[\begin{array}{lll}\sigma_{1} & & \\& \cdot & \\& & \sigma_{r}\end{array}\right]</script><p>补充零空间可以得到</p><script type="math/tex; mode=display">AV=U\Sigma =A\left[\boldsymbol{v}_{1} \cdots \boldsymbol{v}_{n}\right]=\left[\boldsymbol{u}_{1} \cdots \boldsymbol{u}_{m}\right]\left[\begin{array}{lll}\sigma_{1} && & \\& \cdot & &\\& & \sigma_{r}&\\& & &\end{array}\right]</script><p>得到$A=U\Sigma V^T=\sigma_{1}u_1v_1^T+\cdots+\sigma_{r}u_rv_r^T$<br><strong>SVD分解就是找到一组基,从而把复杂矩阵分解成简单rank=1矩阵</strong></p><p>对应$A^TA=V\Sigma^T\Sigma V^T=V\Lambda V^T=V\begin{bmatrix}<br>\sigma_1^2  &amp;  &amp; &amp;\\<br>  &amp; \ddots  &amp; &amp;\\<br>  &amp;  &amp;\sigma_r^2&amp;\\<br>&amp; &amp; &amp; 0<br>\end{bmatrix}V^T$</p><ul><li>证明$u_1,\cdots,u_r$为$C(A)$的一组正交基, 同理由于两个子空间垂直,所以$u_1,\cdots,u_m$为$\mathbb{R}^m$的一组正交基<script type="math/tex; mode=display">u_i^Tu_j=(\frac{Av_i}{\sigma_i})^T(\frac{A\sigma_j}{\sigma_j})=\frac{v_i^TA^TAv_j}{\sigma_i\sigma_j}=\frac{v_i^TV\Lambda V^Tv_j}{\sigma_i\sigma_j}=\frac{\sigma _j^2v_i^Tv_j}{\sigma_i\sigma_j}=0</script></li></ul><p>综上所述,SVD分解为$A=U\Sigma V^T$,$U,V$分别是$\mathbb{R}^m, \mathbb{R}^n$的正交基,其中前$r$个向量分别是2个列空间的正交基,后补充向量为2个零空间的正交基</p><p><strong>SVD和特征值关系</strong><br>可以证明$A^TAv_i=V\Lambda Vv_i=\sigma _i^2v_i$, $AA^Tu_i=U\Lambda Uu_i=\sigma _i^2u_i$, 所以$A^TA,AA^T$的特征值就是$A$奇异值的平方, $v_i,u_i$分别是$A^TA,AA^T$的特征向量. 所以求解SVD也可以从特征值和特征向量入手</p><p>奇异值求解稳定,特征值受矩阵本生影响, 矩阵变化一个很小的量, 特征值可能会有明显变化<br>$A=\left[\begin{array}{llll}<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 2 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 3 \\<br>0 &amp; 0 &amp; 0 &amp; 0<br>\end{array}\right]$特征值$\lambda = 0$, 奇异值$\sigma =3,2,1$, 变化很小的量<br>$A=\left[\begin{array}{llll}<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 2 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 3 \\<br>\frac{1}{60000} &amp; 0 &amp; 0 &amp; 0<br>\end{array}\right]$ 特征值变为$\lambda=\frac{1}{10},\frac{i}{10},\frac{-1}{10},\frac{-i}{10}$, 奇异值$\sigma=3,2,1,\frac{1}{60000}$, $U,V$不变,只是分解后增加了一项很小的值$\sigma_4u_4v_4$</p><h3 id="伪逆-A"><a href="#伪逆-A" class="headerlink" title="伪逆$A^+$"></a>伪逆$A^+$</h3><p>SVD分解对应$Av_i=\sigma u_i$, 对应把$C(A^T)$空间映射到$C(A)$空间,同样我们可以想办法找到映射关系反过来映射, 即$A^+u_i=\frac{1}{\sigma}v_i$, 即</p><script type="math/tex; mode=display">A^+=V\Sigma^+ U^T=\left[\boldsymbol{v}_{1} \cdots \boldsymbol{v}_{r} \cdots \boldsymbol{v}_{n}\right]\left[\begin{array}{lll}\sigma_{1}^{-1} & & \\& \ddots & \\& & \sigma_{r}^{-1}\end{array}\right]\left[\boldsymbol{u}_{1} \cdots \boldsymbol{u}_{r} \cdots \boldsymbol{u}_{m}\right]^{\mathrm{T}}</script><p>其中$\Sigma^+$只是把$\Sigma$对应非零元素求倒,其实这里是想找到$A^{-1}$, 如果不存在的化就找到最接近的矩阵, 对应就是找$\Sigma=VAU^T$, 最接近单位矩阵就是上面的$\Sigma^+$, 对应$\Sigma^+\Sigma=\begin{bmatrix}<br>1  &amp;  &amp;  &amp; \\<br>  &amp;  \ddots &amp;  &amp; \\<br>  &amp;  &amp;  1&amp; \\<br>  &amp;  &amp;  &amp; 0<br>\end{bmatrix}$就是正交投影矩阵<br>$A^+$对应空间的映射关系如下, 刚好和$A$的映射关系相反<br><img src="/2023/10/14/SVD分解/SVDPinv.png" alt="伪逆"><br>对应$AA^+,A^+A$分别把向量投影到$C(A), C(A^T)$</p><script type="math/tex; mode=display">AA^+=U\begin{bmatrix}1  &  &  & \\  &  \ddots &  & \\  &  &  1& \\  &  &  & 0\end{bmatrix} U^T=u_1u_1^T+\cdots+u_ru_r^T</script><script type="math/tex; mode=display">A^+A=V\begin{bmatrix}1  &  &  & \\  &  \ddots &  & \\  &  &  1& \\  &  &  & 0\end{bmatrix} V^T=v_1v_1^T+\cdots+v_rv_r^T</script><p>其中$u_ru_r^T, v_rv_r^T$分别是1维投影到向量$u,v$</p><h2 id="极分解-Polar-Decomposition-A-QS"><a href="#极分解-Polar-Decomposition-A-QS" class="headerlink" title="极分解 Polar Decomposition $A = QS$"></a>极分解 Polar Decomposition $A = QS$</h2><p>极分解从SVD分解衍生而来, 把方阵分解成旋转(rotation)和拉伸(stretching), 其中Q是正交矩阵, S是半正定矩阵, 如果A可逆,则S为正定矩阵.任意实方阵都可极分解A=QS<br>考虑复数的极坐标方式$x+iy=re^{i\theta}$,可以看成1x1矩阵的极分解<br>从SVD分解可以得到两种形式的极分解<br>$A=U\Sigma V^T=(UV^T)(V\Sigma V^T)=QS$, 或者$A=U\Sigma V^T=(U\Sigma U^T)(UV^T)=SQ$</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊矩阵</title>
      <link href="2023/10/11/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5/"/>
      <url>2023/10/11/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="卡式分解"><a href="#卡式分解" class="headerlink" title="卡式分解"></a>卡式分解</h2><p>特殊矩阵可以分解成一般矩阵以便更好理解矩阵的含义, 卡氏分解 （Cartesian decomposition）可以把任何一个$n\times n$矩阵$A$分解成对称矩阵和反对称矩阵之和.<br>$A=B+C=\frac{1}{2}(A+A^T)+\frac{1}{2}(A-A^T)$<br>直接应用在与计算方阵的二次型, $x^TCx=x^TC^Tx=-x^TCx$, 即$x^TCx=0$, 所以二次型只针对卡式分解的对称部分计算即可$x^TAx=x^T\frac{A+A^T}{2}x$</p><p>正定矩阵</p><ul><li>$x^TAx&gt;0$对于任意非零向量$x$满足则是正定矩阵, $x^TAx\ge 0$则是半正定矩阵, 上面分析我们可以直接研究对称矩阵的正定性即可.实际含义就是$x$与经过线性变换后的$Ax$夹角小于等于90°</li><li>$x^TAx=1$,正定矩阵对应椭圆(高维椭球),等价于$y^Ty=(\Lambda ^{\frac{1}{2}}Q^Tx)^T(\Lambda ^{\frac{1}{2}}Q^Tx)=1$, 即$x=Q\Lambda ^{-\frac{1}{2}}y$,在另外一个空间正圆经过缩放和旋转得到椭圆, 比如原本正$x$方向点$(1, 0)$缩放后作为特征向量的系数,成为椭圆的长轴或者短轴,<br>或者$y=Q^Tx$, 得到$y^T\Lambda y=1$, 即$\lambda_1y_1^2+\lambda_2y_2^2=1$, 对应椭圆, 可以分析特征值为负数对应双曲线</li></ul><p>正定矩阵可以用于求函数最小值. 函数$f(x,y)$最小值在$\frac{\partial f}{\partial x}=0,\frac{\partial f}{\partial y}=0$且对应点导数对应对称矩阵为正定矩阵</p><script type="math/tex; mode=display">S=\begin{bmatrix}\frac{\partial^2 f}{\partial x^2}  & \frac{\partial^2 f}{\partial x\partial y}\\ \frac{\partial^2 f}{\partial x\partial y}  & \frac{\partial^2 f}{\partial y^2}\end{bmatrix}</script><p>一元函数最小值如$f(t)=t^2$,在${f}’(0)=0$, 且${f}’’(0)&gt;0 $取得最小值, 即$t=0$, 对应一阶导数为0, 二阶导数为正数, 导数求解为$f’(t)=\lim_{\Delta t \to 0}\frac{f(t+\Delta t)-f(t)}{\Delta t}$<br>二元函数$f(x,y)$偏导数$\frac{\partial f }{\partial x}=\lim_{\Delta x \to 0}\frac{f(x+\Delta x,y)-f(x,y)}{\Delta x},\frac{\partial f }{\partial y}=\lim_{\Delta y \to 0}\frac{f(x,y+\Delta y)-f(x,y)}{\Delta y}$, 另外二元函数不只是两个方向的导数,还有方向导数, 即在对应方向求曲面斜率, 两个偏导数只是在特殊的$x,y$方向而已,$(\cos \alpha, \sin \alpha)$方向导数为</p><script type="math/tex; mode=display">\begin{align}    \frac{\partial f }{\partial z} &= \lim_{\Delta z \to 0}\frac{f(x+\Delta z \cos \alpha,y+\Delta z \sin \alpha)-f(x,y)}{\Delta z} \\    &= \lim_{\Delta z \to 0}\frac{f(x+\Delta z \cos \alpha,y+\Delta z \sin \alpha)-f(x,y+\Delta z \sin \alpha)+f(x,y+\Delta z \sin \alpha)-f(x,y)}{\Delta z} \\    &= \cos \alpha \frac{\partial f}{\partial x}+\sin \alpha\frac{\partial f}{\partial y}\end{align}</script><p>对应二阶导为</p><script type="math/tex; mode=display">\begin{align}    \frac{\partial^2 f }{\partial z^2} &=\cos \alpha(\cos \alpha \frac{\partial^2 f}{\partial x^2}+\sin \alpha \frac{\partial^2 f}{\partial x\partial y}) +\sin \alpha(\cos \alpha \frac{\partial^2 f}{\partial x\partial y}+\sin \alpha \frac{\partial^2 f}{\partial y^2})\\    &= \cos^2 \alpha \frac{\partial^2 f}{\partial x^2} +2\sin \alpha \cos \alpha  \frac{\partial^2 f}{\partial x\partial y} + \sin^2\frac{\partial^2 f}{\partial y^2}\\\end{align}</script><p>同事对应正定矩阵满足$x^TSx&gt;0$,可以把$x$归一化, 即$x=\begin{bmatrix}<br>\cos \alpha  \\<br>\sin \alpha<br>\end{bmatrix}$, 最后化简得到就是指方向二阶导数全为正, 这和实际物理意义也相符合, 即在对应点的导数为0, 对应点所有方向的二阶导数都为正, 即碗状图形, 可以扩展为多元函数最小值求解</p><h3 id="实对称矩阵1"><a href="#实对称矩阵1" class="headerlink" title="实对称矩阵1"></a>实对称矩阵<sup><a href="#fn_1" id="reffn_1">1</a></sup></h3><ol><li>实对称矩阵的特征值皆是实数, 且对应特征向量是实向量<br>首先有$Ax=\lambda x,A\bar{x}=\bar{\lambda} \bar{x}$, 第二个方程左边转置并右乘特征向量$x$得到$\bar{x}^TA^Tx=\bar{x}^TAx=\lambda \bar{x}^Tx$, 等式右边$\bar{\lambda} \bar{x}^Tx$,<br>所以$(\lambda - \bar{\lambda}) \bar{x}^Tx=0$, 同时特征向量$x$非零, 所以特征值$\lambda$为实数, 特征向量为方程$(A-\lambda I)x=0$的解, 通过高斯消去法可以得到解, 同时系数矩阵为实数,所以解即特征向量也是实向量</li><li>实对称矩阵对应相异特征值的特征向量互为正交<br>设$\lambda_1\ne 0$, $\lambda_1x_1^Tx_2=(Ax_1)^Tx_2=x_1A^Tx_2=x_1Ax_2=\lambda_2x_1x_2$, 即$(\lambda_1-\lambda_2)x_1^Tx_2=0$, 由于$\lambda_1\ne \lambda_2$, 所以$x_1^Tx_2=0$,即相互垂直</li><li><p>任一$n\times n$阶实对称矩阵都有n个单范正交特征向量, 即$A=Q\Lambda Q^T$<br>预备知识</p><ul><li><p>对于$n \times n$矩阵$A$, 如果$\mathcal{X} \subseteq  \mathbb{C} ^n$是$A$的一个不变子空间且$\mathcal{X} \ne \{0\}$, 则存在非零特征向量$x \in \mathcal{X}$, 使得$Ax=\lambda x$</p><p>证明: 假定$dim\mathcal{X}=r, 0&lt;r&lt;n$, $x\in \mathcal{X}$非零, 向量集合$\begin{Bmatrix}x  &amp; Ax&amp;\cdots &amp;A^rx\end{Bmatrix}$线性相关, 即有$c_0x+c_1Ax+\cdots+c_rA^rx=0=c_s(A-u_1I)\cdots(A-u_sI)x$, 其中$c_s\ne 0, c_s&lt;r,$为最高次不为0的系数项, 所以必有$(A-u_jI)v=0$, 即对应特征值和特征向量</p></li><li><p>令$x$为实对称矩阵$A$特征向量, 如果$y\bot x$, 则$Ay \bot x$. $\mathcal{X}$为实对称矩阵$A$的不变子空间,则正交补于$\mathcal{X}^\bot$也是$A$的不变子空间</p><p>证明: $x\in \mathcal{X}$, 则$Ax\in \mathcal{X}$, 如果$y\in \mathcal{X}^\bot$, 则$Ax\bot y$.$(Ay)^Tx=0$, 即$y^TA^Tx=y^TAx=0$, 即$Ay\in \mathcal{X}^\bot$</p><p>最终证明: 反证法, 假设$A$有最多$k$个单范正交特征向量$q_1,\cdots,q_k$, 分别对应特征向量$\lambda_1, \cdots, \lambda_k$,令$\mathcal{X}=span\{q_1,\cdots,q_k\}$,则$\mathcal{X}, \mathcal{X}^\bot \ne \{0\}$为$A$的不变子空间, 则有$y\in \mathcal{X}^bot$使得$Ay=\lambda y$, 因此特征向量集还需要增加基,与前提矛盾,所以$\mathcal{X}^\bot=\{0\}$, 得证</p></li></ul></li></ol><h3 id="反对称矩阵2"><a href="#反对称矩阵2" class="headerlink" title="反对称矩阵2"></a>反对称矩阵<sup><a href="#fn_2" id="reffn_2">2</a></sup></h3><ul><li>特征值为0或者纯虚数<br>$Ax=\lambda x$, 则有$A\bar{x} =\bar{\lambda}  \bar{x} $, 两边转置并乘$x$得到$\bar{x}^TA^Tx=-\bar{x}^TAx=-\lambda\bar{x}^T x=\bar{\lambda}\bar{x}^Tx$, 所以$(\bar{\lambda}+\lambda)\bar{x}^Tx=0$, 所以特征值为纯虚数或者0(特征向量为0向量)</li><li>矩阵指数为旋转矩阵<br>旋量里面表示旋转矩阵可以用转轴求反对称矩阵后求指数得到旋转矩阵<br>可以证明$(e^{A})^{T}=e^{-A}$, $e^{A}e^{-A}=I$,后面式子可以通过展开之后推导, 所以最后得到$(e^{A})^{T}e^{A}=I$, 即反对称矩阵的矩阵指数是正交矩阵.</li></ul><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/2011/02/09/%e5%af%a6%e5%b0%8d%e7%a8%b1%e7%9f%a9%e9%99%a3%e5%8f%af%e6%ad%a3%e4%ba%a4%e5%b0%8d%e8%a7%92%e5%8c%96%e7%9a%84%e8%ad%89%e6%98%8e/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/02/09/%e5%af%a6%e5%b0%8d%e7%a8%b1%e7%9f%a9%e9%99%a3%e5%8f%af%e6%ad%a3%e4%ba%a4%e5%b0%8d%e8%a7%92%e5%8c%96%e7%9a%84%e8%ad%89%e6%98%8e/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://ccjou.wordpress.com/2010/08/27/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%99%A313%EF%BC%9A%E5%8F%8D%E5%B0%8D%E7%A8%B1%E7%9F%A9%E9%99%A3/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/08/27/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%99%A313%EF%BC%9A%E5%8F%8D%E5%B0%8D%E7%A8%B1%E7%9F%A9%E9%99%A3/</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵微积分</title>
      <link href="2023/10/08/%E7%9F%A9%E9%98%B5%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
      <url>2023/10/08/%E7%9F%A9%E9%98%B5%E5%BE%AE%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵复特征值含义1"><a href="#矩阵复特征值含义1" class="headerlink" title="矩阵复特征值含义1"></a>矩阵复特征值含义<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><p>考虑微分方程$\frac{d\mathbf{u}}{dt}=A\mathbf{u}$, 如果2x2矩阵$A$的特征值为复数$\lambda$, 可推得特征向量$\mathbf{x}$也是复数(通过$Ax=\lambda x$),特解$\mathbf{u}=e^{\lambda t}\mathbf{x}$, 同理可以推导得到$\bar{\mathbf{u}}$也是特解,所以通解为</p><script type="math/tex; mode=display">y=c_1\mathbf{u}+c_2\bar{\mathbf{u}}</script><p>这里可以通过假设两个特解线性相关, 推导得到特征向量必须为实数,这与实际相悖,所系线性无关</p><p>由于实际解$y$为实数, 可以根据已经得到的解进行组合得到另外的形式, 比如取实部和虚部<br>$Re(\mathbf{u})=\frac{1}{2}(\mathbf{u}+\bar{\mathbf{u}})$<br>$Im(\mathbf{u})=\frac{1}{2i}(\mathbf{u}-\bar{\mathbf{u}})$<br>同理也可以证明线性无关, 所以最后通解$y=c_1Re(\mathbf{u})+c_2Im(\mathbf{u})$, 其中系数由初始条件决定</p><p>线性无关也可以通过可逆矩阵进行证明,即</p><script type="math/tex; mode=display">\begin{bmatrix}Re(\mathbf{u})  & Im(\mathbf{u})\end{bmatrix}=\begin{bmatrix}\mathbf{u}  & \bar{\mathbf{u}}\end{bmatrix}\begin{bmatrix}\frac{1}{2}  & \frac{1}{2i} \\ \frac{1}{2}  & -\frac{1}{2i}\end{bmatrix}</script><p>可以得到如下表示, 即两组基可以相互表示,充满解空间, 本生向量空间乘可逆矩阵不会改变空间维度,右乘可逆矩阵不改变向量的列空间$C(A)$, 左乘可逆矩阵不改变向量的行空间$C(A^T)$<br>$<br>\begin{bmatrix}<br>Re(\mathbf{u})  &amp; Im(\mathbf{u})<br>\end{bmatrix}=\begin{bmatrix}<br>\mathbf{u}  &amp; \bar{\mathbf{u}}<br>\end{bmatrix}B<br>$<br>$<br>\begin{bmatrix}<br>Re(\mathbf{u})  &amp; Im(\mathbf{u})<br>\end{bmatrix}B^{-1}=\begin{bmatrix}<br>\mathbf{u}  &amp; \bar{\mathbf{u}}<br>\end{bmatrix}<br>$</p><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/2010/06/07/%e8%a7%a3%e8%ae%80%e8%a4%87%e6%95%b8%e7%89%b9%e5%be%b5%e5%80%bc/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/06/07/%e8%a7%a3%e8%ae%80%e8%a4%87%e6%95%b8%e7%89%b9%e5%be%b5%e5%80%bc/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本矩阵</title>
      <link href="2023/09/09/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5/"/>
      <url>2023/09/09/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#基本矩阵定义1">基本矩阵定义</a><ul><li><a href="#初等行变换对应基本矩阵">初等行变换对应基本矩阵</a></li></ul></li><li><a href="#基本矩阵的几何意义2">基本矩阵的几何意义</a><ul><li><a href="#基本矩阵的特征值">基本矩阵的特征值</a></li><li><a href="#几何意义">几何意义</a></li></ul></li><li><a href="#矩阵和的行列式3">矩阵和的行列式</a></li></ul><!-- /code_chunk_output --><h2 id="基本矩阵定义1"><a href="#基本矩阵定义1" class="headerlink" title="基本矩阵定义1"></a>基本矩阵定义<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><p>理解复杂系统关键是找到里面的基本元素, 对应一般矩阵则是找到基本矩阵,研究基本矩阵则可以知道一般矩阵的含义</p><p>令$u,v$为$n$维实(复)列向量,若$v^Tu \ne -1$, 则$I+uv^T$为基本矩阵, 其中$uv^T \in \mathbb{R}^{n\times n}$(外积), 如果$u,v$其中有1个为零向量,则基本矩阵退化为单位矩阵</p><p>基本矩阵转置也是基本矩阵$(I+uv^T)^T=I+vu^T$, 其中$v^Tu=u^Tv\ne 1$</p><p>猜测基本矩阵的逆也是基本矩阵$(I+uv^T)^{-1}=I+kuv^T$, 则有</p><script type="math/tex; mode=display">(I+uv^T)(I+kuv^T)=I+(1+k+kv^Tu)uv^T</script><p>上式子右边等于$I$, 得到$k=-\frac{1}{(1+v^Tu)}$, 这也是需要$v^Tu\ne -1$的原因</p><p>计算基本矩阵行列式$|I=uv^T|=|I|+v^T(adjI)u=1+v^Tu$, 其中$I=\frac{adjI}{|I|}=adjI$, 其中$adjI$表示$I$的伴随矩阵</p><h3 id="初等行变换对应基本矩阵"><a href="#初等行变换对应基本矩阵" class="headerlink" title="初等行变换对应基本矩阵"></a>初等行变换对应基本矩阵</h3><p>在高斯消去法中, 每个基本的行变换都对应1个基本矩阵,</p><ol><li>交换, 行$i$于行$j$互换位置</li><li>伸缩, 行$i$乘非零常数$c$</li><li>取代, 行$i$乘非零常数$c$的结果加进行$j$, $i\ne j$<br>对单位矩阵进行初等行变换即为基本矩阵</li></ol><p>例如3维基本矩阵可以归纳处基本矩阵的形态$I+uv^T$</p><script type="math/tex; mode=display">\begin{array}{l}E_{1}=\left[\begin{array}{lll}0 & 1 & 0 \\1 & 0 & 0 \\0 & 0 & 1\end{array}\right]=I+\left[\begin{array}{rrr}-1 & 1 & 0 \\1 & -1 & 0 \\0 & 0 & 0\end{array}\right]=I+\left[\begin{array}{r}1 \\-1 \\0\end{array}\right]\left[\begin{array}{lll}-1 & 1 & 0\end{array}\right]=I+\left(\mathbf{e}_{1}-\mathbf{e}_{2}\right)\left(\mathbf{e}_{2}-\mathbf{e}_{1}\right)^{T}, \\E_{2}=\left[\begin{array}{lll}1 & 0 & 0 \\0 & c & 0 \\0 & 0 & 1\end{array}\right]=I+\left[\begin{array}{ccc}0 & 0 & 0 \\0 & c-1 & 0 \\0 & 0 & 0\end{array}\right]=I+(c-1)\left[\begin{array}{l}0 \\1 \\0\end{array}\right]\left[\begin{array}{lll}0 & 1 & 0\end{array}\right]=I+(c-1) \mathbf{e}_{2} \mathbf{e}_{2}^{T}, \\E_{3}=\left[\begin{array}{lll}1 & 0 & 0 \\c & 1 & 0 \\0 & 0 & 1\end{array}\right]=I+\left[\begin{array}{lll}0 & 0 & 0 \\c & 0 & 0 \\0 & 0 & 0\end{array}\right]=I+c\left[\begin{array}{l}0 \\1 \\0\end{array}\right]\left[\begin{array}{lll}1 & 0 & 0\end{array}\right]=I+c \mathbf{e}_{2} \mathbf{e}_{1}^{T},\end{array}</script><p>其中, $e_i$是第$i$个标准单位向量(第$i$元=1,其余为0), 推广到$n$维矩阵如下, 并使用基本矩阵逆矩阵计算公式推导逆矩阵</p><ol><li>交换, 行$i$于行$j$互换位置: $E_1=I_n-(e_i-e_j)(e_j-e_i)^T$, 计算逆矩阵得$E_1^{-1}=E_1$, 连续两次交换就是单位矩阵并没有做什么</li><li>伸缩, 行$i$乘非零常数$c$: $E_2(c)=I_n+(c-1)e_ie_i^{T}$, $E_2(c)^{-1}=E_c(\frac{1}{c})$</li><li>取代, 行$i$乘非零常数$c$的结果加进行$j$, $i\ne j$: $E_3(c)=I_n+ce_ie_j^T$, $E_3(c)^{-1}=E_3(-c)$</li></ol><p><strong>定理: 方阵$A$非奇异的充要条件是$A$为基本矩阵乘积</strong></p><ul><li>如果$A$非奇异,使用高斯-约当法把矩阵化简直至单位矩阵, 则$E_k\cdots E_2E_1A=I$, 得到$A=E_1^{-1}E_2^{-1}\cdots E_k^{-1}$</li><li>如果$A=E_1E_2\cdots E_n$, 基本矩阵非奇异, 乘积也非奇异, 因为$|A|=|E_1E_2\cdots E_n|=|E_1||E_2|\cdots |E_n|=\ne 0$</li></ul><h2 id="基本矩阵的几何意义2"><a href="#基本矩阵的几何意义2" class="headerlink" title="基本矩阵的几何意义2"></a>基本矩阵的几何意义<sup><a href="#fn_2" id="reffn_2">2</a></sup></h2><h3 id="基本矩阵的特征值"><a href="#基本矩阵的特征值" class="headerlink" title="基本矩阵的特征值"></a>基本矩阵的特征值</h3><p>$(I+uv^T)u=(1 + v^Tu)u$, 所以$1+v^Tu$和$u$分别是特征值和特征向量.<br>另外考虑垂直于$v$的$n-1$子空间$\mathcal{V}$线性独立向量$x_1, x_2,\cdots, x_{n-1}$, 则有$(I+uv^T)x_i=x_i$, $1,x_i$分别为特征值和特征向量, 又有$u\notin \mathcal{V}$, 所以</p><script type="math/tex; mode=display">I+uv^T=S\begin{bmatrix}1+v^Tu  &  & &\\  &  1& &\\  &  & \ddots & \\  &  & &1\end{bmatrix}S^{-1}</script><p>其中$S=\begin{bmatrix}  u&amp;  x_1&amp;  \cdots &amp; x_{n-1}\end{bmatrix}$, 所以$|I+uv^T|=1+v^Tu$</p><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>$(I+uv^T)x=x+(v^Tx)u$, 所以基本矩阵就是对输入矢量$x$进行平移$(v^Tx)u$</p><ol><li>基本镜射矩阵, 令$||u||=1$, $v=-2u$, 对应$H=I-2uu^T$<br><img src="/2023/09/09/基本矩阵/镜射矩阵.jpg" alt="镜射矩阵"></li><li>基本投影矩阵, 令$||u||=1$, $v=-u$, 得到$P=I-uu^T$<br><img src="/2023/09/09/基本矩阵/投影矩阵.jpg" alt="投影矩阵"></li><li>基本列运算矩阵, 参考上面3个初等行变换矩阵</li></ol><ul><li>交换: $E_1=I_n-(e_i-e_j)(e_j-e_i)^T = E_1-2uu^T$, 其中$u=\frac{1}{\sqrt{2}}\frac{e_i-e_j}{||e_i-e_j||}$, 所以交换矩阵就是按照$e_i-e_j$为超镜射平面法向量的基本镜射矩阵</li><li>伸缩: $E_2x=x+(c-1)e_ie_i^{T}x$, 说明只是把$x_i$伸缩了$c$倍</li><li>取代, 行$E_3x=x+ce_ie_j^Tx$, 把向量$x$沿着$e_i$方向平移了$cx_j$单位</li></ul><h2 id="矩阵和的行列式3"><a href="#矩阵和的行列式3" class="headerlink" title="矩阵和的行列式3"></a>矩阵和的行列式<sup><a href="#fn_3" id="reffn_3">3</a></sup></h2><p>矩阵乘积行列式比较简单$|AB|=|A||B|$, 矩阵和的行列式相对比较麻烦</p><ol><li>首先证明$|A+UV^T|=|I_m+V^TA^{-1}U||A|$, 其中$A$为可逆矩阵, $B=UV^T$, 其中$U,V\in \mathcal{R}^{n\times n}$<br>设计分块矩阵<script type="math/tex; mode=display">\left[\begin{array}{cc}A^{-1} & 0 \\V^{T} A^{-1} & I_{m}\end{array}\right]\left[\begin{array}{cc}A & U \\-V^{T} & I_{m}\end{array}\right]=\left[\begin{array}{cc}I_{n} & A^{-1} U \\0 & I_{m}+V^{T} A^{-1} U\end{array}\right]</script>对应求行列式得到<script type="math/tex; mode=display">\begin{vmatrix}A & U \\-V^{T} & I_{m}\end{vmatrix}=\begin{vmatrix}I_{n} & A^{-1} U \\0 & I_{m}+V^{T} A^{-1} U\end{vmatrix}\begin{vmatrix}A^{-1} & 0 \\V^{T} A^{-1} & I_{m}\end{vmatrix}^{-1}=|I_{m}+V^{T} A^{-1} U||A|</script>同时设计分块矩阵<script type="math/tex; mode=display">\left[\begin{array}{cc}A & U \\-V^{T} & I_{m}\end{array}\right]\left[\begin{array}{cc}I_n & 0 \\V^T & I_{m}\end{array}\right]=\left[\begin{array}{cc}A+UV^T & A^{-1} U \\0 & I_{m}\end{array}\right]</script>求行列式证明原等式<script type="math/tex; mode=display">|A+UV^T|=\begin{vmatrix}A & U \\-V^{T} & I_{m}\end{vmatrix}=|I_{m}+V^{T} A^{-1} U||A|</script></li><li>对应特殊矩阵,当$m=1$时, $U=u, V=v$为$n$维列向量,则有<script type="math/tex; mode=display">|A+uv^T|=(1+v^TA^{-1}u)|A|=|A|+v^T(adjA)u</script>其中$adjA$为$A$的伴随矩阵</li></ol><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/2010/02/02/%e7%89%b9%e6%ae%8a%e7%9f%a9%e9%99%a3-%e5%8d%81%ef%bc%9a%e5%9f%ba%e6%9c%ac%e7%9f%a9%e9%99%a3/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/02/02/%e7%89%b9%e6%ae%8a%e7%9f%a9%e9%99%a3-%e5%8d%81%ef%bc%9a%e5%9f%ba%e6%9c%ac%e7%9f%a9%e9%99%a3/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><p><sup><a href="#fn_2" id="reffn_2">2</a></sup>:　<a href="https://ccjou.wordpress.com/2011/01/10/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%99%A3%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/01/10/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%99%A3%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/</a></p><blockquote id="fn_3"><sup>3</sup>. <a href="https://ccjou.wordpress.com/2009/12/04/%e7%9f%a9%e9%99%a3%e5%92%8c%e4%b9%8b%e8%a1%8c%e5%88%97%e5%bc%8f-%e4%b8%8a/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2009/12/04/%e7%9f%a9%e9%99%a3%e5%92%8c%e4%b9%8b%e8%a1%8c%e5%88%97%e5%bc%8f-%e4%b8%8a/</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数概览</title>
      <link href="2023/07/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>2023/07/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#vector-spaces">Vector Spaces</a><ul><li><a href="#向量空间基本定义">向量空间基本定义</a></li><li><a href="#线性独立">线性独立</a></li><li><a href="#子空间并集与交集计算">子空间并集与交集计算</a></li><li><a href="#矩阵乘法">矩阵乘法</a></li></ul></li><li><a href="#4个基本子空间">4个基本子空间</a><ul><li><a href="#行阶梯形矩阵4个子空间">行阶梯形矩阵4个子空间</a></li><li><a href="#矩阵4个基本子空间">矩阵4个基本子空间</a></li><li><a href="#矩阵乘积子空间10">矩阵乘积子空间</a></li><li><a href="#列空间和零空间互换表达">列空间和零空间互换表达</a></li></ul></li><li><a href="#投影矩阵">投影矩阵</a></li><li><a href="#正交基和施密特正交化">正交基和施密特正交化</a><ul><li><a href="#正交基的优良特性">正交基的优良特性</a></li><li><a href="#施密特正交化">施密特正交化</a></li><li><a href="#qr分解">QR分解</a></li></ul></li><li><a href="#行列式">行列式</a><ul><li><a href="#cramers-rule">Cramer’s Rule</a></li><li><a href="#行列式常见含义">行列式常见含义</a></li></ul></li><li><a href="#特征值--特征向量">特征值 &amp; 特征向量</a></li><li><a href="#矩阵对角化">矩阵对角化</a><ul><li><a href="#矩阵幂计算">矩阵幂计算</a></li><li><a href="#相似矩阵">相似矩阵</a></li></ul></li><li><a href="#微分方程">微分方程</a><ul><li><a href="#对称矩阵">对称矩阵</a></li></ul></li><li><a href="#未同步补充项">未同步补充项</a><ul><li><a href="#小知识点">小知识点</a></li></ul></li></ul><!-- /code_chunk_output --><p>重点参考教程<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><h1 id="Vector-Spaces-and-Linear-Transformations"><a href="#Vector-Spaces-and-Linear-Transformations" class="headerlink" title="Vector Spaces and Linear Transformations"></a>Vector Spaces and Linear Transformations</h1><h2 id="Vector-Spaces"><a href="#Vector-Spaces" class="headerlink" title="Vector Spaces"></a>Vector Spaces</h2><h3 id="向量空间基本定义"><a href="#向量空间基本定义" class="headerlink" title="向量空间基本定义"></a>向量空间基本定义</h3><p>向量空间$\mathcal{V}$(矢量空间)中,向量的加法和乘法满足8个公理, 提供了支持演算需要的重组, 分解与化简得规则:</p><ol><li>加法交换律: $x+y=y+x$</li><li>加法结合率: $x+(y+z)=(x+y)+z$</li><li>矢量单位: 存在位移的$0\in \mathcal{V}$, 使得$x+0=x$</li><li>逆元: 存在唯一的$-x\in \mathcal{V}$, 使得$x+(-x)=0$</li><li>向量分配率: $(\alpha + \beta)x=\alpha x + \beta x$, $\alpha, \beta \in F$</li><li>纯量分配率: $\alpha (x + y)=\alpha x + \alpha y$</li><li>结合率:$\alpha(\beta x)=\alpha \beta x$</li><li>纯量单位元: 存在唯一$1\in F$使得$1x=x$</li></ol><p>其中, 纯量$\alpha, \beta \in F$属于1个体(field), 比如实数系或复数系$\mathbb{R}, \mathbb{C}$</p><p>向量空间=向量集合+向量加法与纯量乘法+8个公理, 对应子空间=子集合+向量加法与纯量乘法+8个公理<br>向量空间需要满足封闭性: ${\forall} x,y \in \mathcal{V}$, 则有$cx+dy \in \mathcal{V}$</p><p><strong>同构向量空间</strong>:实际使用中很多场景可以等效成向量空间, 比如多项式操作:加法和纯量乘法, 可以把多项式表示乘以对应变量的幂为基, 对应项为坐标, $f=a_0+a_1x+a_2x^2+\cdots a_nx^n$, 表示成$(a_0,a_1,\cdots,a_n)$<br>向量空间是线性代数处理的主要对象, 使向量空间有趣的就是线性变换:<br>$T(x+y)=T(x)+T(y)$, $T(cx)=cT(x)$<br>如果$S,T$为线性变换, 可以定义加法和纯量乘法$P=S+T,Q=cT$, 分别表示为$P(x)=S(x)+T(x), Q(x)=cT(x)$, 从这里看<strong>线性变换也是矢量空间</strong>, 微积分就满足线性变换</p><p><strong>同构</strong>: 如果$\mathcal{U}, \mathcal{V}$布于相同数系得矢量空间, 且$x\in \mathcal{U}, y\in \mathcal{V}$存在一一对应关系, 表示为线性变换$y=T(x)$, 则称$\mathcal{U}, \mathcal{V}$同构(isomorphic), $\mathcal{U} \cong  \mathcal{V}$, 即$T$是保留结构得同构映射, 只需要证明任意$n$维度矢量空间$\mathcal{V}$和某个特定$n$维向量空间同构,特定矢量空间选为即$\mathbb{R}^n, \mathbb{C}^n$, 那么任意$n$维矢量空间性质可由特定矢量空间性质得到</p><p>比如坐标变换, $\beta=\{x_1,\cdots,x_n\}$为向量空间$\mathcal{V}$一组基, 则对$x\in \mathcal{V}$, 有$x=c_1x_1+\cdots+c_nx_n$, 对应线性变换$L(x) \rightleftharpoons x_{\beta}=(c_1,\cdots,c_n)$, 和上面多项式同理也可得到$n$维坐标值, 所以两个空间从线性变换来看使同构</p><h4 id="线性变换用矩阵表示"><a href="#线性变换用矩阵表示" class="headerlink" title="线性变换用矩阵表示"></a>线性变换用矩阵表示</h4><p>向量空间中最重要的就是基底, 存在线性变换$T:\mathcal{V}\to \mathcal{W}$, 能够将线性变换用矩阵$A$表示<br>向量空间$\mathcal{W}$基底$\alpha=(w_1,w_2,\cdots,w_n)$, $\mathcal{V}$基底$\beta=(v_1,v_2,\cdots,v_n)$, 对于向量$x=\alpha a$, 其中$a=(a_1,a_2,\cdots,a_n)^T$, 向量$y=\beta b$, 其中$b=(b_1,b_2,\cdots,b_n)^T$<br>则有</p><script type="math/tex; mode=display">T\alpha=\beta \begin{bmatrix}c_{11}  & \cdots & c_{1n}\\\vdots  & \vdots & \vdots\\c_{n1}  & \cdots & c_{nn}\end{bmatrix}=\beta A</script><p>对应</p><script type="math/tex; mode=display">T(x)=T(\alpha a)=\begin{pmatrix}T(w_1)a_1  & \cdots &T(w_n)a_n\end{pmatrix}=\beta Aa</script><p>所以从坐标$a$,变换成坐标$Aa$, 本质上使用的是同构,复空间$\mathbb{C}^n$相同</p><h3 id="线性独立"><a href="#线性独立" class="headerlink" title="线性独立"></a>线性独立</h3><p>向量空间的任意向量可由一组最少向量的线性组合表示, 即基底, 即基底之间是不能相互表示,即线性无关, 对应$(v_1,v_2,\cdots,v_n)$线性独立, 等价于仅存在$c_1=c_2=\cdots =c_n=0$, 使得$c_1v_1+c_2v_2+\cdots+c_nv_n=0$</p><p>可证明向量空间中任意向量可由基底唯一表示,唯一性非常重要,　证明如下<br>$x=a_1v_1+a_2v_2+\cdots+a_nv_n$, 同时有$x=b_1v_1+b_2v_2+\cdots+b_nv_n$, 则$0=(a_1-b_1)v_1+(a_2-b_2)v_2+\cdots+(a_n-b_n)v_n$, 又由于线性无关, 所以$\mathbf{a} =\mathbf{b}$</p><p>已知矩阵$A$求解向量空间基, 可以化简为行阶最简梯形矩阵, 可以以此得到线性无关项, 以及对应列之间的线性关系. $PA=C$, 其中$P,C$分别为基本矩阵的乘积, 行阶最简梯形矩阵. $C$的线性关系可以表示为$Ck=0$, $k=(k_1,k_2,\cdots,k_n)^T$, 可以证明$Ak=P^{-1}Ck=0$, 说明$C,A$的列对应的线性关系相同, 所以$C$中线性无关的列就是$A$中线性无关的列,可以作为基底. 初等矩阵左乘矩阵$A$就是对行进行操作,不会改变行空间, 并保留列空间的线性关系. 同样的右乘就是对列进行操作, 不改变列空间, 并保留行空间线性关系</p><h4 id="矩阵左右乘含义"><a href="#矩阵左右乘含义" class="headerlink" title="矩阵左右乘含义"></a>矩阵左右乘含义</h4><ul><li>矩阵左乘保留列向量关系<br>$PA=B$, 其中$A=(a_1,a_2,\cdots,a_n), B=(b_1,b_2,\cdots,b_n)$, 对于任意向量$a_j=Ac\in \mathcal{A}$, 则对应变换后向量$b_j=Pa_j=PAc=Bc$, 即$\mathcal{A}$空间线性关系可推导$\mathcal{B}$线性关系.当$P$可逆则可以通过$\mathcal{B}$推导$\mathcal{A}$线性关系, 但是如果不可逆,那$\mathcal{B}$保留$\mathcal{A}$的线性关系,但是没办法通过$\mathcal{B}$推导$\mathcal{A}$线性关系;<br>可逆矩阵左乘不改变行空间: $\forall b \in C(B^T)$, 即$b=x^TB=x^TPA=y^TA$, 即$B \subset A$, 同理如果$P$可逆, 则可以证明$A \subset B$, 所以行空间不变$C(A^T)=C(B^T)$</li><li>矩阵右乘保留行向量关系<br>有$A^TP^T=B^T$, 上面分析已经得到左乘关系, 即$A^T, B^T$行向量保持关系,如果$P$可逆</li></ul><h3 id="子空间并集与交集计算"><a href="#子空间并集与交集计算" class="headerlink" title="子空间并集与交集计算"></a>子空间并集与交集计算</h3><ul><li>合集<br>针对列空间表达$\mathcal{X}=C(X),\mathcal{Y}=C(Y)$<script type="math/tex; mode=display">\mathcal{X} \bigcup \mathcal{Y}=C(\begin{bmatrix} X & Y \end{bmatrix})</script>针对零空间表达$\mathcal{X}=N(A),\mathcal{Y}=N(B)$, 可以先转化为列空间表达再用上面的结果</li><li>交集<br>零空间表达如下<script type="math/tex; mode=display">\mathcal{X} \bigcap \mathcal{Y}= N(\begin{bmatrix}A \\ B\end{bmatrix})</script>列空间可以先转化为行空间再计算, 也可以通过另外一种更简便的方式计算.<br>交集即意味着对应向量可以同时被两个空间表达,即$w=c_1x_1+\cdots c_px_p=d_1y_1+\cdots d_qy_q$化简得到<script type="math/tex; mode=display">\begin{bmatrix}X  & -Y\end{bmatrix}\begin{bmatrix}c \\ d\end{bmatrix}=0</script>对应结果为求零空间得到$c$, 可能有多列,意味着交集的维数, 最后交集为$C(Xc)$</li></ul><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>矩阵乘法最初就是简化复合线性变换表示得到的<sup><a href="#fn_7" id="reffn_7">7</a></sup>, 比如两个线性映射</p><script type="math/tex; mode=display">\begin{array}{l}f\left(\begin{array}{l}x \\y\end{array}\right)=\left(\begin{array}{l}a x+b y \\c x+d y\end{array}\right) \\g\left(\begin{array}{l}x \\y\end{array}\right)=\left(\begin{array}{l}p x+q y \\r x+s y\end{array}\right) .\end{array}</script><p>得到复合映射:</p><script type="math/tex; mode=display">\begin{aligned}h\left(\begin{array}{l}x \\y\end{array}\right) & =f\left(g\left(\begin{array}{l}x \\y\end{array}\right)\right)=f\left(\begin{array}{l}p x+q y \\r x+s y\end{array}\right) \\& =\left(\begin{array}{l}a(p x+q y)+b(r x+s y) \\c(p x+q y)+d(r x+s y)\end{array}\right) \\& =\left(\begin{array}{l}(a p+b r) x+(a q+b s) y \\(c p+d r) x+(c q+d s) y\end{array}\right) .\end{aligned}</script><p>如果用阵列表示线性映射系数, 得到最后的矩阵乘法表示</p><script type="math/tex; mode=display">\left[\begin{array}{ll}a & b \\c & d\end{array}\right]\left[\begin{array}{ll}p & q \\r & s\end{array}\right]=\left[\begin{array}{ll}a p+b r & a q+b s \\c p+d r & c q+d s\end{array}\right]</script><h4 id="矩阵乘法的现代定义"><a href="#矩阵乘法的现代定义" class="headerlink" title="矩阵乘法的现代定义"></a>矩阵乘法的现代定义</h4><p>最好的理解方式是通过线性组合的定义推导其它表示方式</p><ol><li>以列作为计算单元, 线性组合<script type="math/tex; mode=display">A \mathbf{x}=\left[\begin{array}{lll}\mathbf{a}_{1} & \cdots & \mathbf{a}_{n}\end{array}\right]\left[\begin{array}{c}x_{1} \\\vdots \\x_{n}\end{array}\right]=\mathbf{a}_{1} x_{1}+\cdots+\mathbf{a}_{n} x_{n}</script></li><li><p>以列作为单元定义$AB$<br>参考上面线性组合定义</p><script type="math/tex; mode=display">\begin{aligned}A(B \mathbf{x}) & =A\left(x_{1} \mathbf{b}_{1}+\cdots+x_{p} \mathbf{b}_{p}\right)=x_{1}\left(A \mathbf{b}_{1}\right)+\cdots+x_{p}\left(A \mathbf{b}_{p}\right) \\& =\left[\begin{array}{lll}A \mathbf{b}_{1} & \cdots & A \mathbf{b}_{p}\end{array}\right]\left[\begin{array}{c}x_{1} \\\vdots \\x_{p}\end{array}\right]=\left[\begin{array}{lll}A \mathbf{b}_{1} & \cdots & A \mathbf{b}_{p}\end{array}\right] \mathbf{x} .\end{aligned}</script><p>这种方式可用于证明分配律</p><script type="math/tex; mode=display">\begin{aligned}A(B+C) & =A\left[\begin{array}{lll}\mathbf{b}_{1}+\mathbf{c}_{1} & \cdots & \mathbf{b}_{p}+\mathbf{c}_{p}\end{array}\right] \\& =\left[\begin{array}{lll}A\left(\mathbf{b}_{1}+\mathbf{c}_{1}\right) & \cdots & A\left(\mathbf{b}_{p}+\mathbf{c}_{p}\right)\end{array}\right] \\& =\left[\begin{array}{llll}A \mathbf{b}_{1}+A \mathbf{c}_{1} & \cdots & A \mathbf{b}_{p}+A \mathbf{c}_{p}\end{array}\right] \\& =\left[\begin{array}{llll}A \mathbf{b}_{1} & \cdots & A \mathbf{b}_{p}\end{array}\right]+\left[\begin{array}{lll}A \mathbf{c}_{1} & \cdots & A \mathbf{c}_{p}\end{array}\right] \\& =A B+A C .\end{aligned}</script></li><li><p>以元作为计算单元<br>参考线性组合表示方式可以得到</p><script type="math/tex; mode=display">A \mathbf{x}=\left[\begin{array}{lll}\mathbf{a}_{1} & \cdots & \mathbf{a}_{n}\end{array}\right]\left[\begin{array}{c}x_{1} \\\vdots \\x_{n}\end{array}\right]=\begin{bmatrix}row_1(A)x \\\vdots \\row_1(A)x\end{bmatrix}</script><p>进一步推导可得</p><script type="math/tex; mode=display">(A B)_{i j}=\left[\begin{array}{lll}a_{i 1} & \cdots & a_{i n}\end{array}\right]\left[\begin{array}{c}b_{1 j} \\\vdots \\b_{n j}\end{array}\right]=a_{i 1} b_{1 j}+\cdots+a_{i n} b_{n j}</script></li><li><p>以行作为计算单元定义$AB$<br>类似上面, 只需要转置一下原本</p><script type="math/tex; mode=display">(AB)^T=B^TA^T=\begin{aligned}\left[\begin{array}{c}b_{1}^TA^T \\\vdots \\b_{p}^TA^T\end{array}\right]\end{aligned}</script></li><li>以行列展开计算$AB$<script type="math/tex; mode=display">AB=\begin{bmatrix}a_1  & \cdots  &a_n\end{bmatrix}\begin{bmatrix}row_1(B) \\\vdots \\row_n(B)\end{bmatrix}=a_1row_1(B)+\cdots+a_nrow_n(B)</script>证明方式: 参考$(AB)_{ij}$计算方式发现和第3个表示方式完全相同</li><li>以分块作为计算单元<br>首先分别推导小分块矩阵计算</li></ol><ul><li>行x列计算<script type="math/tex; mode=display">AB=A(B_1,B_2)=(AB_1,AB_2)=\begin{bmatrix}\begin{bmatrix}A_1 \\A_2\end{bmatrix}(B_1)  &\begin{bmatrix}A_1 \\A_2\end{bmatrix}(B_2)\end{bmatrix}=\begin{bmatrix}A_1B_1  & A_1B_2\\A_2B_1  &A_2B_2\end{bmatrix}=\begin{bmatrix}A_1\\A_2\end{bmatrix}\begin{bmatrix}B_1 & B_2\end{bmatrix}</script></li><li>列x行计算<script type="math/tex; mode=display">Ax=\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}x_1  \\x_2\end{bmatrix}=A_1x_1+A_2x_2</script><script type="math/tex; mode=display">AB= (Ab_1,Ab_2,\cdots,Ab_n) \\=\begin{bmatrix}\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}c_1  \\d_1\end{bmatrix} &\cdots &\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}c_n  \\d_n\end{bmatrix}\end{bmatrix}\\=\begin{bmatrix}A_1c_1+A_2d_1  & \cdots &A_1c_n+A_2d_n\end{bmatrix}\\=A_1\begin{bmatrix}c_1  & \cdots &c_n\end{bmatrix}+A_2\begin{bmatrix}d_1  & \cdots &d_n\end{bmatrix}\\=A_1B_1+A_2B_2=\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}B_1  \\B_2\end{bmatrix}</script>最后用$A_1=\begin{bmatrix}A_3  &amp;A_4\end{bmatrix}$, $A_2=\begin{bmatrix}A_5  &amp;A_6 \end{bmatrix}$, $B_1=\begin{bmatrix} B_3  &amp;B_4 \end{bmatrix}$,$B_2=\begin{bmatrix} B_4  &amp;B_6 \end{bmatrix}$, 代入行x列计算, 并结合列x行计算最后得到分块矩阵计算方式<script type="math/tex; mode=display">AB=\begin{bmatrix}A_3  & A_4\\A_5  &A_6\end{bmatrix}\begin{bmatrix}B_3  & B_4\\B_5  &B_6\end{bmatrix}=\begin{bmatrix}A_3B_3+A_4B_5  & A_3B_4+A_4B_6\\A_5B_3+A_6B_5  &A_5B_4+A_6B_6\end{bmatrix}</script></li></ul><p>矩阵乘法交换律证明<br>根据上面第二步定义$A(Bx)=ABx$,则有</p><script type="math/tex; mode=display">A(BC)=A\begin{bmatrix}Bc_1  & \cdots &Bc_n\end{bmatrix}=\begin{bmatrix}ABc_1  & \cdots &ABc_n\end{bmatrix}=AB\begin{bmatrix}c_1  & \cdots &c_n\end{bmatrix}=ABC</script><p>反过头来所有上述表示最后都可以作为分块矩阵的特例</p><h2 id="4个基本子空间"><a href="#4个基本子空间" class="headerlink" title="4个基本子空间"></a>4个基本子空间</h2><p>对于矩阵$A$来说最终要的4个空间对应列空间$C(A)$, $C(A^T)$, 零空间$N(A)$, $N(A^T)$</p><p>一般矩阵可以经过初等行变换转换为行阶梯形矩阵$EA=R$, 首先对行阶梯形矩阵进行分析</p><h3 id="行阶梯形矩阵4个子空间"><a href="#行阶梯形矩阵4个子空间" class="headerlink" title="行阶梯形矩阵4个子空间"></a>行阶梯形矩阵4个子空间</h3><p>针对常见行阶矩阵$m=3,n=5$<br>$\boldsymbol{R}=\left[\begin{array}{lllll}<br>\mathbf{1} &amp; \mathbf{3} &amp; \mathbf{5} &amp; 0 &amp; \mathbf{7} \\<br>0 &amp; 0 &amp; 0 &amp; \mathbf{1} &amp; \mathbf{2} \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0<br>\end{array}\right]$<br>从行阶梯形矩阵可以得到</p><ol><li>$Dim(C(R^T))=Dim(C(R))=2$, 行空间和列空间的秩相等$r=2$, 矩阵的行秩=矩阵的列秩=矩阵pivots个数. 可以把矩阵化简成行阶最简梯形比较, 首先$E_1AE_2$交换矩阵的行和列确保能化简成$\begin{bmatrix}<br>I_r  &amp; F\\<br>0  &amp; 0<br>\end{bmatrix}$, 对应化简后矩阵秩为$r$</li><li>$Dim(N(R))=n-r$, pivots对应列为1,4,自由变量变量对应2,3,5,即对于$Rx=0$,分别单独设置自由变量为1得到最后的解,对应3维</li><li>$Dim(N(R^T))=m-r$, $R^Tx=0$,对应$x^TR=0$,从$R$中可以看到前2行有pivots,对应线性无关,所以要生成0,对应前两行的系数为0,而最后一行的系数任意,即解$(0, 0, y_3)$, 零空间对应0行的个数</li></ol><p>得到$R^n$中$N(R)$, $C(R^T)$, 以及$R^m$中$C(R)$, $N(R^T)$<br>对应子空间如下,这里暂且把$A$替换成$R$<br><img src="/2023/07/30/线性代数/子空间R.png" alt="子空间"></p><h3 id="矩阵4个基本子空间"><a href="#矩阵4个基本子空间" class="headerlink" title="矩阵4个基本子空间"></a>矩阵4个基本子空间</h3><p>行阶梯形矩阵通过$A$进行初等行变换得到,即$EA=R$, 基本行变换只是在对行空间向量进行重新线性组合,不会改变行空间,所以$C(A^T)=C(R^T)$, $N(A)=N(R)$;<br>基本行变换会影响列空间向量,但是$Ax=0$和$Rx=0$等价,因为$E$为可逆矩阵,即$N(A)=N(R)$,即原本$A$中线性相关项在$R$中也线性相关,所以可以通过$R$来找原本$A$中最小线性组合(<strong>这也是行阶最简梯形可以用于获取原矩阵线性无关项的原因</strong>), 即$Dim(N(A))=Dim(N(R)$, $Dim(C(A))=Dim(C(R)$, 虽然空间不一样($A$最后几行一般不是0,但是$R$的最后几行是0),但是维度相同,所以上面的图也适用于$A$</p><p>进一步看$R^n$中零空间$Ax=0$,对应空间中向量都与$A$行向量垂直,即$C(A^T)$中每个向量都与零空间垂直, 结合$Dim(C(A^T))+Dim(N(A))=n$,所以两个空间正交互补<br><img src="/2023/07/30/线性代数/正交互补.png" alt="子空间正交互补"></p><p>对于$Ax=b$图示如下<br><img src="/2023/07/30/线性代数/空间向量表示.png" alt="子空间正交互补"></p><p>4个空间基底基本算法<sup><a href="#fn_9" id="reffn_9">9</a></sup></p><h3 id="矩阵乘积子空间10"><a href="#矩阵乘积子空间10" class="headerlink" title="矩阵乘积子空间10"></a>矩阵乘积子空间<sup><a href="#fn_10" id="reffn_10">10</a></sup></h3><p>容易得到列空间和零空间基本关系 $C(AB)\subseteq C(A)$, $N(B)\subseteq N(AB)$<br>向量空间的子空间也是矢量空间,所以秩-零定理($dim(\mathbb{R} ^n)=dim(C(A))+dim(N(A))$)同样适用, 即$dim(C(B))=dim(C(AB))+dim(N(A)\bigcap C(B))$, 可以得到$rank(C(AB)) \le rank(C(B))$, 即左乘矩阵维度不会增加, 最多保持原有维度, 如果$A$可逆, 则不改变$B$行空间, 维度保持, 和上面矩阵左右乘含义一致. 也可以从上面等式中推导, $A$可逆意味着$dim(N(A))=0$, 即$dim$C(B)=dim(C(AB))$</p><p>得到$rank(AB)\le min\{rank(A),rank(B)\}$<br><img src="/2023/07/30/线性代数/矩阵乘积.jpg" alt="矩阵乘积子空间"></p><h3 id="列空间和零空间互换表达"><a href="#列空间和零空间互换表达" class="headerlink" title="列空间和零空间互换表达"></a>列空间和零空间互换表达</h3><ol><li><p>零空间用列空间表达<br>$A$列空间$C(A)$和零空间$N(A)$可以互换表达, 即隐式表达换成显式$N(A)=C(P)$, 显式表达换成隐式表达$C(A)=N(Q)$<br>如</p><script type="math/tex; mode=display">A=\begin{bmatrix}1  &4  &1  &0  &-2 \\-1 &-4  &0  &1  &5 \\2  &8  &2  &1  &-2 \\1  &4  &2  &2  &3\end{bmatrix}</script><p>化成行阶最简梯形为</p><script type="math/tex; mode=display">R=\begin{bmatrix}1  &4  &0  &0  &-3 \\0  &0  &1  &0  &1 \\0  &0  &0  &1  &2 \\0  &0  &0  &0  &0\end{bmatrix}</script><p>教科书一般是通过求解方程组的形式获取零空间解,即</p><script type="math/tex; mode=display">\begin{aligned}x_{1}+4 x_{2}-3 x_{5}=0 & \Rightarrow x_{1}=-4 x_{2}+3 x_{5} \\x_{3}+x_{5}=0 & \Rightarrow x_{3}=-x_{5} \\x_{4}+2 x_{5}=0 & \Rightarrow x_{4}=-2 x_{5}\end{aligned}</script><p>最后得到</p><script type="math/tex; mode=display">\left[\begin{array}{l}x_{1} \\x_{2} \\x_{3} \\x_{4} \\x_{5}\end{array}\right]=\alpha\left[\begin{array}{r}-4 \\1 \\0 \\0 \\0\end{array}\right]+\beta\left[\begin{array}{r}3 \\0 \\-1 \\-2 \\1\end{array}\right]=\alpha \mathbf{p}_{1}+\beta \mathbf{p}_{2}</script><p>即</p><script type="math/tex; mode=display">P=\left[\begin{array}{r}-4&3 \\1&0 \\0&-1 \\0&-2 \\0&1\end{array}\right]</script><p>这里可以使用分块矩阵进行计算, 把行阶最简梯形进行列交换得到$R=\left[\begin{array}{r}<br>I_r&amp;F \\<br>0&amp;0 \\<br>\end{array}\right],<br>P=\left[\begin{array}{r}<br>-F \\<br>I_{n-r} \\<br>\end{array}\right]$<br>对于交换了列只是交换了变量, 可以在得到$P$之后把对应列交换回去即可<sup><a href="#fn_8" id="reffn_8">8</a></sup>,可以记住交换后的序列, 最后求出$P$之后再换回去</p></li><li><p>列空间用零空间表达<br>$C(A)=N(Q)$, 求矩阵$Q$, 对应有方程$QA=0$, 即可满足$QAx=0$. 转置得到$A^TQ^T=0$, 所以只需要求得$A^T$的零空间并转置即可, 也可以借助矩阵的4个子空间进行理解.</p></li></ol><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>把空间中向量$b$投影到空间$C(A)$中, 即找到投影后向量和投影前向量最近的值, 对应投影后残余向量$b-Pb$垂直于空间$C(A)$, 根据垂直得到$A^T(b-Ax)=0$, 其中$x$为投影后在空间中的向量, $A^TAx=A^Tb$, 得到$x=(A^TA)^{-1}A^Tb$, 所以投影矩阵$P=(A^TA)^{-1}A^T$</p><p>$A^TA$只要$A$中列向量线性无关即可逆, 可以用SVD分解证明. <strong>对于$A$中存在线性相关项, 则$A^TA$不可逆, 可以使用伪逆,待补充</strong></p><p>误差$e=b-Ax$最小证明:</p><ul><li>几何法<br>如果$e$与$Ax$不垂直,其它任意向量可以组成三角形,都大于垂直向量</li><li>代数法<br>$Ax=b=p+e$, 其中$b\in R^m$, $p\in C(A) \bot e \in N(A^T)$, 只有$Ax=p$有解, $min||Ax-b||^2=min||Ax-p-e||^2=min(||Ax-p||^2+||e||^2)=||e||^2$</li><li>微积分<br>$min||Ax-b||^2$即取导数为0的点$f=(Ax-b)^T(Ax-b)=x^TA^TAx-2b^TAx+b^Tb$, 即$df=2(A^TAx-A^Tb)dx$, 所以$A^TAx=A^Tb$对应最小误差的地方<br>图形表示如下<br><img src="/2023/07/30/线性代数/最小误差解.png" alt="最小误差解"></li></ul><h2 id="正交基和施密特正交化"><a href="#正交基和施密特正交化" class="headerlink" title="正交基和施密特正交化"></a>正交基和施密特正交化</h2><h3 id="正交基的优良特性"><a href="#正交基的优良特性" class="headerlink" title="正交基的优良特性"></a>正交基的优良特性</h3><p>$Q$所有列单位正交, 对应$Q^TQ=I$</p><ul><li>$Q$不为方阵, 则$Q^T$是$Q$的左逆</li><li>$Q$为方阵, $Q^TQ=I$ -&gt; $Q^T=IQ^{-1}=Q^{-1}I$ -&gt; $QQ^T=I$, $Q^T$为双边逆, 转置即逆</li></ul><p>使用正交基投影, 即$Q$代$A$, 则有$Q^TQx=Q^Tb=x$, 投影矩阵为$QQ^T$, 这里没有$A^TA$带来的耦合(或者说协方差矩阵之类的), $x=Q^Tb$也就是$b$分别投影到每个正交基(点乘), 已经<strong>解耦成1维投影</strong></p><p>当$Q$是方阵时, 投影向量$p=QQ^Tb=b$, 即全空间投影还是本身. 这里的$QQ^T=I$非常重要, 很多变换(傅里叶变换)就是基于类似原理进行分解, 把向量或者和函数分解到垂直的空间. $p=q_1(q_1^Tb)+q_2(q_2^Tb)+ \cdots +q_n(q_n^Tb)$</p><h3 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h3><p>正交基可以解耦投影, 针对空间空任意基可以通过施密特正交化获得正交基. 核心是”Subtract from every new vector its projections in the directions already set”</p><p>比如给定一组独立向量$a,b,c$, 正交化得$A,B,C$,最后单位化即为单位正交基</p><ol><li>$A=a$, 初始向量不变</li><li>$B=b-A\frac{A^Tb}{A^TA}$, 即把$b$中正交投影到$a$的去除了,剩下的就是垂直于$a$, 可以通过$A^TB=A^Tb-A^Tb=0$证明</li><li>$C=c-A\frac{A^Tc}{A^TA}-B\frac{B^Tc}{B^TB}$, 分别把正交投影到其它向量的给剔除了</li></ol><p>改进的施密特正交化数值计算更加稳定, 相对于直接一次把投影到所有正交基分量减去, 可以逐个减</p><ol><li>$q_1=\frac{a} {||a||}$</li><li>$B=b-(q_1^Tb)q_1$, $q_2 = \frac{B} {||B||}$</li><li>$C^<em>=c-(q_1^Tc)q_1$, $C=C^</em>-(q_2^TC^*)q_2$, $q_3=\frac{C}{||C||}$</li></ol><h3 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h3><p>施密特正交化把空间中线性无关的基变换成单位正交基, 这两组基表示同一个空间, 之间的关系就是$A=QR$, $q_i$只与$a_1\cdots a_i$相关, 对应$R$为三角矩阵</p><script type="math/tex; mode=display">\left[\begin{array}{lll}\boldsymbol{a} & \boldsymbol{b} & \boldsymbol{c}\end{array}\right]=\left[\begin{array}{lll}\boldsymbol{q}_{1} & \boldsymbol{q}_{2} & \boldsymbol{q}_{3} \\& &\end{array}\right]\left[\begin{array}{lll}\boldsymbol{q}_{1}^{\mathrm{T}} \boldsymbol{a} & \boldsymbol{q}_{1}^{\mathrm{T}} \boldsymbol{b} & \boldsymbol{q}_{1}^{\mathrm{T}} \boldsymbol{c} \\& \boldsymbol{q}_{2}^{\mathrm{T}} \boldsymbol{b} & \boldsymbol{q}_{2}^{\mathrm{T}} \boldsymbol{c} \\& & \boldsymbol{q}_{3}^{\mathrm{T}} \boldsymbol{c}\end{array}\right]</script><p>很多分解都是为了方便解方程, 对于最小二乘法$A^TAx=A^Tb$, 使用QR分即可得$A^TAx=R^TRx=R^TQb$, 即$Rx=Q^Tb$(R满秩可逆), 由于$R$为上三角矩阵, 直接反过来代入即可求解</p><p>使用施密特正交化可以得到$Q$, 则$Q^TA=Q^TQR=R$可用于直接求解$R$<br>可以用于理解行列式意义<sup><a href="#fn_4" id="reffn_4">4</a></sup>, 可以用QR分解帮助理解$|A|=|QR|=|Q||R|$, 所以由$A$列向量组成的空间体积可以由以$Q$为基, $diag(R)$为长度组成的体积, 所以行列式的绝对值就是多面体的体积. 另外不依赖于$|AB|=|A||B|$也可以推导, 第$k$个向量在前$k-1$个向量组成的空间中给出垂直分量,即为$R$对角线上值$r_{kk}$, 所以体积在前面的集成上乘$r_{kk}$, 所以多面体体积$V= {\textstyle \prod_{i=1}^{n} r_{ii}} = |R|$</p><p>比如求n个列向量组成的多面体体积, 组成的矩阵$A\in R^{m\times n}$, $V=\sqrt{A^TA}$, $|A^TA|\geq 0$, 即$A^TA$为半正定矩阵. 可以补充$A$垂直子空间中$m-n$个单位正交向量得到$B$,则</p><script type="math/tex; mode=display">|B^TB|=\begin{vmatrix}A^TA  & 0\\0  & I_{m-n}\end{vmatrix} = |A^TA|=|B|^2</script><p>对应体积的平方, 所以多面体体积$V=\sqrt {B^TB}=\sqrt {A^TA}$, 这里主要针对$A$不是方阵, 如果是方阵, $|A^TA|=|R^TQ^TQR|=|R|^2=V^2$</p><h4 id="线性变换把面积伸缩了5"><a href="#线性变换把面积伸缩了5" class="headerlink" title="线性变换把面积伸缩了5"></a>线性变换把面积伸缩了<sup><a href="#fn_5" id="reffn_5">5</a></sup></h4><p>线性变换就是把1个空间变换成另外1个空间, 两个空间之间的面积/体积存在一定的关系, 针对线性变换$Ax$, 可以得到原来单位体积 $V=e_1e_2 \cdots e_n$, 其中空间基为$e_1. e_2,\cdots, e_n$, 则新的空间基为$Ae_1, Ae_2, \cdots, Ae_n$, 对应矩阵$\begin{bmatrix} Ae_1&amp;  Ae_2&amp; \cdots &amp; Ae_n \end{bmatrix}=AI=A$的体积, 即$V=|A|$, 即原本体积放大了$|A|$倍, 针对任意封闭多面体可以分成很多个小立方体近似, 平移不会改变多面体的体积, 所以任意多面体经过线性变换后体积缩放了$|A|$倍. 如果$A$不是方阵, 则放大倍数为$\sqrt{|A^TA|}$, 如果矩阵只有单个元素, 放大倍数就是本生, 属于矩阵的特例</p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>矩阵的行列式就是对应行组成的多面体的体积, 可以简单看成2x2/3x3矩阵推广到nxn, 原本可能就是想求面积或者体积之类的</p><p>3个最重要性质如下, 后面几个性质可以通过前3个进行推导<sup><a href="#fn_6" id="reffn_6">6</a></sup>, 使用面积(多面体体积更好理解) </p><ol><li>单位矩阵行列式=1, $|I|=1$, 简单理解就是单位立方体(包含多维)</li><li>两行交换, 行列式异号. 可以简单使用2x2矩阵进行验证.<br>求向量面积$A=\begin{bmatrix}<br>a  &amp; b\\<br>c  &amp; d<br>\end{bmatrix}$, 面积$S=ad-bs$, 结合性质3得到$|A|=$</li><li>行列式是任1行的线性函数(其他行不变)<script type="math/tex; mode=display">\begin{array}{l}\left|\begin{array}{cc}t a & t b \\c & d\end{array}\right|=t\left|\begin{array}{ll}a & b \\c & d\end{array}\right| \\\left|\begin{array}{cc}a+a^{\prime} & b+b^{\prime} \\c & d\end{array}\right|=\left|\begin{array}{ll}a & b \\c & d\end{array}\right|+\left|\begin{array}{cc}a^{\prime} & b^{\prime} \\c & d\end{array}\right| .\end{array}</script></li><li>矩阵两行相同, 则$|A|=0$, 可以通过第二条推导, 交换两行异号</li><li>某一行减去其它任一行的倍数,行列式不变. 初等行变换, 可以通过第3条线性进行推导</li><li>带有0行的矩阵行列式=0. 直接在原矩阵0行上加上其它任一行不改变行列式, 两行相同对应行列式相等</li><li>三角矩阵行列式=对角线pivots值相乘. 可以初等行变换化为对角矩阵, 行列式不变</li><li>$A$奇异对应$|A|=0$, 反之也成立</li><li>$|AB|=|A||B|$, 可以使用初等行变换把$A,B$化为对角矩阵得到行列式乘积, $|A|=|LPA|=|D|$, $P, L$, 分别是行交换和初等行变换. $|AB|=|LPAB|=|DB|=|A||B|$, 这里的$L$包括下三角和上三角矩阵, $D$为对角矩阵, 对B每行分别进行乘积, 可由性质3推导: 对角矩阵分解成只有1个元素保留,其它元素为1的矩阵乘积, 相当于每次单独对矩阵某行进行乘积. 或者也可以把矩阵直接化简为初等矩阵的乘积, 初等矩阵本生满足$|P_1P_2|=|P_1||P_2|$, 则$|AB|=|P_1P_2\cdots P_nQ_1Q_2\cdots Q_n|=|P_1P_2\cdots P_n||Q_1Q_2\cdots Q_n|=|A||B|$ </li><li>$|A^T|=|A|$, <strong>行列式对于行的性质同样适用于列</strong>. 可用$PA=LU$证明, $|A|=|P^{-1}LU|=|P^{-1}||L||U|$, $|A^{T}|=|U^T||L^T||P^{-T}|$, 可以发现各自相等, 其中$L, U$对三角矩阵, $P$为行交换矩阵, $P^{-1}=P=P^T$</li></ol><p>行列式求值<br>可以使用前三个基本规则确定, 求行列式$|A|$, 首先使用线性性质得到</p><script type="math/tex; mode=display">|A|=\begin{vmatrix}a_{11} &  a_{12} &  \cdots & a_{1n}\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} =\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} +\begin{vmatrix}0 &  a_{12} &  \cdots & 0\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} + \cdots +\begin{vmatrix}0 &  0 &  \cdots & a_{1n}\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix}</script><p>然后针对单个行列式依次进行再拆分, 第2个行列式为0, 同样的第一列所有除$a_{11}$的元素都可以消除为0, 最后化简成每一行/列只能选取1个元素. 对应总共由$n!$个行列式, 每个行列式可以化简成单位阵, 即行列式值$=||P||||A_i||$, 使用了基本性质1-3</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} =\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\0 &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} +\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\a_{21} &  0 &  \cdots & 0\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} =\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\0 &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\0 &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} = -1^{1+1-2}a_{11}\begin{vmatrix}a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots & \vdots\\a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} = a_{11}C_{11}</script><p>其中符号取决为$(-1)^{j+i-2}=(-1)^{i+j}$, 对应$a_{ij}$, 其实就是利用行列式基本性质2以及行和列具有相同性质把$a_{ij}$交换到$a_{11}$, 对应$i+j-2$次交换<br>得到两种计算行列式算法<br>$|A|=\sum |P|a_{1i}a_{2j}\cdots a_{nk}$, 其中$i, j, k$为列的排列<br>$|A|=a_{i1}C_{i1} + a_{i2}C_{i2} + \cdots a_{in}C_{in}$, 其中$C_{in}$为代数余子式</p><h3 id="Cramer’s-Rule"><a href="#Cramer’s-Rule" class="headerlink" title="　Cramer’s Rule"></a>　Cramer’s Rule</h3><p>回到求解方程$Ax=b$, 之前是通过消去法得到的解,这次直接使用代数法<br>$Ax=b$, 可以扩充矩阵成为</p><script type="math/tex; mode=display">A\begin{bmatrix}x_1  & 0 & 0\\x_2  & 1 & 0\\x_3  & 0 & 1\end{bmatrix} = \begin{bmatrix}b & a_2 & a_3\end{bmatrix} = B_1</script><p>所以$|A|x_1=|B_1|$, 通过这种方式可以求得$x$, 针对$x_2$, 只需要把$x$放在矩阵第二列即可, 对应方程解$x_1=\frac{|B_1|}{|A|}, x_2=\frac{|B_2|}{|A|}, \cdots, x_n=\frac{|B_n|}{|A|}$, 这就是<strong>Cramer’s Rule</strong>, 这种方式计算效率比较低, 但是可以用于简单矩阵的符号推导. 求逆矩阵就是求了3次$Ax=b$方程, 对应求$AA^{-1}=I$, $b$分别为$I$矩阵种的列, 得到$A^{-1}_{ij} = \frac{C_{ji}}{|A|}$, 注意这里不是$C_{ij}$, 整合得到</p><script type="math/tex; mode=display">A^{-1}=\frac{C^T}{|A|}</script><p>直接证明$A^{-1}=\frac{C^T}{|A|}$, 等价于$AC^T=|A|I$</p><script type="math/tex; mode=display">\left[\begin{array}{lll}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{array}\right]\left[\begin{array}{lll}C_{11} & C_{21} & C_{31} \\C_{12} & C_{22} & C_{32} \\C_{13} & C_{23} & C_{33}\end{array}\right]=\left[\begin{array}{ccc}\operatorname{det} A & 0 & 0 \\0 & \operatorname{det} A & 0 \\0 & 0 & \operatorname{det} A\end{array}\right]</script><p>其中$a_{21}C_{11}+a_{22}C_{12}+a_{23}C_{13}=0$, 可以看成是把$A$的第二行拷贝到第1行得到$A^<em>$行列式$|A^</em>|=0$</p><p>这里可以推导得到2维矩阵逆方便使用, 对于非奇异矩阵,$A=\begin{bmatrix} a  &amp; b\\ c  &amp; d\end{bmatrix}$且 $|A|\ne 0$<br>则有</p><script type="math/tex; mode=display">A^{-1}=\frac{\begin{bmatrix}d  & -b\\-c  & a\end{bmatrix}}{|A|}</script><h3 id="行列式常见含义"><a href="#行列式常见含义" class="headerlink" title="行列式常见含义"></a>行列式常见含义</h3><ul><li><p>三角形面积<br>三角形顶点$(x_1, y_1), (x_2, y_2), (x_3, y_3)$, 面接为</p><script type="math/tex; mode=display">\frac{1}{2}\begin{vmatrix}x_1  & y_1 & 1\\x_2  & y_2 & 1\\x_3  & y_3 & 1\end{vmatrix}</script><p>从第三列展开对应就是3个三角形的面积和, 小三角形的1个顶点为原点</p></li><li><p>叉乘, 也可以用反堆成矩阵表示成矩阵和向量的乘积</p><script type="math/tex; mode=display">u \times v=\begin{vmatrix}i  & j & k\\u_1  & u_2 & u_3\\v_1  & v_2 & v_3\end{vmatrix}</script></li><li><p>体积, 可以借助叉乘理解, 叉乘就是向量构成的平行四边形面积, 最后增加1个点乘, 只需要把$i, j, k$替换成第3个向量即可</p><script type="math/tex; mode=display">(u\times v)w=\begin{vmatrix}w \\u \\v\end{vmatrix}</script></li></ul><h2 id="特征值-amp-特征向量"><a href="#特征值-amp-特征向量" class="headerlink" title="特征值 &amp; 特征向量"></a>特征值 &amp; 特征向量</h2><p>$Px=\lambda x$具有很有用的性质, $\lambda$为特征值, $x$为特征向量.</p><ul><li>投影矩阵, $Px=x, Py=0$, 把空间分成列空间和零空间, 对应特征值$\lambda=1$, $\lambda=0$, 列空间投影为本身, 零空间投影成0</li><li>反射矩阵, reflection matrix, $R=2P-I$, 对应$Rx=x, Ry=-y$, 对应特征值$\lambda=1$, $\lambda=-1$</li><li>旋转矩阵, 特征值是复数</li><li>反对称矩阵, 特征值为纯虚数, 待证明</li><li>对称矩阵, 特征值为实数. 任何矩阵都可以分解成对称矩阵和反对称矩阵和(卡式分解, Cartesian decomposition)$A=(\frac{A}{2} + \frac{A^T}{2}) + (\frac{A}{2} - \frac{A^T}{2})$</li></ul><p>$(A-\lambda I)x=0$, 对应$|A-\lambda x|=0$, 可求得特征值</p><p>特征值基本性质</p><ol><li>$\sum \lambda_i=trac(A)$<br>$|A-\lambda I|=|\lambda I - A|=0$, 对应$\lambda ^n - (a_{11}+a_{22}+\cdots + a_{nn})\lambda ^{n-1} + \cdots=0$, 同时有$(\lambda - \lambda_1)(\lambda - \lambda_2)\cdots(\lambda - \lambda_n)=0$ 对应有$\lambda ^n - (\lambda_1+\lambda_2+\cdots + \lambda_n)\lambda ^{n-1} + \cdots=0$, 对比$\lambda^{n-1}$系数即可得到证</li><li>$\prod \lambda_i=|A|$<br>所有特诊向量集合可得$A(x_1, x_2, \cdots, x_n)=(x_1, x_2, \cdots, x_n)\Lambda$, 即$|A||Q|=|Q||\Lambda|$, $|A|=||Lambda|$, 其中$\Lambda$为特诊值组成的对角矩阵</li><li>三角矩阵特征值就是对角线元素pivots, 直接用定义求即可证</li></ol><h2 id="矩阵对角化"><a href="#矩阵对角化" class="headerlink" title="矩阵对角化"></a>矩阵对角化</h2><p>所有矩阵特征值不相等,对应特征向量线性无关, 即$X$可逆, 矩阵可对角化, $AX=X\Lambda$, 对应$\Lambda = X^{-1}AX$, $Ax=X\Lambda X^{-1}x$, 物理意义就是$x$投影到特征向量上缩放后得到的向量, 相当于在特征向量的方向进行了处理<br>反证法, 假如线性相关, 则$c_1x_1+c_2x_2+\cdots+c_nx_n=0$, 其中系数不全为0(为方便推导可直接把0项去除), 左乘矩阵得到$c_1\lambda_1x_1+c_2\lambda_2x_2+\cdots+c_n\lambda_nx_n=0$, 两式结合消除$x_n$, 则说明前n-1项线性相关, 通过不断递推到$x_1$, 证明$c_1=0$, 也可证明$c_i=0$, 和原本假设相悖, 所以线性无关</p><p>矩阵可对角化和可逆没有必然联系</p><ul><li>矩阵不可逆, 对应特征值$\lambda_i=0$</li><li>矩阵可对角化, 特征向量是否足够作为空间一组基</li></ul><p>能否对角化判定依据: GM=AM</p><ul><li>Geometric Multiplicity: 几何重数, $\lambda_i$对应特征向量的个数, 也就是$A-\lambda I$的零空间维数</li><li>Algebraic Multiplicity: 代数重数, $\lambda_i$重根数, 即$|A-\lambda I|$根</li></ul><h3 id="矩阵幂计算"><a href="#矩阵幂计算" class="headerlink" title="矩阵幂计算"></a>矩阵幂计算</h3><p>$A^n=(X\Lambda X^{-1})^n=X\Lambda ^n X^{-1}$, 实际中非常有用, 比如求 Fibonacci number第100个, 0, 1, 1, 2, 3……, 后1个数是前来两个数之和, 可以用矩阵表示</p><script type="math/tex; mode=display">u_{k+1}=\begin{bmatrix}F_{k+2} \\F_{k+1}\end{bmatrix} = \begin{bmatrix}1  & 1\\1  & 0\end{bmatrix}\begin{bmatrix}F_{k+1} \\F_{k}\end{bmatrix}=Au_k</script><p>这里就可以用到矩阵幂, 实现快速求解$u_{100}=X\Lambda^{100}X^{-1}u_0$</p><p>计算$A^nu$</p><ul><li>$A$可对角化,即特征向量线性无关充满整个空间<br>$A^nu=X\Lambda^{n} X^{-1}u$, 令$X^{-1}u=c$,即$u=Xc$, 对应用特征向量表示$u$. $X\Lambda X^{-1}u$整个含义是把$u$投影到特征向量$X$上, 然后缩放特征值倍数, 最后在特征向量上表示(即向量空间沿着特征向量缩放特征值倍数)</li><li>$A$不能对角化, 即特征向量构成的空间小于矩阵的维度<br>只要$u$可有用仅有的特征向量表示也可以实现快速简单计算. <script type="math/tex; mode=display">A^nu=A^nXc=A^n\begin{bmatrix}x_1 & \cdots & x_n\end{bmatrix}\begin{bmatrix}c_1 \\\vdots \\c_n\end{bmatrix}=c_1\lambda_1^kx_1+\cdots+c_n\lambda_n^kx_n</script></li></ul><h3 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h3><p>相似矩阵的特征值相等, 可以从对角矩阵开始, $A=X\Lambda X^{-1}$, $X$为特征向量.任意选择一组基即可得到对应的$A$, 所以$A,\Lambda$相似. 拓展到任意矩阵$A=BCB^{-1}$, 只需要确保$B$可逆即可, 同时$A, C$矩阵不一定可以对角化.下面证明特征值相等<br>假如$Cx=\lambda x$, 则$A(Bx)=BCB^{-1}Bx=BCx=\lambda (Bx)$</p><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p>把一般微分方程推广到矩阵$\frac{du}{dt}=\lambda u$, 对应$u=e^{\lambda t}u_0$<br>$\frac{d\mathbf u}{dt}=A\mathbf u$, 假设$\mathbf u=e^{\lambda_it}{x_i}$, 其中$\lambda_i, x_i$分别为$A$的特征值和特征向量, 带回原式刚好满足, n个特征向量对应n个解, 所以解为, </p><script type="math/tex; mode=display">\mathbf u= c_1e^{\lambda_1t}x_1+c_2e^{\lambda_2t}x_2+\cdots+c_ne^{\lambda_nt}x_n=X\begin{pmatrix}e^{\lambda_1}  &  & \\  & \ddots & \\  &  & e^{\lambda_n }\end{pmatrix}c</script><p>满足$Xc=\mathbf u_0$, 如果$X$可逆, 对应$c=X^{-1}\mathbf u_0$, 类似单变量微分方程, 遇到两个$\lambda_i$相等且只有1个特征向量, 则需要增加解$te^{\lambda_it}$, 这里用二阶方程进行简要证明$\ddot x + p \dot x + qx=0$, 当两个根相等时即$\lambda=-\frac{p}{2}$, 对应一个解$x_1=e^{\lambda t}$, 需要找到另外一个线性无关解设为$x_2= u_xe^{\lambda t}$, 带入原方程得到$(\ddot u + (2\lambda+p)\dot u+(\lambda ^2 + p\lambda+1)u)e^{\lambda t}=0$, 其中$2\lambda+p=0, \lambda ^2 + p\lambda+1=0$, 所以$\ddot u=0$, 取$u=t$, 所以$x_2=te^{\lambda t}$</p><p>还有另一种处理方式, 针对可对角化矩阵$A=X\Lambda X^{-1}$可以进行变量解耦, 令$z=X^{-1}u$, 得到$\frac{dz}{dt}=\Lambda z$, 对应$z=\begin{bmatrix}<br>e^{\lambda_1t}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_nt}<br>\end{bmatrix}\begin{bmatrix}<br>c_1 \\<br>\cdots \\<br>c_n<br>\end{bmatrix}$, 最后得到<br>$<br>u=Xz=X\begin{bmatrix}<br>e^{\lambda_1t}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_nt}<br>\end{bmatrix}\begin{bmatrix}<br>c_1 \\<br>\vdots \\<br>c_n<br>\end{bmatrix}=X\begin{bmatrix}<br>e^{\lambda_1t}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_nt}<br>\end{bmatrix}c<br>$</p><p>矩阵形式的微分方程可以从多阶微分方程得到,比如$\ddot x + b\dot x + k x=0$, 常见的单位质量弹簧阻尼系统, 对应$\dot x = \dot x$, $\ddot x=-kx-b\dot x$, 对应矩阵$\frac{d\mathbf u}{dt}=A\mathbf u$, 使用矩阵得到的解和直接微分方程解相同, 只不过会附带$\dot x$状态. 其余高阶微分方程也可以通过这种方式进行求解</p><script type="math/tex; mode=display">\begin{bmatrix}\dot x \\\ddot x\end{bmatrix} = \begin{bmatrix}0  & 1\\-k & -b\end{bmatrix}\begin{bmatrix}x \\\dot x\end{bmatrix}</script><p>这里接触指数函数定义矩阵指数, 如果特征向量足够且线性无关,有<br>$e^{At}=I+At+\frac{At^2}{2}+\cdots=X\begin{pmatrix}<br>e^{\lambda_1}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_n }<br>\end{pmatrix}X^{-1}$, 所以矩阵微分方程的解有可以写成$\mathbf u=e^{At}\mathbf u_0$, 这里只是针对齐次常微分方程的解,相当于零空间解,非齐次方程还需要得到特解+通解, 实际使用中通常使用数值法<strong>Runge-Kutta</strong>求常微分方程. 微分方程参考<a href="math.mit.edu/dela">Differential Equations and Linear Algebra</a><br>对应导数<br>$\frac{de^{At}}{dt}=Ae^{At}=e^{At}A$</p><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><ol><li>实对称矩阵特征向量是实数<br>证明: $Sx=\lambda x$, 则有$S\overline{x}=\overline{\lambda}\overline{x}$, 即$\overline{x}^TS=\overline{x}^T\overline{\lambda}$, 进一步得到$\overline{x}^TSx=\overline{x}^T\overline{\lambda}x$<br>另一方面,$\overline{x}^TSx=\overline{x}^T\lambda x$,<br>和上式比较得到$(\lambda-\overline{\lambda})\overline{x}^Tx=0$, 又由于$\overline{x}^T x\ne 0$, 所以$\overline{\lambda}=\lambda$, 即特征值为实数.<ul><li>实矩阵$Ax=\lambda x$, 对应有$A\overline{x}=\overline{\lambda}\overline{x}$, 所以实矩阵对应的特征值共轭,特征向量共轭</li></ul></li><li>实对称矩阵不同特征值对应的特征向量垂直<script type="math/tex; mode=display">\left(\lambda_{1} \boldsymbol{x}\right)^{\mathrm{T}} \boldsymbol{y}=(S \boldsymbol{x})^{\mathrm{T}} \boldsymbol{y}=\boldsymbol{x}^{\mathrm{T}} S^{\mathrm{T}} \boldsymbol{y}=\boldsymbol{x}^{\mathrm{T}} S \boldsymbol{y}=\boldsymbol{x}^{\mathrm{T}} \lambda_{2} \boldsymbol{y}</script>其中$\lambda_1\ne \lambda_2$, 所以$\mathbf x^T \mathbf y=0$,即垂直</li></ol><p>$S=Q\Lambda Q^T$ 待证明即使有相同特征值的对称矩阵也满足</p><h2 id="未同步补充项"><a href="#未同步补充项" class="headerlink" title="未同步补充项"></a>未同步补充项</h2><p>待证明:对称矩阵pivots符号=特征值的符号<br>正定矩阵: 所有特征值都是正数</p><h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><ol><li><p>矩阵左逆和右逆相等<sup><a href="#fn_2" id="reffn_2">2</a></sup>, 针对方阵<br>之前学习的时候更多的是直接定义$AA^{-1}=I$以及$A^{-1}A=I$, 可以通过结合律进行推导, 假设$BA=I$, $AC=I$, 则有 $(BA)C=B(AC)$, 即$C=B$<br>结合律证明$(AB)C=A(BC)$<br>等式左边: $(AB)C=AB(c_1,c_2,…,c_n)=(ABc_1,ABc_2,…,ABc_n)$<br>等式右边: $A(BC)=A(Bc_1,Bc_2,…,Bc_n)=(ABc_1,ABc_2,…,ABc_n)$</p></li><li><p>高斯消元法(Gauss-Jordan)<br>就是用多个初等矩阵<a href="**基本矩阵, 单位阵经过1次初等行/列变换得到: 两行(列">^3</a>互换、某行乘以非零常数、把第i行(列)加上第j行(列)的k倍<strong>) 左乘目标矩阵简化为行阶梯形矩阵, 一般用于方程求逆、矩阵的秩、线性方程组求解.<br>求$Ax=b$, 对增广矩阵进行高斯消元$(A,b)$, 得到$(U,c)$(</strong>A=LU分解<strong>, 可以进一步分解$U$为对角矩阵$A=LDU$), 再反向求解$x$,从$x_n$开始.<br>矩阵求逆类似$AA^{-1}=I$, 可以看成$n$个方程$Ax_i=e_i$, 最后得到逆矩阵, 这里可以不用反向求$x_i$, 可以直接再用初等矩阵把$A$变换为对角阵(元素积为$|A|$), 最后变为单位阵, 则右边的直接就是$A^{-1}$, 即$(A,I)$通过初等变换得到$(I,A^{-1})$. 矩阵求逆计算量较大, 所以matlab建议直接使用 <code>A\b</code>代替<code>inv(A)b</code><br>LU分解, 当$A^T=A$即</strong>对称矩阵**(最重要的矩阵), 分别分解$A^T=U^TDL^T、A=LDU$, 本生$A=A^T$, 所以分解出来的$L=U^T、L^T=U$, 即$A=LDL^T$<br>针对方程求解$Ax=b$解$x$=特解+零空间解, 首先使用高斯消元得到行阶梯形矩阵, 可以得到pivot(行阶梯形矩阵中每行第一个非零)和free variables(自由变量), 特解可以选取自由变量区零对应方程解, 零空间解则直接就是各个自由变量各自分别取1得到的解</p></li><li><p>对角线优势的矩阵可逆<br>对角线元素绝对值大于同行其他元素绝对值之和$|a_{ii}|&gt;\sum_{j \neq i}{a_{ij}}$. 矩阵不可逆=&gt;$Ax=0$存在非零解, 对于任意非0$x$, 假设$x_i$绝对值最大, 则$A_ix_i \neq 0$, 因为$a_{ii}x_i$比其余项之和还大, 所以解只有$x=0$, 对应$A$可逆</p></li><li><p>矩阵转置<br>$(Ax)^T=x^TA^T$ 证明$(Ax)^T=\begin{bmatrix}  a_1x\\  a_2x\\  …\\  a_nx \end{bmatrix}^T=[x^Ta_1^T,x^Ta_2^T,…,x^Ta_n^T]=x^TA^T$ 或者$Ax$是$A$的列向量线性组合, $x^TA^T$是$A^T$行向量线性组合, 相同向量的相同组合<br>$(AB)^T=B^TA^T$ 证明同理, 只需要将$B=(b_1,b_2,…,b_n)$类似证明<br>$(A^T)^{-1})=((A^{-1})^{T}$ 证明 $A^T((A^{-1})^T)=(A^{-1}A)^T=I$</p></li></ol><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/%e9%96%b1%e8%ae%80%e5%b0%8e%e5%bc%95/%e7%9f%a9%e9%99%a3%e7%90%86%e8%ab%96%e5%ad%b8%e7%bf%92%e5%b0%8e%e5%bc%95/" target="_blank" rel="noopener">https://ccjou.wordpress.com/%e9%96%b1%e8%ae%80%e5%b0%8e%e5%bc%95/%e7%9f%a9%e9%99%a3%e7%90%86%e8%ab%96%e5%ad%b8%e7%bf%92%e5%b0%8e%e5%bc%95/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. Gilbert Strang, Introduction to Linear Algebra, 3rd edition, Wellesley-Cambridge Press, 2003.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://en.wikipedia.org/wiki/Elementary_matrix" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Elementary_matrix</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://ccjou.wordpress.com/2010/04/29/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/04/29/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. <a href="https://ccjou.wordpress.com/2011/01/03/%e7%b7%9a%e6%80%a7%e8%ae%8a%e6%8f%9b%e6%8a%8a%e9%9d%a2%e7%a9%8d%e4%bc%b8%e7%b8%ae%e4%ba%86/#comment-7584" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/01/03/%e7%b7%9a%e6%80%a7%e8%ae%8a%e6%8f%9b%e6%8a%8a%e9%9d%a2%e7%a9%8d%e4%bc%b8%e7%b8%ae%e4%ba%86/#comment-7584</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. <a href="https://ccjou.wordpress.com/2010/12/01/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E9%81%8B%E7%AE%97%E5%85%AC%E5%BC%8F%E8%88%87%E6%80%A7%E8%B3%AA/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/12/01/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E9%81%8B%E7%AE%97%E5%85%AC%E5%BC%8F%E8%88%87%E6%80%A7%E8%B3%AA/</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. <a href="https://ccjou.wordpress.com/2010/06/18/%e7%b7%9a%e6%80%a7%e4%bb%a3%e6%95%b8%e7%9a%84%e7%ac%ac%e4%b8%80%e5%a0%82%e8%aa%b2-%e7%9f%a9%e9%99%a3%e4%b9%98%e6%b3%95%e7%9a%84%e5%ae%9a%e7%be%a9/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/06/18/%e7%b7%9a%e6%80%a7%e4%bb%a3%e6%95%b8%e7%9a%84%e7%ac%ac%e4%b8%80%e5%a0%82%e8%aa%b2-%e7%9f%a9%e9%99%a3%e4%b9%98%e6%b3%95%e7%9a%84%e5%ae%9a%e7%be%a9/</a><a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. <a href="https://ccjou.wordpress.com/2011/07/04/%E8%A1%8C%E7%A9%BA%E9%96%93%E8%88%87%E9%9B%B6%E7%A9%BA%E9%96%93%E7%9A%84%E4%BA%92%E6%8F%9B%E8%A1%A8%E9%81%94/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/07/04/%E8%A1%8C%E7%A9%BA%E9%96%93%E8%88%87%E9%9B%B6%E7%A9%BA%E9%96%93%E7%9A%84%E4%BA%92%E6%8F%9B%E8%A1%A8%E9%81%94/</a><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. <a href="https://ccjou.wordpress.com/2012/11/19/%E7%9F%A9%E9%99%A3%E7%9A%84%E5%9B%9B%E5%80%8B%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%96%93%E5%9F%BA%E5%BA%95%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2012/11/19/%E7%9F%A9%E9%99%A3%E7%9A%84%E5%9B%9B%E5%80%8B%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%96%93%E5%9F%BA%E5%BA%95%E7%AE%97%E6%B3%95/</a><a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. <a href="https://ccjou.wordpress.com/2010/07/27/%e7%9f%a9%e9%99%a3%e4%b9%98%e7%a9%8d%e7%9a%84%e5%ad%90%e7%a9%ba%e9%96%93%e5%88%86%e6%9e%90/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/07/27/%e7%9f%a9%e9%99%a3%e4%b9%98%e7%a9%8d%e7%9a%84%e5%ad%90%e7%a9%ba%e9%96%93%e5%88%86%e6%9e%90/</a><a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex公式编辑</title>
      <link href="2023/07/11/LaTex%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/"/>
      <url>2023/07/11/LaTex%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#基本使用">基本使用</a><ul><li><a href="#公式编号">公式编号</a></li><li><a href="#注释">注释</a></li></ul></li><li><a href="#引用">引用</a></li><li><a href="#附录">附录</a></li></ul><!-- /code_chunk_output --><p>想要在文档中快速敲出好看的公式，<a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTex</a>必不可少。LaTeX系统是一种可以处理排版和渲染的标记语言，一种基于TEX的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，非常适用于生成高印刷质量的科技和数学、物理文档。</p><p>简单公式可以参考下面规则,对于复杂公式可以直接使用<a href="https://www.latexlive.com/" target="_blank" rel="noopener">在线latex</a>, 或者使用mathtype编辑后复制,对应公式识别可以使用<a href="https://mathpix.com/" target="_blank" rel="noopener">mathpix</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li><p>常用字符</p><pre><code>  `$`: 左对齐公式  $$$$: 居中对齐公式  `_`、`^`: 下标，上标  `\`: 转义字符  `\\`: 换行          $$          f(x)=2x+1 \\          =2+1 \\          =3          $$</code></pre></li><li><p>对齐<br>  <code>begin{aligned}</code>对齐，<code>&amp;</code>为对齐位置，一般在<code>=</code>前面</p><pre><code>  $$  \begin{aligned}  f(x)&amp;=2x+1 \\  &amp;=2+1 \\  &amp;=3  \end{aligned}  $$</code></pre><script type="math/tex; mode=display">  \begin{aligned}  f(x)&=2x+1 \\  &=2+1 \\  &=3  \end{aligned}</script></li><li><p>字体<br>  具体根据需要查询<a href="https://www.latexlive.com/help" target="_blank" rel="noopener">latex在线help</a></p><p>  比如拉式变换用到的花体$\mathcal{L}$</p></li><li><p>空格<br>  <code>quad</code>: 空1格<br>  <code>qquad</code>: 空2格</p></li><li><p>绝对值范数<br>  <code>||</code>, <code>||||</code>, 绝对值和范数</p></li><li><p>括号<br>  <code>(), [], |</code>为符号本身，大括号用<code>\{\}</code>，需要转义(上下标集合用了花括号)<br>  长括号<script type="math/tex">\left(表达式\right)</script></p></li><li><p>分式<br>  <code>\frac{分子}{分母}</code>, 简单可使用<code>\frac ab</code>, 对应$\frac ab$，复杂可以使用<code>分子 \over 分母</code>, $a \over b$</p></li><li><p>根<br>  \sqrt [根指数] {被开方数}<br>  缺省根指数时为2</p></li><li><p>对数<br>  \log_{对数底数}{表达式}</p><p>  表达式的大括号可省略</p></li><li><p>省略号<br>  数学公式中常见的省略号有两种，<code>\ldots</code> 表示与文本底线对齐的横向省略号$\ldots…$，<code>\cdots</code> 表示与文本中线对齐的横向省略号$\cdots⋯$</p></li><li><p>最值<br>  <code>\max_{下标表达式}{最值表达式}</code>表示最大值，<code>\min_{下标表达式}{最值表达式}</code>表达最小值</p></li><li><p>累加累乘<br>  使用 <code>\sum_{下标表达式}^{上标表达式}{累加表达式}</code>来输入一个累加。<br>  与之类似，使用 <code>\prod \bigcup \bigcap</code>来分别输入累乘、并集和交集。<br>  此类符号在行内显示时上下标表达式将会移至右上角和右下角。</p><pre><code>  $$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$</code></pre><p>  对应</p><script type="math/tex; mode=display">\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R</script></li><li><p>矢量<br>  使用 <code>\vec{矢量}</code>来自动产生一个矢量。<script type="math/tex">\vec{a}</script>对应$\vec{a}$</p></li><li><p>极限<br>  <code>\lim_{变量 \to 表达式} 表达式</code>, 比如<code>\lim_{n \to +\infty} \frac{1}{n(n+1)}</code><br>  对应</p><script type="math/tex; mode=display">\lim_{n \to +\infty} \frac{1}{n(n+1)}</script></li><li><p>导数<br>  ${\rm d}x$或${\text d}x$或$\text{d}x$</p></li><li><p>偏导<br>  <script type="math/tex">{\partial y} \over {\partial x}</script>对应${\partial y} \over {\partial x}$</p></li><li><p>梯度<br>  <script type="math/tex">\nabla f(x)</script>对应$\nabla f(x)$</p></li><li>积分<br>  \int_积分下限^积分上限 {被积表达式}, <code>\int_0^1 {x^2} \,{\rm d}x</code>对应<script type="math/tex; mode=display">\int_0^1 {x^2} \,{\rm d}x</script></li></ul><h3 id="公式编号"><a href="#公式编号" class="headerlink" title="公式编号"></a>公式编号</h3><ul><li><p>自动编号</p><pre><code>  $$  \begin{equation}  a^2+b^2=c^2  \end{equation}  $$</code></pre><p>  只需要在开始增加<code>\begin{equation}</code>，结束增加<code>\end{equation}</code></p><script type="math/tex; mode=display">  \begin{equation}  a^2+b^2=c^2  \end{equation}</script></li><li><p>手动编号</p><pre><code>  $$  x+y=z  \tag{3}  $$</code></pre><p>  对应只需要增加<code>\tag{编号}</code>，可以自定义修改公式编号，推荐自动编号</p><script type="math/tex; mode=display">  x+y=z  \tag{3}</script></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>%</code>单行注释, 主要方便自己对公式的维护和阅读</p><script type="math/tex; mode=display">% test commentx+y=z\tag{3}</script><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.latexlive.com/help" target="_blank" rel="noopener">在线文档</a></li><li><a href="https://www.latexlive.com/" target="_blank" rel="noopener">LaTex在线编辑器</a></li><li><a href="https://blog.csdn.net/NSJim/article/details/109066847" target="_blank" rel="noopener">LaTeX详细教程+技巧总结</a></li><li><a href="https://blog.csdn.net/NSJim/article/details/109045914" target="_blank" rel="noopener">LaTeX数学公式-详细教程</a></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>常用希腊字母对照</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">小写</th><th style="text-align:center">LaTeX</th><th style="text-align:center">读音</th><th style="text-align:center">序号</th><th style="text-align:center">大写</th><th style="text-align:center">LaTeX</th><th style="text-align:center">读音</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$\alpha$</td><td style="text-align:center">\alpha</td><td style="text-align:center">/ˈælfə/</td><td style="text-align:center">22</td><td style="text-align:center">$\sigma$</td><td style="text-align:center">\sigma</td><td style="text-align:center">/ˈsɪɡmə/</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$\beta$</td><td style="text-align:center">\beta</td><td style="text-align:center">/ˈbiːtə/, US: /ˈbeɪtə/</td><td style="text-align:center">23</td><td style="text-align:center">$\varsigma$</td><td style="text-align:center">\varsigma</td><td style="text-align:center">/ˈsɪɡmə/</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$\gamma$</td><td style="text-align:center">\gamma</td><td style="text-align:center">/ˈɡæmə/</td><td style="text-align:center">24</td><td style="text-align:center">$\tau$</td><td style="text-align:center">\tau</td><td style="text-align:center">/taʊ, tɔː/</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$\delta$</td><td style="text-align:center">\delta</td><td style="text-align:center">/ˈdɛltə/</td><td style="text-align:center">25</td><td style="text-align:center">$\upsilon$</td><td style="text-align:center">\upsilon</td><td style="text-align:center">/ˈʌpsɪlɒn/</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$\epsilon$</td><td style="text-align:center">\epsilon</td><td style="text-align:center">/ˈɛpsɪlɒn/</td><td style="text-align:center">26</td><td style="text-align:center">$\phi$</td><td style="text-align:center">\phi</td><td style="text-align:center">/faɪ/</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$\varepsilon$</td><td style="text-align:center">\varepsilon</td><td style="text-align:center">/ˈɛpsɪlɒn/</td><td style="text-align:center">27</td><td style="text-align:center">$\varphi$</td><td style="text-align:center">\varphi</td><td style="text-align:center">/faɪ/</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$\zeta$</td><td style="text-align:center">\zeta</td><td style="text-align:center">/ˈzeɪtə/</td><td style="text-align:center">28</td><td style="text-align:center">$\chi$</td><td style="text-align:center">\chi</td><td style="text-align:center">/kaɪ/</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">$\eta$</td><td style="text-align:center">\eta</td><td style="text-align:center">/ˈeɪtə/</td><td style="text-align:center">29</td><td style="text-align:center">$\psi$</td><td style="text-align:center">\psi</td><td style="text-align:center">/psaɪ/</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">$\theta$</td><td style="text-align:center">\theta</td><td style="text-align:center">/ˈθiːtə/</td><td style="text-align:center">30</td><td style="text-align:center">$\omega$</td><td style="text-align:center">\omega</td><td style="text-align:center">/oʊˈmeɪɡə/</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">$\vartheta$</td><td style="text-align:center">\vartheta</td><td style="text-align:center">/ˈθiːtə/</td><td style="text-align:center">31</td><td style="text-align:center">$\Gamma$</td><td style="text-align:center">\Gamma</td><td style="text-align:center">/ˈɡæmə/</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">$\iota$</td><td style="text-align:center">\iota</td><td style="text-align:center">/aɪˈoʊtə/</td><td style="text-align:center">32</td><td style="text-align:center">$\Delta$</td><td style="text-align:center">\Delta</td><td style="text-align:center">/ˈdɛltə/</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">$\kappa$</td><td style="text-align:center">\kappa</td><td style="text-align:center">/ˈkæpə/</td><td style="text-align:center">33</td><td style="text-align:center">$\Theta$</td><td style="text-align:center">\Theta</td><td style="text-align:center">/ˈθiːtə/</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">$\lambda$</td><td style="text-align:center">\lambda</td><td style="text-align:center">/ˈlæmdə/</td><td style="text-align:center">34</td><td style="text-align:center">$\Lambda$</td><td style="text-align:center">\Lambda</td><td style="text-align:center">/ˈlæmdə/</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">$\mu$</td><td style="text-align:center">\mu</td><td style="text-align:center">/mjuː/</td><td style="text-align:center">35</td><td style="text-align:center">$\Xi$</td><td style="text-align:center">\Xi</td><td style="text-align:center">/zaɪ, ksaɪ/</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">$\nu$</td><td style="text-align:center">\nu</td><td style="text-align:center">/njuː/</td><td style="text-align:center">36</td><td style="text-align:center">$\Pi$</td><td style="text-align:center">\Pi</td><td style="text-align:center">/paɪ/</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">$\xi$</td><td style="text-align:center">\xi</td><td style="text-align:center">/zaɪ, ksaɪ/</td><td style="text-align:center">37</td><td style="text-align:center">$\Sigma$</td><td style="text-align:center">\Sigma</td><td style="text-align:center">/ˈsɪɡmə/</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">$o$</td><td style="text-align:center">o</td><td style="text-align:center">/ˈɒmɪkrɒn/</td><td style="text-align:center">38</td><td style="text-align:center">$\Upsilon$</td><td style="text-align:center">\Upsilon</td><td style="text-align:center">/ˈʌpsɪlɒn/</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">$\pi$</td><td style="text-align:center">\pi</td><td style="text-align:center">/paɪ/</td><td style="text-align:center">39</td><td style="text-align:center">$\Phi$</td><td style="text-align:center">\Phi</td><td style="text-align:center">/faɪ/</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">$\varpi$</td><td style="text-align:center">\varpi</td><td style="text-align:center">/paɪ/</td><td style="text-align:center">40</td><td style="text-align:center">$\Psi$</td><td style="text-align:center">\Psi</td><td style="text-align:center">/psaɪ/</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">$\rho$</td><td style="text-align:center">\rho</td><td style="text-align:center">/roʊ/</td><td style="text-align:center">41</td><td style="text-align:center">$\Omega$</td><td style="text-align:center">\Omega</td><td style="text-align:center">/oʊˈmeɪɡə/</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">$\varrho$</td><td style="text-align:center">\varrho</td><td style="text-align:center">/roʊ/</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>书单</title>
      <link href="2023/07/09/%E4%B9%A6%E5%8D%95/"/>
      <url>2023/07/09/%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ol><li>《MEASUREMENT》PAUL LOCKHART, 中文版《度量》</li></ol><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><ol><li><a href="https://www.feynmanlectures.caltech.edu/" target="_blank" rel="noopener">《费曼物理学讲义》</a></li></ol><h2 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h2><ol><li><a href="http://hades.mech.northwestern.edu/index.php/Modern_Robotics" target="_blank" rel="noopener">《Modern Robotics: Mechanics, Planning, and Control》</a>Kevin M. Lynch and Frank C. Park 《现代机器人学：机构、规划与控制》</li><li>《Introduction to Robotics:Mechanics and Control》John J. Craig 《机器人学导论》</li></ol><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><ul><li><p>Linux</p><ol><li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a></li></ol></li><li><p>Ros</p><ol><li>《ROS机器人编程》更多资源参考<a href="http://wiki.ros.org/cn" target="_blank" rel="noopener">Ros官网</a></li></ol></li><li><p>C++</p><ol><li>《数据结构与算法》邓俊辉</li><li><a href="https://gearyyoung.gitbooks.io/cmake-api/content/" target="_blank" rel="noopener">《cmake-api》</a></li><li>《[设计模式：可复用面向对象软件的基础]》李英军等译，视频学习参考<a href="https://www.bilibili.com/video/BV1Yr4y157Ci/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8b3168fa50de13b934ede65b59261239" target="_blank" rel="noopener">C++设计模式入门</a></li></ol></li></ul><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><ol><li>《Feedback Control of Dynamic Systems》Gene F. Franklin_ J. Da Powell_ Abbas Emami-Naeini</li><li>《信号与系统》奥本海默</li></ol><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><ol><li>《金字塔原理》</li></ol><h2 id="在读"><a href="#在读" class="headerlink" title="在读"></a>在读</h2><ol><li>《毛泽东选集》毛泽东</li><li>《野草》鲁迅</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.cnblogs.com/yaoz/p/7392564.html" target="_blank" rel="noopener">国外优秀数学教材选评</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="2021/07/04/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>2021/07/04/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#卡尔曼滤波基本原理">卡尔曼滤波基本原理</a></li><li><a href="#理论推导">理论推导</a><ul><li><a href="#高斯分布融合">高斯分布融合</a></li><li><a href="#计算值和测量值融合">计算值和测量值融合</a></li></ul></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="卡尔曼滤波基本原理"><a href="#卡尔曼滤波基本原理" class="headerlink" title="卡尔曼滤波基本原理"></a>卡尔曼滤波基本原理</h2><p>现实中存在很多不确定性：</p><ul><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量的传感器存在误差</li></ul><p>卡尔曼滤波就是融合同一值的多个不确定性得到更准确的值，这里可以是模型计算值和测量值融合。参考知乎解释<a href="https://www.zhihu.com/question/23971601/answer/26254459" target="_blank" rel="noopener">如何通俗并尽可能详细地解释卡尔曼滤波？ - Kent Zeng的回答</a></p><p>用两个传感器同时测一个数值，最终结果可以取平均值，如果其中一个传感器更准确，取加权平均，加权的系数根据两个传感器的噪声分布（高斯分布）确定。实际中是数学模型计算出一个值，传感器测量出一个值，把这个两个值进行高斯分布的融合，得到的值的概率分布的方差更小（数据更准确）</p><h2 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h2><h3 id="高斯分布融合"><a href="#高斯分布融合" class="headerlink" title="高斯分布融合"></a>高斯分布融合</h3><p>两个一维高斯分布的融合就是概率的乘积然后归一化。一维高斯分布方程为$\mathcal{N}(x, \mu, \sigma)=\frac{1}{\sigma \sqrt{2 \pi}} e^{-\frac{(z-\mu)^{2} }{2 \sigma^{2}} }$。融合得到</p><script type="math/tex; mode=display">{\cal N}\left( {x,{\mu _0},{\sigma _0}} \right) \cdot {\cal N}\left( {x,{\mu _1},{\sigma _1}} \right) = {\cal N}\left( {x,{\mu ^\prime },{\sigma ^\prime }} \right)</script><p>其中</p><script type="math/tex; mode=display">{\mu ^\prime } = {\mu _0} + { {\sigma _0^2\left( { {\mu _1} - {\mu _0} } \right)} \over {\sigma _0^2 + \sigma _1^2} }</script><script type="math/tex; mode=display">{\sigma ^{\prime 2} } = \sigma _0^2 - { {\sigma _0^4} \over {\sigma _0^2 + \sigma _1^2} }</script><p>令${\bf{k}} = { {\sigma _0^2} \over {\sigma _0^2 + \sigma _1^2}}$则有</p><script type="math/tex; mode=display">{\mu ^\prime } = {\mu _0} + {\bf{k} }\left( { {\mu _1} - {\mu _0} } \right)</script><script type="math/tex; mode=display">{\sigma ^{\prime 2} } = \sigma _0^2 - {\bf{k} }\sigma _0^2</script><p>写成矩阵形式</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{K}=\Sigma_{0}\left(\Sigma_{0}+\Sigma_{1}\right)^{-1} \\\vec{\mu}^{\prime}=\overrightarrow{\mu_{0}}+\mathbf{K}\left(\overrightarrow{\mu_{1}}-\overrightarrow{\mu_{0}}\right) \\\Sigma^{\prime}=\Sigma_{0}-\mathbf{K} \Sigma_{0}\end{array}</script><p>其中$\mathbf{K}$为卡尔曼增益。</p><h3 id="计算值和测量值融合"><a href="#计算值和测量值融合" class="headerlink" title="计算值和测量值融合"></a>计算值和测量值融合</h3><p>连续系统的状态空间方程</p><script type="math/tex; mode=display">{ {\dot X}_t} = A{X_x} + B{U_t}</script><script type="math/tex; mode=display">{Z_t} = H{X_t}</script><p>其中$X$为系统的状态，$U$为系统的输入，$Z$传感器测量值，$H$状态到测量值的转换举证，由于传感器示数和状态的单位或者刻度不一样，$H$可能不是单位举证。</p><p>转换为离散形式，具体转换过程就叙述了，注意不是简单的替换，这里只是为了方便说明。</p><ol><li><p>计算值</p><script type="math/tex; mode=display">{X_k} = A{X_{k - 1}} + B{U_k} + {w_{k - 1}}</script><script type="math/tex; mode=display">{Z_k} = H{X_k}</script><p> 其中$w = {\cal N}(0,Q)$是由于模型不确定性和干扰带来的过程噪音</p><p> 设$Cov({X_k}) = {P_k}$为${X_k}$的协方差矩阵，又认为$U$的的协方差为0，并且和状态无关，过程噪声和状态也没有关系，则有${P_k} = A{P_{k - 1}}{A^{\rm{T}}}$<br> 所以就算值的协方差矩阵为</p><script type="math/tex; mode=display">Cov({Z_k}) = H{P_k}{H^{\rm{T}}}</script><p> 综上，计算值的概率分布为</p><script type="math/tex; mode=display">({\mu _0},{\Sigma _0}) = {\cal N}({H_k}{X_k},{H_k}{P_k}{H_k}^{\rm{T}})</script></li><li><p>测量值<br> 测量值的概率分布为，<script type="math/tex">({\mu _1},{\Sigma _1}) = {\cal N}({Z_k},{R_k})</script><br> 其中$R$为传感的噪声的方差</p></li><li><p>融合计算值和测量值<br> 借助上面高斯分布融合公式得到如下公式，用估计值作为计算值迭代求解下次估计值，初始状态估计值的均值的协方差可以大概给一个，会随着迭代次增加接近真实值。</p><script type="math/tex; mode=display">{\bf{\hat K}} = {P_k}H_k^T{\left( { {H_k}{P_k}H_k^T + {R_k} } \right)^{ - 1} }</script><script type="math/tex; mode=display">{ {\hat X}_k} = {X_k} + {\bf{\hat K} }\left( { {Z_k} - {H_k}{X_k} } \right)</script><script type="math/tex; mode=display">{ {\hat P}_k} = {P_k} - {\bf{\hat K} }{H_k}{P_k}</script></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://space.bilibili.com/230105574/channel/detail?cid=139198" target="_blank" rel="noopener">卡尔曼滤波器 视频详解</a></li><li><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener">How a Kalman filter works, in pictures</a></li><li><a href="https://blog.csdn.net/u010720661/article/details/63253509?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control" target="_blank" rel="noopener">详解卡尔曼滤波原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡尔曼滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械臂动力学</title>
      <link href="2021/01/16/%E6%9C%BA%E6%A2%B0%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
      <url>2021/01/16/%E6%9C%BA%E6%A2%B0%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#机械臂动力学">机械臂动力学</a><ul><li><a href="#牛顿欧拉递推动力学">牛顿欧拉递推动力学</a></li></ul></li></ul><!-- /code_chunk_output --><h2 id="机械臂动力学"><a href="#机械臂动力学" class="headerlink" title="机械臂动力学"></a>机械臂动力学</h2><p>动力学主要研究:</p><ul><li>已知轨迹点求期望的关机力矩,用于机械臂控制</li><li>已知力矩求机械臂运动的轨迹点,用于仿真</li></ul><h3 id="牛顿欧拉递推动力学"><a href="#牛顿欧拉递推动力学" class="headerlink" title="牛顿欧拉递推动力学"></a>牛顿欧拉递推动力学</h3><p>牛顿欧拉递推动力学是一种高效的动力学计算方法</p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>${ }^{B} V_{Q}$: $Q$点在坐标系$\{B\}$中求导并表示</li><li>${ }^A({ }^{B} V_{Q})$: $Q$点在坐标系$\{B\}$中求导并在坐标系$\{A\}$中表示</li><li>$v_c = { }^{U} V_{CORG}$: 坐标系$\{C\}$原点在常见坐标系$\{U\}$中求导并表示</li><li>${ }^{A} v_c = { }^B_A R { }^{U} V_{CORG}$: 坐标系$\{C\}$原点在常见坐标系$\{U\}$中求导并表示</li><li>${ }^{A} \Omega_{B}$: 坐标系$\{B\}$相对于坐标系$\{A\}$的旋转角速度</li><li>$w_c = { }^{U} \Omega_{C}$: 坐标系$\{C\}$相对于世界坐标系$\{U\}$的旋转角速度</li><li>${}^Aw_c = {}^A_UR{ }^{U} \Omega_{C}$: 坐标系$\{C\}$相对于世界坐标系$\{U\}$的旋转角速度在坐标系$\{A\}$中的表示</li></ul><h4 id="刚体线速度-线加速度"><a href="#刚体线速度-线加速度" class="headerlink" title="刚体线速度/线加速度"></a>刚体线速度/线加速度</h4><p>坐标系$\{A\}$固定,$\{B\}$与$\{A\}$的原点重合,则$\{B\}$中一点$Q$的速度为:</p><script type="math/tex; mode=display">{ }^{A} V_{Q}={ }_{B}^{A} R^{B} V_{Q}+{ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} Q</script><p>扩展到原点不重合:</p><script type="math/tex; mode=display">{ }^{A} V_{Q}={}^AV_Q + { }_{B}^{A} R^{B} V_{Q}+{ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} Q</script><p>求导得:</p><script type="math/tex; mode=display">\begin{aligned}{ }^{A} V_{Q}={ }^{A} \dot{V}_{B O R G} &+{ }_{B}^{A} R^{B} \dot{V}_{Q}+2^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} V_{Q}+{ }^{A} \dot{\Omega}_{B} \times{ }_{B}^{A} R^{B} Q \\&+{ }^{A} \Omega_{B} \times\left({ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} Q\right)\end{aligned}</script><p>此式子可根据不同情况进行简化,比如${}^BQ$是常量时${ }^{B} V_{Q}={ }^{B} \dot{V}_{Q}=0$</p><h4 id="角速度-角加速度"><a href="#角速度-角加速度" class="headerlink" title="角速度/角加速度"></a>角速度/角加速度</h4><p>$\{B\}$相对于于$\{A\}$的角速度${}^A\Omega_B$,$\{C\}$相对于于$\{B\}$的角速度${}^B\Omega_C$,则有</p><script type="math/tex; mode=display">{ }^{A} \Omega_{C}={ }^{A} \Omega_{B}+{ }_{B}^{A} R^{B} \Omega_{C}</script><p>求导得:</p><script type="math/tex; mode=display">{ }^{A} \dot{\Omega}_{C}={ }^{A} \dot{\Omega}_{B}+{ }_{B}^{A} R^{B} \dot{\Omega}_{C}+{ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} \Omega_{C}</script><h4 id="连杆速度传递"><a href="#连杆速度传递" class="headerlink" title="连杆速度传递"></a>连杆速度传递</h4><p>机械臂关节坐标系如图所示<br><img src="/2021/01/16/机械臂动力学/连杆速度传递.png" alt="连杆速度传递(图片来自Introduction to Robotics:Mechanics and Control)"></p><ol><li><p>直接采用前面推论进行替换得到最终的表达式<br> 角速度/角加速度推导</p><ul><li><p>坐标系$\{A\}$替换为坐标系$\{0\}$(世界坐标系),$\{B\}$替换为$\{i\}$,$\{Q\}$替换为$\{i+1\}$(可在$Q$点建立一个坐标系)</p></li><li><p>替换完之后左乘矩阵${}^{i+1}_0R$即可得到最终表达时</p><p>线速度/线加速度推导</p></li><li><p>坐标系$\{A\}$替换为坐标系$\{0\}$(世界坐标系),$\{B\}$替换为$\{i\}$,$\{C\}$替换为$\{i+1\}$</p></li><li><p>替换完之后左乘矩阵${}^{i+1}_0R$即可得到最终表达时</p></li></ul></li><li><p>直接求导推导<br> 世界坐标系下角速度:连杆的角速度等于上一个连杆的角速度加上由于关节转动带来的角速度</p><script type="math/tex; mode=display"> \boldsymbol{\omega}_{i+1}=\boldsymbol{\omega}_{i}+\dot{\boldsymbol{\theta}}_{i+1} \boldsymbol{z}_{i+1}</script><p> 求导然后左乘${}^{i+1}_0R$即可得到角加速度表达式,借助公式${}^0_i \dot{\boldsymbol{R}} = {}^0 \omega_{i} \times {}^0_i\boldsymbol{R}$</p><script type="math/tex; mode=display"> { }^{i+1} \dot{\omega}_{i+1}={ }_{i}^{i+1} R^{i} \dot{\omega}_{i}+{ }_{i}^{i+1} R^{i} \omega_{i} \times \dot{\theta}_{i+1}{ }^{i+1} \hat{z}_{i+1}+\ddot{\theta}_{i+1}{ }^{i+1} \hat{z}_{i+1}</script><p> 同理世界坐标系下线速度:连杆的线速度等于上一个连杆的线速度,上一个连杆转动带来的线速度,以及关节平移(移动关节才有)带来的速度之和</p><script type="math/tex; mode=display"> \boldsymbol{v}_{i+1}=\boldsymbol{v}_{i}+\boldsymbol{\omega}_{i} \times ({}^0_iR{}^i\boldsymbol{p}_{i+1})+\dot{\boldsymbol{d}}_{i+1} \boldsymbol{z}_{i+1}</script><p> ${}^0_iR{}^i\boldsymbol{p}_{i+1}$表示连杆坐标系$\{i\}$原点到$\{i+1\}$原点向量在世界坐标系下的表示<br> 求导即可得到线加速度关系,注意如果是移动关节,那么$\boldsymbol{p}_{i+1}$也是变化的所以才会有公式里面的倍数2,对应科式加速度</p><script type="math/tex; mode=display"> \begin{aligned} { }^{i+1} \dot{v}_{i+1} &={ }_{i}^{i+1} R\left({ }^{i} \dot{\omega}_{i} \times{ }^{i} P_{i+1}+{ }^{i} \omega_{i} \times\left({ }^{i} \omega_{i} \times{ }^{i} P_{i+1}\right)+{ }^{i} \dot{v}_{i}\right) \\ &+2^{i+1} \omega_{i+1} \times \dot{d}_{i+1}{ }^{i+1} \hat{z}_{i+1}+\ddot{d}_{i+1}{ }^{i+1} \hat{z}_{i+1} \end{aligned}</script><p> 也可以根据绝对加速度=相对加速度+牵连加速度+科式加速度来计算,在之前的文章<a href="/2020/01/13/科式加速度/" title="科式加速度">科式加速度</a>中有提到过<br> 质心的加速度更明显一点</p><script type="math/tex; mode=display"> {}^i \dot{v}_{C_{i}}={}^i\dot{\omega}_{i} \times^{i} P_{C_{i}}+{ }^{i} \omega_{i} \times\left({ }^{i} \omega_{i} \times { }^{i} P_{C_{i}}\right)+^{i} \dot{v}_{i}</script></li></ol><h4 id="连杆力-力矩传递"><a href="#连杆力-力矩传递" class="headerlink" title="连杆力/力矩传递"></a>连杆力/力矩传递</h4><p>不考虑重力,利用平衡方程递推关节力矩</p><script type="math/tex; mode=display">\begin{array}{l}F_{i}=m \dot{v}_{c_{i}} \\N_{i}=^{c_{i}} I \dot{\omega}_{i}+\omega_{i} \times^{c_{i}} I \omega_{i}\end{array}</script><p>得到转动关节递推算法:<br>外推:1-&gt;5:<br>${}^{i+1}  \omega_{i+1}={ }_{i}^{i+1} R^{i} \omega_{i}+\dot{\theta}_{i+1}^{i+1} \hat{Z}_{i+1}$<br>${ }^{i+1} \dot{\omega}_{i+1} ={ }_{i}^{i+1} R^{i} \dot{\omega}_{i}+{ }_{i}^{i+1} R^{i} \omega_{i} \times \dot{\theta}_{i+1}^{i+1} \hat{Z}_{i+1}+\ddot{\theta}_{i+1}^{i+1} \hat{Z}_{i+1}$<br>${ }^{i+1} \dot{v}_{i+1} ={ }_{i}^{i+1} R\left({ }^{i} \dot{\omega}_{i} \times{ }^{i} P_{i+1}+{ }^{i} \omega_{i} \times\left({ }^{i} \omega_{i} \times{ }^{i} P_{i+1}\right)+{ }^{i} \dot{v}_{i}\right)$<br>${ }^{i+1} \dot{v}_{C_{i+1}} ={ }^{i+1} \dot{\omega}_{i+1} \times{ }^{i+1} P_{C_{i+1}}+{ }^{i+1} \omega_{i+1} \times\left({ }^{i+1} \omega_{i+1} \times{ }^{i+1} P_{C_{i+1}}\right)+{ }^{i+1} \dot{v}_{i+1} $<br>${ }^{i+1} F_{i+1} =m_{i+1}{ }^{i+1} \dot{v}_{C_{i+1}}$<br>${ }^{i+1} N_{i+1} ={}^{C_{i+1}} I_{i+1}{ }^{i+1} \dot{\omega}_{i+1}+{ }^{i+1} \omega_{i+1} \times {}^{C_{i+1}} I_{i+1}{ }^{i+1} \omega_{i+1}$</p><p>内推:6-&gt;1<br>${}^i f_{i}={ }_{i+1}^{i} R^{i+1} f_{i+1}+{ }^{i} F_{i}$<br>${ }^{i} n_{i}={ }^{i} N_{i}+{ }_{i+1}^{i} R^{i+1} n_{i+1}+{ }^{i} P_{C_{i}} \times{ }^{i} F_{i}+{ }^{i} P_{i+1} \times{ }_{i+1}^{i} R^{i+1} f_{i+1}$<br>$\tau_{i}={ }^{i} n_{i}^{T} i \hat{Z}_{i}$</p><p>考虑重力:令${ }^{0} \dot{v}_{0}=G$,其中$G$与重力大小相等,方向相反,等价于机器人以1g的加速度向上做加速运动</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li>机器人学导论(Introduction to Robotics:Mechanics and Control)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=2650215895&amp;idx=1&amp;sn=98163c17bc650fc26c7dd2b52cede55c&amp;chksm=f1fb2efbc68ca7ed54b5c4c8ef33a2a02f27fe0dbb168a47d7550bdae2d1e22fd0950810169c&amp;mpshare=1&amp;scene=1&amp;srcid=01164QqSklrW7oMLuaaQ3E3v&amp;sharer_sharetime=1610778773411&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=A0RunuAtEUc1BIRp1U8qEPs%3D&amp;pass_ticket=fSV9aDHJ8qPwgo9Tg8KgiZWwCQ1rLqEqLnyLTx1rWWkQ12bzO4ZqXXrvKB6W%2FXxk&amp;wx_header=0#rd" target="_blank" rel="noopener">干货 | 机械臂的动力学（一）：牛顿欧拉法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub的raw.githubusercontent.com无法链接</title>
      <link href="2020/12/27/GitHub%E7%9A%84raw-githubusercontent-com%E6%97%A0%E6%B3%95%E9%93%BE%E6%8E%A5/"/>
      <url>2020/12/27/GitHub%E7%9A%84raw-githubusercontent-com%E6%97%A0%E6%B3%95%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="无法使用rosdep-update更新"><a href="#无法使用rosdep-update更新" class="headerlink" title="无法使用rosdep update更新"></a>无法使用rosdep update更新</h2><p><code>rosdep update</code>报错</p><pre><code>&lt;urlopen error &lt;urlopen error [Errno 111] Connection refused&gt; (https://raw.githubusercontent.com/ros/rosdistro/master/index-v4.yaml)&gt;</code></pre><p>排查问题<br><code>ping</code>延迟太小了,国外服务器不可能延迟这么低,应该是本地的ip</p><pre><code>ping raw.githubusercontent.com      64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.030 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.036 ms64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.025 ms</code></pre><p>进入<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a>,输入githubusercontent.com,得到<br>199.232.96.133,发现<code>ping</code>延迟很高,说明这才是真正的ip</p><pre><code>ping 199.232.96.13364 bytes from 199.232.96.133: icmp_seq=1 ttl=42 time=239 ms64 bytes from 199.232.96.133: icmp_seq=2 ttl=42 time=267 ms64 bytes from 199.232.96.133: icmp_seq=3 ttl=42 time=287 ms</code></pre><p>说明是DNS解析ip地址出了问题</p><p>解决方案:</p><ol><li><p>把真是ip写入host</p><pre><code> sudo gedit /etc/hosts # 增加一行   199.232.96.133 raw.githubusercontent.com</code></pre></li><li><p>修改DNS解析</p><pre><code> sudo gedit /etc/resolv.conf # 增加两行 nameserver 8.8.8.8 #google域名服务器 nameserver 8.8.4.4 #google域名服务器</code></pre><p> 进入这个文件发现提示不建议修改<strong>DO NOT EDIT THIS FILE BY HAND — YOUR CHANGES WILL BE OVERWRITTEN</strong><br> 不过也能用,之后再研究一下ubuntu DNS解析的内容</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.cnblogs.com/xyann/p/12738326.html" target="_blank" rel="noopener">GitHub的raw.githubusercontent.com无法链接</a></li><li><a href="https://blog.csdn.net/mrh1714348719/article/details/103803110" target="_blank" rel="noopener">ubuntu安装ROS进行到rosdep update时出现错误，如ERROR: unable to process source …</a></li><li><a href="http://hshsh.me/post/2016-08-09-ubuntu-14.04-dnsmasq/" target="_blank" rel="noopener">Ubuntu14.04上DNS引发的血案</a>            </li></ol>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机标定</title>
      <link href="2020/12/26/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
      <url>2020/12/26/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#相机内参标定">相机内参标定</a><ul><li><a href="#kalib">kalib</a></li><li><a href="#camera-calibration">camera-calibration</a></li></ul></li><li><a href="#相机外参标定手眼标定">相机外参标定(手眼标定)</a><ul><li><a href="#franka-realsense-标定">franka realsense 标定</a></li></ul></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="相机内参标定"><a href="#相机内参标定" class="headerlink" title="相机内参标定"></a>相机内参标定</h2><p>主要有两种方式</p><ul><li><a href="http://wiki.ros.org/camera_calibration/Tutorials/StereoCalibration" target="_blank" rel="noopener">camera-calibration</a></li><li><a href="https://github.com/ethz-asl/kalibr" target="_blank" rel="noopener">kalibr</a></li></ul><h3 id="kalib"><a href="#kalib" class="headerlink" title="kalib"></a>kalib</h3><ol><li><p>生成标定棋格盘</p><p> 可以使用<a href="https://github.com/ethz-asl/kalibr/wiki/calibration-targets" target="_blank" rel="noopener">kalibr_create_target_pdf</a></p><p> 查看帮助</p><pre><code> kalibr_create_target_pdf --h kalibr_create_target_pdf --type apriltag --nx [NUM_COLS] --ny [NUM_ROWS] --tsize [TAG_WIDTH_M] --tspace [TAG_SPACING_PERCENT]</code></pre><p> 生成A4纸棋盘内部角点个数6x7棋盘格,边长0.030m,打印的时候选择实际大小,否则打印出来的格子可能比较小.可能需要安装模块<code>sudo apt-get install python-pyx</code></p><pre><code>  kalibr_create_target_pdf --type checkerboard --nx 6 --ny 7 --csx 0.030 --csy 0.030</code></pre></li></ol><ol><li><p>录制bag包<br> 首先运行相机驱动</p><p> 可以更改相机话题和频率</p><pre><code> rosrun topic_tools throttle messages /camera/color/image_raw 4.0 /color</code></pre><p> 录制图像</p><pre><code> rosbag record -O camd435 /color</code></pre></li><li><p>标定<br> 一种是使用<code>kalibr_calibrate_cameras</code>标定</p><p> 生成<code>checkerboard.yaml</code>文件</p><pre><code> target_type: &#39;checkerboard&#39; #gridtype targetCols: 6               #number of internal chessboard corners targetRows: 7               #number of internal chessboard corners rowSpacingMeters: 0.03      #size of one chessboard square [m] colSpacingMeters: 0.03      #size of one chessboard square [m]</code></pre><p> 标定</p><pre><code> kalibr_calibrate_cameras --target path/to/checkerboard.yaml --bag path/to/camd435i.bag --models pinhole-equi --topics /color --show-extractio</code></pre><hr><p> 另一种是使用matlab工具箱标定</p><pre><code> %% 读取bag文件 bag = rosbag(&#39;camd435.bag&#39;); geometry_message = select(bag,&#39;Topic&#39;,&#39;/color&#39;); data = readMessages(geometry_message); imshow(readImage(data{1, 1}));  % 显示图片 % 保存图片 for i = 1 : length(data)     im_data = readImage(data{i, 1});         imwrite(im_data, [num2str(i), &#39;.png&#39;]); end %% matlab 工具箱Camera Calibrator(在app里面搜索然后导入图片) 标定后可以生成代码</code></pre></li></ol><h3 id="camera-calibration"><a href="#camera-calibration" class="headerlink" title="camera-calibration"></a>camera-calibration</h3><ol><li><p>安装标定包</p><pre><code> sudo apt-get install ros-kinetic-camera-calibration</code></pre></li><li><p>运行标定程序<br> 会有一个GUI方便操作,将棋盘对着相机朝着左/右/上/下/前/后移动，还需要倾斜棋盘。绿色填满之后点击CALIBRATE按钮,需要等几分钟. 生成的文件在<code>/tmp/calibrationdata.tar.gz</code>中</p><pre><code> rosrun camera_calibration cameracalibrator.py --size 6x7 --square 0.03 image:=/image_raw camera:=/camera</code></pre></li><li><p>获取标定结果</p><pre><code> cd /tmp tar -xvzf calibrationdata.tar.gz mv ost.txt ost.ini # 得到camera.yaml rosrun camera_calibration_parsers convert ost.ini camera.yaml</code></pre></li></ol><h2 id="相机外参标定-手眼标定"><a href="#相机外参标定-手眼标定" class="headerlink" title="相机外参标定(手眼标定)"></a>相机外参标定(手眼标定)</h2><p>这篇文章的图片已经解释的很清楚了<a href="https://blog.csdn.net/yaked/article/details/77161160?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">机器人手眼标定Ax=xB（eye to hand和eye in hand）及平面九点法标定</a></p><ol><li>eye-in-hand<br> 两次运动,机器人底座和标定板的位恣关系不变,求解相机和机器人末端的位姿关系<br> <img src="/2020/12/26/相机标定/eye-in-hand.png" alt="eye-in-hand">    </li><li>eye-on-base<br> 两次运动,机器人末端和标定板的位恣关系不变,求解相机和机器人基座之间的位恣关系<br> <img src="/2020/12/26/相机标定/eye-on-base.png" alt="eye-on-base"></li></ol><h3 id="franka-realsense-标定"><a href="#franka-realsense-标定" class="headerlink" title="franka realsense 标定"></a>franka realsense 标定</h3><p>主要使用了三个包:</p><ul><li><a href="https://github.com/pal-robotics/aruco_ros" target="_blank" rel="noopener">aruco_ros</a>, 相机获取二维码位恣,二维码可通过<a href="https://chev.me/arucogen/" target="_blank" rel="noopener">ArUco markers generator!</a>生成,记得一定要选择<em>Original ArUco</em><br>ID和size根据需要选择,这两个参数在之后的launch文件中使用,这里选用的是ID:582,size:50</li><li><a href="https://github.com/IFL-CAMP/easy_handeye" target="_blank" rel="noopener">easy_handeye</a>, 结合moveit标定的包</li><li><a href="https://github.com/IntelRealSense/realsense-ros" target="_blank" rel="noopener">realsense-ros</a>, realsense ros驱动</li></ul><p>则有标定launch文件如下,标定后得到camera_link到panda_link0的位恣变换,然后在launch文件中使用tf2_ros中的static_transform_publisher发布出来即可使用</p><pre><code>    &lt;?xml version=&quot;1.0&quot; ?&gt;    &lt;launch&gt;        &lt;!--  franka --&gt;        &lt;arg name=&quot;robot_ip&quot; default=&quot;192.168.10.102&quot;/&gt;        &lt;arg name=&quot;move_group&quot; default=&quot;panda_arm&quot; /&gt;        &lt;arg name=&quot;robot_base_frame&quot; default=&quot;panda_link0&quot;/&gt;        &lt;arg name=&quot;robot_effector_frame&quot; default=&quot;panda_EE&quot;/&gt;        &lt;!--  marker  --&gt;        &lt;arg name=&quot;markerId&quot;        default=&quot;582&quot;/&gt;        &lt;arg name=&quot;markerSize&quot;      default=&quot;0.05&quot;/&gt;    &lt;!-- in m --&gt;        &lt;arg name=&quot;marker_frame&quot;    default=&quot;aruco_marker_frame&quot;/&gt;        &lt;arg name=&quot;ref_frame&quot;       default=&quot;camera_link&quot;/&gt;  &lt;!-- leave empty and the pose will be published wrt param parent_name --&gt;        &lt;arg name=&quot;camera_frame&quot;    default=&quot;camera_color_optical_frame&quot;/&gt;        &lt;arg name=&quot;corner_refinement&quot; default=&quot;LINES&quot; /&gt; &lt;!-- NONE, HARRIS, LINES, SUBPIX --&gt;        &lt;!--  launch franka  --&gt;        &lt;include file=&quot;$(find franka_control)/launch/franka_control.launch&quot;&gt;            &lt;arg name=&quot;robot_ip&quot; value=&quot;$(arg robot_ip)&quot; /&gt;            &lt;arg name=&quot;load_gripper&quot; value=&quot;true&quot; /&gt;        &lt;/include&gt;        &lt;include file=&quot;$(find panda_moveit_config)/launch/panda_moveit.launch&quot;&gt;            &lt;arg name=&quot;load_gripper&quot; value=&quot;true&quot; /&gt;        &lt;/include&gt;        &lt;!--  panda_link0 to world TF  --&gt;        &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;virtual_joint_broadcaster_1&quot; args=&quot;0 0 0 0 0 0 world panda_link0&quot; /&gt;        &lt;!--  realsense  --&gt;        &lt;include file=&quot;$(find realsense2_camera)/launch/rs_camera.launch&quot;/&gt;        &lt;!--  marker  --&gt;        &lt;node pkg=&quot;aruco_ros&quot; type=&quot;single&quot; name=&quot;aruco_single&quot;&gt;            &lt;remap from=&quot;/camera_info&quot; to=&quot;/camera/color/camera_info&quot; /&gt;            &lt;remap from=&quot;/image&quot; to=&quot;/camera/color/image_raw&quot; /&gt;            &lt;param name=&quot;image_is_rectified&quot; value=&quot;True&quot;/&gt;            &lt;param name=&quot;marker_size&quot;        value=&quot;$(arg markerSize)&quot;/&gt;            &lt;param name=&quot;marker_id&quot;          value=&quot;$(arg markerId)&quot;/&gt;            &lt;param name=&quot;reference_frame&quot;    value=&quot;$(arg ref_frame)&quot;/&gt;   &lt;!-- frame in which the marker pose will be refered --&gt;            &lt;param name=&quot;camera_frame&quot;       value=&quot;$(arg camera_frame)&quot;/&gt;            &lt;param name=&quot;marker_frame&quot;       value=&quot;$(arg marker_frame)&quot; /&gt;            &lt;param name=&quot;corner_refinement&quot;  value=&quot;$(arg corner_refinement)&quot; /&gt;        &lt;/node&gt;        &lt;node pkg=&quot;image_view&quot; type=&quot;image_view&quot; name=&quot;iamge_view&quot; args=&quot;image:=/aruco_single/result&quot; /&gt;        &lt;!--  easy hand eye calibrate  --&gt;        &lt;include file=&quot;$(find easy_handeye)/launch/calibrate.launch&quot;&gt;            &lt;arg name=&quot;eye_on_hand&quot; value=&quot;false&quot;/&gt;            &lt;arg name=&quot;move_group&quot; value=&quot;$(arg move_group)&quot; /&gt;            &lt;!-- fill in the following parameters according to your robot&#39;s published tf frames --&gt;            &lt;arg name=&quot;robot_base_frame&quot; value=&quot;$(arg robot_base_frame)&quot;/&gt;            &lt;arg name=&quot;robot_effector_frame&quot; value=&quot;$(arg robot_effector_frame)&quot;/&gt;            &lt;!-- fill in the following parameters according to your tracking system&#39;s published tf frames --&gt;            &lt;arg name=&quot;tracking_base_frame&quot; value=&quot;$(arg ref_frame)&quot;/&gt;            &lt;arg name=&quot;tracking_marker_frame&quot; value=&quot;$(arg marker_frame)&quot;/&gt;        &lt;/include&gt;    &lt;/launch&gt;</code></pre><p>遇到的问题:</p><ol><li><p>import cv2的版本不对(<code>pip3 install opencv-python</code> <code>pip install opencv-contrib-python</code> 安装位置在~/.local下)</p><pre><code> # 查看cv2的路径 发现对的cv2在~/.local下 import cv2 help(cv2)  # 是cv2.so文件 可以通过locate定位(根据需要进行updatedb) # 查看python path信息 import sys sys.path    # &#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;在前面, 而对的cv2在~/.local,排在后面 # 在需要用到cv2的地方如下处理即可 import sys sys.path.remove(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;) import cv2 sys.path.append(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;)</code></pre></li><li><p>无法显示rqt_gui界面的gui操作框<br>可能是由于conda环境冲突,切换回系统对应的环境就可以了(最开始是把libqt5*卸载之后再安装依赖就可以,之后发现还是得切换回之前的环境)</p></li><li><p>相机对反光敏感<br> 相机外参标定好之后在rviz中查看点云,人站在相机正前方走动会产生其它地方的点云(机械臂附近),造成干扰</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/yaked/article/details/77161160?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">机器人手眼标定Ax=xB（eye to hand和eye in hand）及平面九点法标定</a></li><li><a href="https://mp.weixin.qq.com/s/nJx1dlpBXaL2_iT_J4W5Kg" target="_blank" rel="noopener">3D 视觉之手眼标定</a></li><li><a href="https://blog.csdn.net/qq_34935373/article/details/103727968" target="_blank" rel="noopener">通过ROS控制真实机械臂(15) —- 视觉抓取之手眼标定</a></li><li><a href="https://blog.csdn.net/AnChenliang_1002/article/details/109775356" target="_blank" rel="noopener">Inter Realsense D435i标定过程步骤记录（超详细）</a></li><li><a href="https://blog.csdn.net/qq_42688495/article/details/107640826" target="_blank" rel="noopener">视觉SLAM | RealsenseD435i相机标定</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyhton 代码规范</title>
      <link href="2020/12/12/pyhton-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>2020/12/12/pyhton-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ol><li>缩进<br> 缩进必须使用4个空格，而不是tab，否则容易出现pylint:<code>bad-indentation.</code><br> vscode可以将tab转化为空格<br> F1 -&gt; 输入indentation space -&gt; 回车  (查看是空格还是tab可以通过选中对应行或者全选)</li></ol><h2 id="c-vscode-自动格式化"><a href="#c-vscode-自动格式化" class="headerlink" title="c++  vscode 自动格式化"></a>c++  vscode 自动格式化</h2><ul><li><p>设置 -&gt; 搜索 clang format -&gt; 在Clang_format_path 中输入</p><pre><code>  { BasedOnStyle: Google, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Custom, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 100, AccessModifierOffset: -3 }</code></pre></li><li>设置 -&gt; 搜索 save format -&gt; 勾选Format on Save</li></ul>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四元数</title>
      <link href="2020/11/25/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
      <url>2020/11/25/%E5%9B%9B%E5%85%83%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><p>四元数是由爱尔兰数学家威廉·卢云·哈密顿在1843年创立出的数学概念.速度更快、提供平滑插值、有效避免万向锁问题、存储空间较小.</p><script type="math/tex; mode=display">q=a+b i+c j+d k \quad(a, b, c, d \in \mathbb{R})</script><p>其中</p><script type="math/tex; mode=display">i^{2}=j^{2}=k^{2}=i j k=-1</script><h2 id="罗德里格旋转公式-Rodrigues’-rotation-formula"><a href="#罗德里格旋转公式-Rodrigues’-rotation-formula" class="headerlink" title="罗德里格旋转公式(Rodrigues’ rotation formula)"></a>罗德里格旋转公式(Rodrigues’ rotation formula)</h2><p>罗德里格旋转公式是在给定转轴和旋转角度后,旋转一个向量的有效算法.公式如下,具体推导参考图片(<a href="https://commons.wikimedia.org/w/index.php?curid=43943835" target="_blank" rel="noopener">By Maschen - Own work, CC0</a>)</p><p><img src="/2020/11/25/四元数/rodrigues_rotation_formula.svg" alt="rodrigues rotation formula"></p><script type="math/tex; mode=display">\mathbf{v}_{\mathrm{rot}}=\mathbf{v} \cos \theta+(\mathbf{k} \times \mathbf{v}) \sin \theta+\mathbf{k}(\mathbf{k} \cdot \mathbf{v})(1-\cos \theta)</script><h2 id="四元数基本运算"><a href="#四元数基本运算" class="headerlink" title="四元数基本运算"></a>四元数基本运算</h2><ul><li><p>模长</p><script type="math/tex; mode=display">  \|q\|=\sqrt{a^{2}+b^{2}+c^{2}+d^{2}}</script></li><li><p>加减法</p><script type="math/tex; mode=display">  q_{1} \pm q_{2}=[s \pm t, \mathbf{v} \pm \mathbf{u}]</script></li><li><p>乘法<br>  对任意四元数 $q_{1}=[s, \mathbf{v}], q_{2}=[t, \mathbf{u}]$ 有</p><script type="math/tex; mode=display">  q_{1} q_{2}=[s t-\mathbf{v} \cdot \mathbf{u}, s \mathbf{u}+t \mathbf{v}+\mathbf{v} \times \mathbf{u}]</script></li><li><p>逆</p><script type="math/tex; mode=display">  q^{-1}=\frac{q^{*}}{\|q\|^{2}}</script><script type="math/tex; mode=display">  q_{1}^{*} q_{2}^{*}=\left(q_{2} q_{1}\right)^{*}</script></li><li><p>旋转公式</p><script type="math/tex; mode=display">  v^{\prime}=q v q^{*}=q v q^{-1}</script><p>  可借助罗德里格旋转公式,分别对垂直旋转轴和平行旋转轴的向量进行旋转.</p><p>  或者借助$\mathbf{a} \times(\mathbf{b} \times \mathbf{c})=(\mathbf{a} \cdot \mathbf{c}) \mathbf{b}-(\mathbf{a} \cdot \mathbf{b}) \mathbf{c}$直接推导</p><script type="math/tex; mode=display">  q v q^{*}=[0, \cos (\theta) \mathbf{v}+(1-\cos (\theta))(\mathbf{u} \cdot \mathbf{v}) \mathbf{u}+\sin (\theta)(\mathbf{u} \times \mathbf{v})]</script><p>  注意:可以证明<strong>即使v不是实部为0的纯四元数,旋转公式所得结果的向量部分也相同</strong></p></li></ul><h2 id="双倍覆盖"><a href="#双倍覆盖" class="headerlink" title="双倍覆盖"></a>双倍覆盖</h2><p>四元数q与-q表示同一个旋转,轴正方向旋转$\theta $,与反方向旋转$2\pi  - \theta $等价</p><h2 id="四元数插值"><a href="#四元数插值" class="headerlink" title="四元数插值"></a>四元数插值</h2><ol><li><p>两个四元数之间中间变换<br> 两个四元数之间的中间变换可以通过对空间中一个向量的变换来理解.<br> 四元数${q_0}$到${q_1}$的变换</p><script type="math/tex; mode=display"> \begin{aligned} \Delta q &=q_{1} q_{0}^{*} \\ &=\left[\cos \left(\theta_{1}\right), \sin \left(\theta_{1}\right) \mathbf{u}_{1}\right]\left[\cos \left(\theta_{0}\right),-\sin \left(\theta_{0}\right) \mathbf{u}_{0}\right] \\ &=\left[\cos \left(\theta_{0}\right) \cos \left(\theta_{1}\right)-\left(\sin \left(\theta_{1}\right) \mathbf{u}_{1}\right) \cdot\left(-\sin \left(\theta_{0}\right) \mathbf{u}_{0}\right), \ldots\right] \\ &=\left[\cos \left(\theta_{0}\right) \cos \left(\theta_{1}\right)+\left(\sin \left(\theta_{1}\right) \mathbf{u}_{1}\right) \cdot\left(\sin \left(\theta_{0}\right) \mathbf{u}_{0}\right), \ldots\right] \end{aligned}</script><p> $\Delta q$的角度看实部就可以了,实部就是两个四元数的点乘${q_0} \cdot {q_1}$的结果,由于两个都是单位四元数,所以中间变换$\Delta q$在三维空间中实际旋转的角度就是两个四元数之间夹角的两倍</p></li><li><p>常用插值算法</p><ul><li>正规化线性插值（Normalized Linear Interpolation）,沿着直线进行差值,在差值角度比较大会出现角速度不均匀</li><li><p>球面线性插值 ( Spherical Linear Interpolation), 最常用的姿态差值算法, 运算会多一点,较慢, 小角度通常选用Nlerp,效果差不多, 还能避免除以0的错误, 实际算法中可以检测四元数之间的夹角, 小角度用Nlerp,大角度用Slerp</p><p><strong>同时由于双倍覆盖的问题,在进行姿态插值时需要先计算两个四元数之间夹角是否大于90°,如果大于可以把其中一个四元素反转,即-q</strong>       </p></li></ul></li></ol><h2 id="四元数在不同坐标系下变换"><a href="#四元数在不同坐标系下变换" class="headerlink" title="四元数在不同坐标系下变换"></a>四元数在不同坐标系下变换</h2><ol><li><p>求${q}$姿态对应坐标系下z轴在极坐标系下的表示如下,只需要把全局坐标系中z轴(0,0,1)进行对应变换就可以(同旋转矩阵一样,可以理解为旋转算子或者姿态)</p><script type="math/tex; mode=display">q \cdot z \cdot {q^ * }</script></li><li><p>求两个四元素之间的中间变换对应的轴,比如${q_1}$到${q_0}$,</p><p> ${q_0}q_1^*$,然后取出旋转轴就可以.如果想把轴转换到${q_0}$坐标系下,则旋转回来再提取轴</p><p> 另外在<a href="https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/src/cartesian_impedance_example_controller.cpp" target="_blank" rel="noopener">franka程序</a>    中看到换了成了$q_0^ * {q_1}$ ,然后增加负号并旋转变换到基坐标系下,这里推导<strong>只针对向量部分</strong>,即旋转轴,借助前面的结论<strong>普通四元数与纯四元数使用旋转公式后向量部分同</strong><br> 这里还使用了单位四元数的共轭就是逆,即把向量部分取负号</p><script type="math/tex; mode=display">{q_0}( - q_0^ * {q_1})q_0^ *  = {q_0}{(q_0^ * {q_1})^{ - 1}}q_0^ *  = {q_0}q_1^ * {q_0}q_0^ *  = {q_0}q_1^ *</script></li></ol><h2 id="四元数可视化"><a href="#四元数可视化" class="headerlink" title="四元数可视化"></a>四元数可视化</h2><p>参考3blue1brown的教程,四元数变换可以理解为对四维空间的变换然后投影到三维空间成我们见到的.</p><p>变换的形象理解是拉伸和旋转,考虑一个四元数对另一个四元数的作用(变换),简单理解就是对四元数的基1,i,j,k作用看效果</p><ul><li>把位于原点的1拉伸到四元数乘子所在位置</li><li>绕轴旋转对应的角度</li></ul><p>文章:<a href="https://eater.net/quaternions" target="_blank" rel="noopener">Visualizing quaternions</a></p><p>视频:</p><ul><li><a href="https://www.bilibili.com/video/BV1SW411y7W1?from=search&amp;seid=14501682529068922403" target="_blank" rel="noopener">四元数的可视化</a></li><li><a href="https://www.bilibili.com/video/BV1Lt411U7og?from=search&amp;seid=14501682529068922403" target="_blank" rel="noopener">四元数和三维转动，可互动的探索式视频（请看链接）</a></li></ul><h2 id="重点参考"><a href="#重点参考" class="headerlink" title="重点参考"></a>重点参考</h2><p>文章内有对四元数的详细介绍,四元数插值部分也讲得非常清楚</p><div class="row">    <embed src="quaternion.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%85%83%E6%95%B8" target="_blank" rel="noopener">四元数</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E5%BE%B7%E9%87%8C%E6%A0%BC%E6%97%8B%E8%BD%AC%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">罗德里格旋转公式</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=2650216092&amp;idx=1&amp;sn=7f99fc0bc70293a3c5719ca864ece4ca&amp;chksm=f1fb2db0c68ca4a674760ce8c8bda1c3c4c6bcace1def7bb6eb132bc14c916669fb736377296&amp;mpshare=1&amp;scene=23&amp;srcid=1125JzIIUJ2yJphL2dc91Yay&amp;sharer_sharetime=1606291414222&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51#rd" target="_blank" rel="noopener">干货 | 欧拉角，四元数？晕头转向的空间姿态表示法（下篇）</a></li><li><a href="https://krasjet.github.io/quaternion/" target="_blank" rel="noopener">quaternion by krasjet</a></li><li><a href="https://www.qiujiawei.com/understanding-quaternions/" target="_blank" rel="noopener">Understanding Quaternions 中文翻译《理解四元数》</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四元数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆运动学</title>
      <link href="2020/11/23/%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
      <url>2020/11/23/%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="逆运动学"><a href="#逆运动学" class="headerlink" title="逆运动学"></a>逆运动学</h1><p>逆运动学是已知机械臂末端的位姿求解关节角度的过程,通常有两种方法:</p><ul><li>解析法.使用代数或者几何法求解,可以求得当前位姿对应的所有解,需要选择离当前位置最近的关节角解缺点是机械臂需要满足一定的要求.</li><li>优化法.把问题转化为优化问题(很多问题都可以转化为优化问题),缺点是只能获得一个解,耗时相对较长</li></ul><h2 id="优化法"><a href="#优化法" class="headerlink" title="优化法"></a>优化法</h2><ol><li><p>雅克比逆(牛顿-拉夫森法, Newton-Raphson Method)<br> 逆运动学就是求解方程$f(\theta)=0$,目标是找到关节坐标满足$x_{d}-f\left(\theta_{d}\right)=0$,使用泰勒展开,即</p><script type="math/tex; mode=display"> x_{d}=f\left(\theta_{d}\right)=f\left(\theta_{0}\right)+\underbrace{\left.\frac{\partial f}{\partial \theta}\right|_{\theta_{0}}}_{J\left(\theta_{0}\right)} \underbrace{\left(\theta_{d}-\theta_{0}\right)}_{\Delta \theta}+\mathrm{h.o.t.}</script><p> 只保留泰勒级数到第一项,简化为</p><script type="math/tex; mode=display"> J\left(\theta_{0}\right) \Delta \theta=x_{d}-f\left(\theta_{0}\right)</script><p> 如果作则雅克比矩阵可逆,则有</p><script type="math/tex; mode=display"> \Delta \theta=J^{-1}\left(\theta_{0}\right)\left(x_{d}-f\left(\theta_{0}\right)\right)</script><p> 如果正向运行学$f(\theta)$是$\theta$的线性函数,泰勒级数没有高阶项,新的估计值$\theta_{1}=\theta_{0}+\Delta \theta$精确满足运动学方程,<br> 相反,如果运动学是非线性函数,那么新的估计值将会更接近真实值,迭代不断重复,直到$\theta$收敛,如下图所示<br> <img src="/2020/11/23/逆运动学/niudun.png" alt="牛顿-拉夫森法"><br> 如果逆运动学存在多组解,则只会找到最近的解.在实际使用中,矩阵求逆很耗费计算资源,通常是借鉴$A x=b$,使用矩阵的LU分解.</p><p> 如果雅克比不可逆,则使用矩阵伪逆(Moore-Penrose),伪逆求法:</p><ul><li>SVD分解, 然后求逆</li><li>行满秩,右逆 $J^{\dagger}=J^{T}\left(J J^{T}\right)^{-1}$</li><li><p>列满秩,左逆 $J^{\dagger}=\left(J^{T} J\right)^{-1} J^{T}$<br>使用伪逆得到的解不会精确满足方程,但从最小二乘的层面会尽可能接近这个条件,求线性方程组或者拟合的时候经常用到.伪逆推导就是求解</p><script type="math/tex; mode=display">\begin{array}{c}\min _{\dot{q}}\|\dot{q}\|^{2} \\\text {subject to } \dot{x}=J \dot{q}\end{array}</script><p>然后使用<strong>拉格朗日乘数法（Lagrange Multiplier）</strong> 变成</p><script type="math/tex; mode=display">\min _{\dot{q}} \frac{1}{2}\|\dot{q}\|^{2}+\lambda^{T}(\dot{x}-J \dot{q})</script><p>分别对两个变量求导等与0得到两个方程求解就得到了右伪逆.<br>顺带说一下雅克比的零空间(null space),把关节速度投影到”零空间内”,对末端运动没有影响,公式如下,可以参考我的另一篇文章<a href="/2020/02/19/雅克比矩阵零空间/" title="雅克比矩阵零空间">雅克比矩阵零空间</a>    </p><script type="math/tex; mode=display">\forall \dot{q}_{0}, J\left(I-J^{+} J\right) \dot{q}_{0}=0</script><p>上述方法只是针对机械臂的末端位置求解,如果增加姿态,则不能只是直接简单相减,使用雅克比我们可以先求出末端的线速度和角速度(物体的速度旋量)</p><p>首先计算相对物体坐标系的期望位形</p><script type="math/tex; mode=display">T_{b d}\left(\theta_{i}\right)=T_{s b}^{-1}\left(\theta_{i}\right) T_{s d}=T_{b s}\left(\theta_{i}\right) T_{s d}</script><p>其中b指代body,即当前末端位恣,d指代destination.然后使用矩阵对数求解旋量</p><script type="math/tex; mode=display">\left[\mathcal{V}_{b}\right]=\log T_{b d}\left(\theta_{i}\right)</script><p>然后迭代求解</p><script type="math/tex; mode=display">\theta_{i+1}=\theta_{i}+J_{b}^{\dagger}\left(\theta_{i}\right) \mathcal{V}_{b}</script><p>注意这里使用的是物体雅克比(Body Jacobian)和对应的物体运动旋量(Body Twist),如果使用空间雅克比和空间运动旋量需要转换一下,$\mathcal{V}_{s}=\left[\mathrm{Ad}_{T_{s b}}\right] \mathcal{V}_{b}$</p><p>雅克比逆的方法也可以理解从当前点到目标点的速度,然后用雅克比逆求解关节角速度,使用到下一个关节角度的叠加,<br>只是这种理解关节角度角度变化不能太大,否则雅克比不准(和关节构型有关,是变化的)</p></li></ul></li><li><p>雅克比转置(梯度下降法)<br> 逆解的目标是当前的位置距离目标位置尽可能近,转化为一个最小值问题</p><script type="math/tex; mode=display"> \min _{q} \frac{1}{2}\left\|x_{d}-x_{c}\right\|^{2}</script><p> 这里有系数只是为了求导后没有系数,不影响结果,将当前位置带入方程得</p><script type="math/tex; mode=display"> \min _{q} \frac{1}{2}\left\|x_{d}-f(q)\right\|^{2}</script><p> 这个时候可以使用梯度下降法,每一步都沿着下降最快的方向走,方向为梯度的反方向</p><script type="math/tex; mode=display"> \begin{aligned} \Delta q &=-\alpha \nabla\left(\frac{1}{2}\left\|x_{d}-f(q)\right\|^{2}\right) \\ &=\alpha\left(\left(x_{d}-x\right)^{T} \frac{\partial f(q)}{\partial q}\right)^{T} \\ &=\alpha J^{T}\left(x_{d}-x\right)=\alpha J^{T} \Delta x \end{aligned}</script><p> 其中$\alpha$是梯度下降法的一个系数,步长(step size)或这学习效率(learning rate).步长太大导致”走过头”甚至多绕弯路,<br> 最终迭代速度慢(甚至无法收敛),步长太小导致迭代速度太慢.</p><p> 雅克比转置方法不需要求逆,不过收敛速度反而慢一点,使用这个方法控制机械臂,离end effector较远的关节常常需要输出更大的扭矩。</p></li><li><p>阻尼最小二平方法(DLS, Damped Least Square)<br> 雅克比奇异导致关节速度过大,这显然是我们不希望看到的,现在也有很多避奇异的方法,DLS就是一种限制关节速度的方法,<br> 这时我们需要最小化的目标是</p><script type="math/tex; mode=display"> \|J \Delta \theta-\overrightarrow{\mathrm{e}}\|^{2}+\lambda^{2}\|\Delta \theta\|^{2}</script><p> 即把关节变化量放进最小化的目标函数,方程可等价于</p><script type="math/tex; mode=display"> \left\|\left(\begin{array}{c} J \\ \lambda I \end{array}\right) \Delta \theta-\left(\begin{array}{c} \overrightarrow{\mathrm{e}} \\ 0 \end{array}\right)\right\|</script><p> 借鉴线性方程组$A x=b$求解(伪逆)</p><script type="math/tex; mode=display"> \left(\begin{array}{c} J \\ \lambda I \end{array}\right)^{T}\left(\begin{array}{c} J \\ \lambda I \end{array}\right) \Delta \boldsymbol{\theta}=\left(\begin{array}{c} J \\ \lambda I \end{array}\right)^{T}\left(\begin{array}{l} \overrightarrow{\mathbf{e}} \\ \mathbf{0} \end{array}\right)</script><p> 进而得到</p><script type="math/tex; mode=display"> \left(J^{T} J+\lambda^{2} I\right) \Delta \boldsymbol{\theta}=J^{T} \overrightarrow{\mathbf{e}}</script><p> 由于左侧矩阵非奇异,则有</p><script type="math/tex; mode=display"> \Delta \boldsymbol{\theta}=\left(J^{T} J+\lambda^{2} I\right)^{-1} J^{T} \overrightarrow{\mathbf{e}}</script><p> 同时有$\left(J^{T} J+\lambda^{2} I\right)^{-1} J^{T}=J^{T}\left(J J^{T}+\lambda^{2} I\right)^{-1}$ 可以左右两侧同时乘$J^{T} J+\lambda^{2} I$<br> 则有</p><script type="math/tex; mode=display"> \Delta \boldsymbol{\theta}=J^{T}\left(J J^{T}+\lambda^{2} I\right)^{-1} \overrightarrow{\mathbf{e}}</script><p> 这就是DLS方法的迭代方程</p><p> 在编程实现中,通常是直接处理雅克比矩阵奇异值分解后对奇异值操作,这是等效的,首先奇异值分解</p><script type="math/tex; mode=display"> J=U D V^{T}</script><p> 然后化简得到</p><script type="math/tex; mode=display">{J^T}{\left( {J{J^T} + {\lambda ^2}I} \right)^{ - 1}} = V{D^T}{\left( {D{D^T} + {\lambda ^2}I} \right)^{ - 1}}{U^T} = VE{U^T}</script><p> 从这里可以看出E为对称矩阵,而且值为(雅克比矩阵svd分解后奇异值为$\sigma_$,求逆之后为倒数)</p><script type="math/tex; mode=display"> e_{i, i}=\frac{\sigma_{i}}{\sigma_{i}^{2}+\lambda^{2}}</script><p> 所以一种比较简单的方式就是直接处理奇异值,<a href="https://github.com/CentroEPiaggio/kuka-lwr/blob/master/lwr_controllers/include/utils/pseudo_inversion.h" target="_blank" rel="noopener">kuka-lwr</a>就是这样处理的</p></li></ol><p>总结: DLS方法可以看成是两种方法的结合,<br>当$\lambda$很小时,根据SVD分解奇异值可以看出来就是牛顿-拉夫森法(矩阵逆),<br>当$\lambda$很大, $J{J^T}$为对阵矩阵,可以分解为<script type="math/tex">J{J^T} = Q\Lambda {Q^T}</script>,由于分解后的特征值相对$\lambda$ 很小,则最后直接成为下式,其实就是前面的梯度法  </p><script type="math/tex; mode=display">\Delta \boldsymbol{\theta}=J^{T}\left(\lambda^{2} \right)^{-1} \overrightarrow{\mathbf{e}}</script><p>逆解参考Samuel R. Buss的Introduction to Inverse Kinematics with Jacobian Transpose, Pseudoinverse and Damped Least Squares methods<br><div class="row">    <embed src="iksurvey.pdf" width="100%" height="550" type="application/pdf"></div></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>使用<a href="https://bitbucket.org/traclabs/trac_ik/src/master/" target="_blank" rel="noopener">trac-ik</a>求解motoman逆运动学的时候容易求到距离当前关节较远的位置<br>通过判断关节角度差来决定是否需要重新逆解即可</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402440005&amp;idx=1&amp;sn=6fd6f3dab8d2a5859100b8d432b4bc57&amp;chksm=7bf084694c870d7fc3cda2050951d2464f2bf8d3a3fe53a5793b8c4853e7907f64d2f61c252e&amp;mpshare=1&amp;scene=1&amp;srcid=1122bJnzmLv4PJaTr2MAtKsn&amp;sharer_sharetime=1606046642935&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=Ax1h1mIg50AJIvm3eB93%2F%2B8%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd" target="_blank" rel="noopener">干货 | “逆运动学”——从操作空间到关节空间（上篇）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402732106&amp;idx=1&amp;sn=49072186c7c893a6e09801f11e8ffd78&amp;chksm=740d0f66437a86702b645b1e9a79d809e9c5feae53bdbbf39a81932c163c5bf1643f0da193ae&amp;mpshare=1&amp;scene=1&amp;srcid=1122mBBiPmcRYHdHnoQr8iQ9&amp;sharer_sharetime=1606046650729&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=A1IFM3SHYDEbQt4WRKd233w%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd" target="_blank" rel="noopener">干货 | “逆运动学”——从操作空间到关节空间（下篇）</a></li><li><a href="http://hades.mech.northwestern.edu/index.php/Modern_Robotics" target="_blank" rel="noopener">MODERN ROBOTICS MECHANICS, PLANNING, AND CONTROL</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="2020/11/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/11/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="c-使用线程注意事项"><a href="#c-使用线程注意事项" class="headerlink" title="c++ 使用线程注意事项"></a>c++ 使用线程注意事项</h2><ol><li><p>限定符避免编译器优化<br> <a href="/2019/10/06/c++记录/" title="参考限定符部分">参考限定符部分</a>,不过没用好像也没什么问题   </p><pre><code> // 线程操作对象需要增加volatile,避免编译器优化(直接从变量地址读取而不是上次的值) volatile int val;</code></pre></li><li><p>锁同一个对象需要同一个锁,如全局变量或类对象        </p><pre><code> std::mutex mut   //构造函数加锁,析构函数解锁,避免程序意外终止结果没来得及解锁 lock_guard&lt;mutex&gt; lock (mut);  </code></pre></li><li><p>sleep_for,线程休眠指定时间后唤醒,不过由于线程调度等原因,实际睡眠时间可能更长</p><pre><code> std::this_thread::sleep_for( std::chrono::milliseconds(2000) );        </code></pre></li><li>线程销毁 <ul><li>thread::join()调用后,调用它的线程会被block，直到线程的执行被完成.如果一个c++线程对象销毁时还可以join就会抛出异常</li><li>thread::detach()函数被调用后,执行的线程从线程对象中被分离,已不再被一个线程对象所表达—这是两个独立的事情.</li><li>执行到析构函数时要么join,要么detach线程</li></ul></li></ol><h2 id="c-11院子操作-atomic-operation"><a href="#c-11院子操作-atomic-operation" class="headerlink" title="c++11院子操作(atomic operation)"></a>c++11院子操作(atomic operation)</h2><p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义.确保同一时刻只有唯一的线程对指定的全局资源进行访问,<br>类似互斥锁,但是原子操作更加接近底层，因而效率更高.</p><p>使用非常简单,只是类型不一样,且不用加锁就能保证线程访问的安全性,类型包括atomic_bool,atomic_int等常用简单类型</p><pre><code>#include &lt;atomic&gt;      atomic_long total(0);total++;</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/fawdlstty/article/details/49492197?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf" target="_blank" rel="noopener">C++11：多线程与锁</a></li><li><a href="https://blog.csdn.net/fengbingchun/article/details/73521630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf" target="_blank" rel="noopener">C++11中std::mutex的使用</a></li><li><a href="https://blog.csdn.net/xibeichengf/article/details/71173543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">thread中join和detach的区别</a></li><li><a href="https://blog.csdn.net/yockie/article/details/8838686?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control" target="_blank" rel="noopener">C++11中的原子操作（atomic operation）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑小问题记录</title>
      <link href="2020/11/12/%E7%94%B5%E8%84%91%E5%B0%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>2020/11/12/%E7%94%B5%E8%84%91%E5%B0%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>电脑的问题有时候是硬件问题,需要细心排查</p><h2 id="电脑无法正常启动"><a href="#电脑无法正常启动" class="headerlink" title="电脑无法正常启动"></a>电脑无法正常启动</h2><ol><li>电脑上电之后马上自己断电,如此反复<br> 把线头紧一下,内存条拿下来擦一下就可以了,可能是线头送了或者之前打扫的时候灰尘太大影响的主板</li><li>双系统电脑开机之后没有ubuntu grub启动项选项,直接进入ubuntu,进系统前显示屏一直没有信号输入<br> 电脑显示器插头松了.另一种可能是需要把内存条拿下来擦一下    <h2 id="中文输入法下使用英文标点"><a href="#中文输入法下使用英文标点" class="headerlink" title="中文输入法下使用英文标点"></a>中文输入法下使用英文标点</h2><code>Ctrl + ,</code>进行切换,需要在语言栏未打开的情况下才能使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 装饰器</title>
      <link href="2020/11/10/python-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>2020/11/10/python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="python装饰器-property"><a href="#python装饰器-property" class="headerlink" title="python装饰器 @property"></a>python装饰器 @property</h2><p>绑定属性时有时候我们只想只读类的属性值,或者有限制的更改类的属性值</p><p>可以使用get()和set()方法,但是略显复杂,使用装饰器可以更简单,python内置的@property装饰器负责把方法变成属性调用</p><pre><code>class Student(object):    @property    def score(self):        return self._score    @score.setter    def score(self, value):        if not isinstance(value, int):            raise ValueError(&#39;score must be an integer!&#39;)        if value &lt; 0 or value &gt; 100:            raise ValueError(&#39;score must between 0 ~ 100!&#39;)        self._score = value</code></pre><p>把getter方法变成属性时只需要@property,@score.setter负责把setter方法变成属性赋值,对于只读属性可只定义getter方法</p><p><strong>这种方式对于单个值设置只读是很有帮助的,但是对于列表,numpy数组等就无法防止对列表中单个数据的修改</strong></p><pre><code>import numpy as npclass testnp(object):    def __init__(self):        self._data = [1, 1]        self._npdata = np.asarray([1, 1, 1])    @property    def data(self):        return self._data    @property    def npdata(self):        return self._npdata        # return self.get_readOnly_view(self._npdata)    def get_readOnly_view(self, data):        res = data.view()        res.flags.writeable = False        return restest = testnp()print &quot;初始值:&quot;print test.dataprint test.npdatadata = test.datanpdata = test.npdata# 测试赋值前# 可以单独修改# test.data[0] = 10 # 原始数据修改 [10,1]# test.npdata[0] = 10     # 原始数据修改 [10, 1, 1]# 整体无法修改# test.data = [10,10] # AttributeError: can&#39;t set attribute# test.npdata = np.asarray([10, 10, 10])  # AttributeError: can&#39;t set attribute# 测试赋值后# 新变量整体操作不影响# data = [10,10]  # 原始数据保留# npdata = np.asarray([10, 10, 10])   # 原始数据保留# 新变量操作元素改变数据# data[0] = 10    #   原始数据修改 [10, 1]# npdata[0] = 10  # 原始数据修改 [10, 1, 1]</code></pre><p>使用@property</p><ul><li>只作用于赋值前的数据.如果赋值给新变量,那么新变量可以再赋值,不过不会影响到原始数据(新变量是一个新的对象)</li><li>只能作用于整个变量.对于列表和<code>numpy</code>数组,能够防止对于整体数据的修改,如果对列表中元素修改会修改到原始数据,不论是赋值前后</li></ul><p>从装饰器也可以看出来返回的值就是对象数据本身,虽然整体值不让改,但是元素的值可以改;</p><ul><li>list:python中一般会使用写时复制功能,所以新变量赋值再更改之后就是另一个变量,和之前的数据没有关系,变量名可以看成是指向了另一块内存区域</li><li>numpy数组:numpy自身优化了效率,需要调用<code>numpy.copy</code>才能深度拷贝成为另一个变量,否则即使赋值给变量,对新变量的操作还是对同一块内存区域的操作</li></ul><p>解决办法:</p><ul><li>列表可以返回一个拷贝<code>return self._data[:]</code>,如果数据量大是很不利的</li><li>numpy可以返回一个只读属性的view,见上面测试代码.为了利用@property把获取数据的方法变成属性使用,可以直接把返回的只读numpy数组使用@property再次封装.这样整体和单独变量都不会被修改,如果需要修改,那么深度拷贝返回值即可<code>numpy.copy(test.npdata)</code></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208" target="_blank" rel="noopener">廖雪峰python教程 使用@property</a></li><li><a href="https://stackoverflow.com/questions/60810463/is-this-a-correct-way-to-create-a-read-only-view-of-a-numpy-array" target="_blank" rel="noopener">Is this a correct way to create a read-only view of a numpy array?</a>          </li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决conda和ros库不兼容问题,libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用</title>
      <link href="2020/11/10/%E8%A7%A3%E5%86%B3libapr-1-so-0%EF%BC%9A%E5%AF%B9%E2%80%98uuid-generate-UUID-1-0%E2%80%99%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8/"/>
      <url>2020/11/10/%E8%A7%A3%E5%86%B3libapr-1-so-0%EF%BC%9A%E5%AF%B9%E2%80%98uuid-generate-UUID-1-0%E2%80%99%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="主要是因为conda和ros兼容的问题"><a href="#主要是因为conda和ros兼容的问题" class="headerlink" title="主要是因为conda和ros兼容的问题"></a>主要是因为conda和ros兼容的问题</h2><ol><li>问题关键词： <strong>libapr-1.so.0</strong>和<strong>uuid</strong></li><li><p>locate第一个关键词: </p><pre><code> $ locate libapr-1.so.0  /usr/lib/x86_64-linux-gnu/libapr-1.so.0 /usr/lib/x86_64-linux-gnu/libapr-1.so.0.5.2</code></pre></li><li><p>查看该库对第二个关键字的依赖包位置</p><pre><code> $ ldd /usr/lib/x86_64-linux-gnu/libapr-1.so.0 |grep uuid libuuid.so.1 =&gt; /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f3588aab000)</code></pre><p> 这是ros系统所使用的库依赖，报错是因为anaconda中也有libuuid.so.1,但是版本不同</p></li><li><p>locate第二个关键词</p><pre><code>$ locate libuuid.so.1  /home/yang/anaconda3/envs/franka/lib/libuuid.so.1/home/yang/anaconda3/envs/franka/lib/libuuid.so.1.0.0/home/yang/anaconda3/lib/libuuid.so.1/home/yang/anaconda3/lib/libuuid.so.1.0.0/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1.0.0/lib/i386-linux-gnu/libuuid.so.1/lib/i386-linux-gnu/libuuid.so.1.3.0/lib/x86_64-linux-gnu/libuuid.so.1/lib/x86_64-linux-gnu/libuuid.so.1.3.0/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1.3.0/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1.3.0</code></pre><p>可以看出,ros使用的是/lib/x86_64-linux-gnu/libuuid.so.1,由于anaconda的存在,我使用的库是/home/yang/anaconda3/envs/franka/lib/libuuid.so.1<br>对比两个版本</p><pre><code>$ ll /lib/x86_64-linux-gnu/ |grep uuid   lrwxrwxrwx  1 root root      16 Jan 27  2020 libuuid.so.1 -&gt; libuuid.so.1.3.0-rw-r--r--  1 root root   18976 Jan 27  2020 libuuid.so.1.3.0$ ll ~/anaconda3/envs/franka/lib |grep uuid-rw-rw-r--  3 yang yang    26398 Jan 12  2018 libuuid.a-rwxrwxr-x  1 yang yang      978 Nov  9 16:05 libuuid.la*lrwxrwxrwx  1 yang yang       16 Nov  9 16:05 libuuid.so -&gt; libuuid.so.1.0.0*lrwxrwxrwx  1 root root       34 Nov 10 09:35 libuuid.so.1 -&gt; libuuid.so.1.0.0*-rwxrwxr-x  3 yang yang    18472 Jan 12  2018 libuuid.so.1.0.0*可以看出系统库是1.3.0版本,anaconda使用的是1.0.0版本</code></pre></li><li><p>把anaconda库链接到系统的库(比较简单,可以先把anaconda对应库备份一下,也可以考虑升级anaconda对应库,但是我没找到)</p><pre><code> mv ~/anaconda3/envs/franka/lib/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1.back        sudo ln -s /lib/x86_64-linux-gnu/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1</code></pre></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/qq_36013249/article/details/103311001" target="_blank" rel="noopener">解决libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="2020/05/22/python%E5%9F%BA%E7%A1%80/"/>
      <url>2020/05/22/python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>很多简单模块容易忘,在此记录一下</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><ol><li><p>查看帮助文档</p><pre><code> import os # 主要有3中类型 ,也可以针对具体函数 dir(os) help(os)  os.__doc__</code></pre></li><li><p>查看变量内存地址</p><pre><code> # 需要注意有时候变量的复制是浅拷贝,地址相同的 # 使用pybullet获取机械臂位置就是这样,机械臂运动之后地址才变了 print(id(object))</code></pre></li><li><p>查看当前路径</p><pre><code> import os os.getcwd()</code></pre></li><li><p>copy模块</p><ul><li><p>注意python具有即时复制的功能</p><pre><code>  a = 1  b = a  print(id(a), id(b))  b = 2  print(id(a), id(b))</code></pre></li><li><p>有些模块如numpy没有特别设置不会深拷贝,通常配合copy.deepcopy()</p></li></ul></li><li><p>python3中@<br> 矩阵乘法</p><pre><code> Op    Precedence/associativity    Methods @    Same as *                    __matmul__, __rmatmul__ @=    n/a                            __imatmul__</code></pre></li><li><p>numpy数组交换行列</p><pre><code> a = np.array([[1,2,3],[2,3,4],[1,6,5], [9,3,4]]) a[:,[1,0,2]]</code></pre></li></ol><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><ol><li><p>常用安装命令</p><pre><code> # 安装 conda环境可以使用conda install xxx pip install package_name pip install package_name==package_version # 更新 pip install -U package_name # 显示模块的信息 pip show package_name # 查看对应包简单信息 pip list |grep package_name # 卸载建议这种方式,不会会有残留文件(针对pip install -e .) pip uninstall package_name  </code></pre></li><li><p>pip install -e . VS python setup.py install</p><pre><code> Editable   pip                    setup.py yes        pip install -e .       python setup.py develop     no         pip install .          python setup.py install   </code></pre></li></ol><ul><li><p>可编辑模式安装(develop,可以在当前文件基础上修改)</p><p>这种方式会在site-packages下创建一个文件指向项目目录,并不会复制对应代码;<br>在项目根目录(setup.py所在)会生成egg-info 文件夹包含这个包的主要信息;<br>查看sys.path会发现里面多了一个项目根目录的路径</p><pre><code>  pip install -e /path/to/your/setup.py  # 项目根目录                  </code></pre></li><li>install 这种方式会在site-packages生成egg文件,里面包含对应的函数和模块,无法修改</li></ul><h2 id="python2和3用法区别"><a href="#python2和3用法区别" class="headerlink" title="python2和3用法区别"></a>python2和3用法区别</h2><ol><li><p>super函数<br> super() 函数是用于调用父类(超类)的一个方法。<br> super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p><p> python3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx :</p><pre><code> #!/usr/bin/python # -*- coding: UTF-8 -*- class A(object):   # Python2.x 记得继承 object     def add(self, x):          y = x+1          print(y) class B(A):     def add(self, x):         super(B, self).add(x)  # python3 直接super().add(x) b = B() b.add(2)  # 3</code></pre></li></ol><h2 id="pybullet-结合-ROS"><a href="#pybullet-结合-ROS" class="headerlink" title="pybullet 结合 ROS"></a>pybullet 结合 ROS</h2><p>将pybullet中获取的图像通过变换获得对应的点云图<br><div class="row">    <embed src="OPGL_pointcloud.pdf" width="100%" height="550" type="application/pdf"></div></p><ol><li><p>Image  numpy array to sensor_msgs/Image</p><pre><code> from cv_bridge import CvBridge import numpy as np from sensor_msgs.msg import Image # 确保能都找到正确的opencv2的位置 import sys sys.path.remove(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;) import cv2 rgb_np_arr, depth_np_arr, seg_mask_np_arr, point_cloud = self.camera.get_camera_frame() bridge = CvBridge() image_message = bridge.cv2_to_imgmsg(rgb_np_arr[:, :, [2, 1, 0, 3]].astype(&#39;uint8&#39;))  # default bgra8</code></pre></li><li><p>Pointcloud numpy to sensor_msgs/PointCloud2     </p><pre><code> import ros_numpy import numpy as np from sensor_msgs.msg import PointCloud2, PointField number = point_cloud.shape[0] * point_cloud.shape[1] point_cloud_arr = point_cloud.reshape([number, 3]) data = np.zeros(number, dtype=[     (&#39;x&#39;, np.float32),     (&#39;y&#39;, np.float32),     (&#39;z&#39;, np.float32) ]) data[&#39;x&#39;] = point_cloud_arr[:, 0] data[&#39;y&#39;] = point_cloud_arr[:, 1] data[&#39;z&#39;] = point_cloud_arr[:, 2] cloud_msg = ros_numpy.msgify(PointCloud2, data) cloud_msg.header.frame_id = &quot;map&quot;</code></pre></li><li><p>pointcloud from image deepth<br> reshape 默认是按行排列, 按列需要order=’F’</p><p> 矩阵求逆 np.linalg.inv(x)</p><p> 矩阵乘积 np.matmul(a, b)</p><pre><code> stepX = 10 stepY = 10 pointCloud = np.empty([np.int(self.img_height/stepY), np.int(self.img_width/stepX), 4]) projectionMatrix = np.asarray(self.projection_matrix).reshape([4,4],order=&#39;F&#39;) viewMatrix = np.asarray(view_matrix).reshape([4,4],order=&#39;F&#39;) tran_pix_world = np.linalg.inv(np.matmul(projectionMatrix, viewMatrix)) for h in range(0, self.img_height, stepY):     for w in range(0, self.img_width, stepX):         x = (2*w - self.img_width)/self.img_width         y = -(2*h - self.img_height)/self.img_height  # be careful！ deepth and its corresponding position         z = 2*depth_np_arr[h,w] - 1         pixPos = np.asarray([x, y, z, 1])         position = np.matmul(tran_pix_world, pixPos)         pointCloud[np.int(h/stepY),np.int(w/stepX),:] = position / position[3]          </code></pre></li></ol><h2 id="python代码中查看当前编译器版本"><a href="#python代码中查看当前编译器版本" class="headerlink" title="python代码中查看当前编译器版本"></a>python代码中查看当前编译器版本</h2><pre><code>import sysprint(sys.version)  # python2      </code></pre><h2 id="脚本中指定编译器"><a href="#脚本中指定编译器" class="headerlink" title="脚本中指定编译器"></a>脚本中指定编译器</h2><p>相当于写死了python3路径;</p><pre><code>#!/usr/bin/python3</code></pre><p>去环境设置寻找python3目录,推荐这种写法</p><pre><code>#!/usr/bin/env python3      </code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>使用正则表达式可以非常方便从文本中获取到需要的值, 相对matlab速度更快<br><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式 - 教程</a>, 验证正则表达式是否正确参考<a href="https://c.runoob.com/front-end/854/" target="_blank" rel="noopener">正则表达式在线测试|菜鸟工具</a></p><ul><li>字符匹配<br>普通字符：普通字符按照字面意义进行匹配，例如匹配字母 “a” 将匹配到文本中的 “a” 字符。<br>元字符：元字符具有特殊的含义，例如 \d 匹配任意数字字符，\w 匹配任意字母数字字符，. 匹配任意字符（除了换行符）等。</li><li>量词<br>*：匹配前面的模式零次或多次。<br>+：匹配前面的模式一次或多次。<br>?：匹配前面的模式零次或一次。<br>{n}：匹配前面的模式恰好 n 次。<br>{n,}：匹配前面的模式至少 n 次。<br>{n,m}：匹配前面的模式至少 n 次且不超过 m 次。</li><li>字符类<br>[ ]：匹配括号内的任意一个字符。例如，[abc] 匹配字符 “a”、”b” 或 “c”。<br><sup><a href="#fn_ " id="reffn_ "> </a></sup>：匹配除了括号内的字符以外的任意一个字符。例如，<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup> 匹配除了字符 “a”、”b” 或 “c” 以外的任意字符。</li><li>边界匹配<br>^：匹配字符串的开头。<br>$：匹配字符串的结尾。<br>\b：匹配单词边界。<br>\B：匹配非单词边界。</li><li>分组和捕获<br>( )：用于分组和捕获子表达式。<br>(?: )：用于分组但不捕获子表达式。</li><li>特殊字符<br>\：转义字符，用于匹配特殊字符本身。<br>.：匹配任意字符（除了换行符）。<br>|：用于指定多个模式的选择。</li></ul><p>常用正则:</p><ul><li>数字匹配并分组<code>(-?\d+\.?\d*(?:e[+-]?\d+)?)</code></li><li>匹配所有<code>[\s\S]</code>, <code>\s</code>匹配所有空白符, 包括换行, <code>\S</code>非空白符，不包括换行</li><li><p>匹配一个数字字符<code>\d</code>, 等价于 [0-9]</p><pre><code>  # 匹配带字符`UT: a0: 数字`  import re  a0Reg = re.compile(r&quot;[\s\S]+UT: a0: (-?\d+\.?\d*(?:e[+-]?\d+)?)&quot;)  line = &quot;fhdsa UT: a0: 1.23&quot;  m = a0Reg.match(line)  if m:          print(float(m.group(i + 1))) # 索引0 对应整个字符串, 1开始为分组内部的内容</code></pre></li></ul><p>python中可视化可以用<code>matplot</code>, 如果想要更好的绘图可以使用matlab, 这是只是用python提取数据, 存放在txt可以用<code>numpy</code>, 先创建list, 然后转换numpy格式</p><pre><code>class GetData:def __int__(self):    self.version = 1.0@staticmethoddef get_joint(data_file, data_reg, num_jnt):    &quot;&quot;&quot;Get several data from file with regular expression    Used for analyze data    Args:        data_file (str): The path of the file to read        data_reg (Pattern object): regular expression pattern        num_jnt (int): number of data    Returns:        t_arr: time in millisecode        jnt_arr: data array    &quot;&quot;&quot;    data_list = []    t = []    with open(data_file, &quot;rt&quot;, encoding=&#39;utf-8&#39;) as fp:        for line in fp:            m = data_reg.match(line)            if m:                datime = line[1:27]                time_array = datetime.datetime.strptime(datime, &quot;%Y-%m-%d %H:%M:%S.%f&quot;)                time_stamp = time.mktime(time_array.timetuple()) + time_array.microsecond / 1e6                t.append(time_stamp)                data_line = []                for i in range(num_jnt):                    data_line.extend([float(m.group(i + 1))])                data_list.append(data_line)    data_arr = np.asarray(data_list)    t_arr = np.asarray(t)    return t_arr, data_arr@staticmethoddef get_matrix(data_file, data_text, data_reg, num_row, num_col):    jnt_list = []    t = []    with open(data_file, &quot;rt&quot;, encoding=&#39;utf-8&#39;) as fp:        for line in fp:            if data_text in line:                next_line = fp.readline()                m = data_reg.match(next_line)                if m:                    datime = line[12:27]                    t_tmp = datetime.datetime.strptime(datime, &quot;%H:%M:%S.%f&quot;)                    t.append(t_tmp)                    jnt = []                    for i in range(num_row * num_col):                        jnt.extend([float(m.group(i + 1))])                    jnt_list.append(jnt)    jnt_arr = np.asarray(jnt_list)    return t, jnt_arr</code></pre><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><p>好的函数注释能够快速确认该如何使用, 特别时对于阅读老代码是非常有用的<br>参考<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="noopener">Google 开源项目风格指南</a></p><ul><li>google推荐  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def func(path, field_storage, temporary):</span><br><span class="line">    &apos;&apos;&apos;基本描述</span><br><span class="line"></span><br><span class="line">    详细描述</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        path (str): The path of the file to wrap</span><br><span class="line">        field_storage (FileStorage): The :class:`FileStorage` instance to wrap</span><br><span class="line">        temporary (bool): Whether or not to delete the file when the File instance is destructed</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        BufferedFileStorage: A buffered writable file descriptor</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li></ul><p>也可以通过库函数跳转到定义, 参考官方的注释方式</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>ImportError: cannot import name ‘PackageFinder’</p><pre><code> curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py &amp;&amp; python get-pip.py</code></pre></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.jb51.cc/python/241778.html" target="_blank" rel="noopener">在virtualenv中设置：<code>pip install -e .</code> vs <code>python setup.py install</code></a></li><li><a href="https://www.jianshu.com/p/9a54e9f3e059" target="_blank" rel="noopener">如何将自己的Python程序打包—setuptools详解</a></li><li><a href="https://blog.csdn.net/qq_35356840/article/details/88557912" target="_blank" rel="noopener">Python Numpy 如何交换两行和两列</a></li><li><a href="http://ksimek.github.io/2012/08/22/extrinsic/" target="_blank" rel="noopener">Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix</a></li><li><a href="https://zhuanlan.zhihu.com/p/73034007" target="_blank" rel="noopener">OpenGL投影矩阵(Projection Matrix)构造方法</a></li><li><a href="https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/" target="_blank" rel="noopener">OpenGL 101: Matrices - projection, view, model</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux + Qt5 + ROS配置Qwtplot3d</title>
      <link href="2020/05/12/Linux-Qt5-ROS%E9%85%8D%E7%BD%AEQwtplot3d/"/>
      <url>2020/05/12/Linux-Qt5-ROS%E9%85%8D%E7%BD%AEQwtplot3d/</url>
      
        <content type="html"><![CDATA[<p>qwtplot3D是一个Qt第三方库,在OpenGL基础上封装了一层可以用来三维绘图.</p><h2 id="Qt项目使用QwtPlot3d"><a href="#Qt项目使用QwtPlot3d" class="headerlink" title="　Qt项目使用QwtPlot3d"></a>　Qt项目使用QwtPlot3d</h2><ol><li>安装OpenGL(QwtPlot3d需要OpenGL作为基础)<br> 这一步网上很多教程,我之前装过,这里略过</li><li><p>下载QwtPlot3d压缩包两种选择,建议选a</p><p> a. 下载分支<a href="https://sourceforge.net/p/qwtplot3d/code/HEAD/tree/branches/multiple_curves_0_2_x/" target="_blank" rel="noopener">multiple_curves_0_2_x</a> 可以一个画面绘制多个图形</p><p> b. 下载<a href="https://sourceforge.net/projects/qwtplot3d/" target="_blank" rel="noopener">qwt-plot3d</a> <a href="https://blog.csdn.net/eastonwoo/article/details/37658141" target="_blank" rel="noopener">修改参考</a></p><p> 第一种方式顺利编译</p><p> 第二种方式,出现的问题 </p><pre><code> ‘gluErrorString’ was not declared in this scope err = gluErrorString(errcode);</code></pre><p> 解决方式</p><pre><code>    在include/qwt3d_openglhelper.h这个文件里添加 #include &lt;GL/glu.h&gt;    打开 qwtplot3d.pro , 在最前面输入下面这一句  LIBS += -lGLU            </code></pre></li><li><p>打开qwtplot3d.pro, 选择Release</p><p> 两种方式都可以编译后在编译文件夹找到4个libqwtplot3d.so*文件</p><p> 复制这四个文件到存放lib文件的目录,可以自己指定,我的是</p><pre><code> /opt/qt59/lib/x86_64-linux-gnu/qtcreator/</code></pre></li><li><p>打开qwtplot3d/examples/simpleplot/simpleplot.pro</p><pre><code> # 将第一句改为这二句 其实就是指定刚才生成的动态链接库的位置 # 其实把库文件放在原本指定的位置../../lib也可以编译成功 unix:LIBS += -lqwtplot3d -L../../lib unix:LIBS += -L/opt/qt59/lib/x86_64-linux-gnu/qtcreator/ -lqwtplot3d</code></pre><p> 其他项目使用需要生成的库文件.so 以及头文件 .h(qwtplot3d/include下),<br> simpleplot只用指定库是因为项目中指定了头文件位置</p><p> 运行程序如下<br> <img src="/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/simpleplot_mult.png" alt="simpleplot">    </p></li></ol><h2 id="ROS-CmakeLists-txt使用QwtPlot3d"><a href="#ROS-CmakeLists-txt使用QwtPlot3d" class="headerlink" title="ROS CmakeLists.txt使用QwtPlot3d"></a>ROS CmakeLists.txt使用QwtPlot3d</h2><pre><code># 把头文件拷贝到include/qwt 下并包含include_directories(${catkin_INCLUDE_DIRS}    include/qwt)# 寻找OpenGL 这是底层库find_package(Qt5 COMPONENTS Core Widgets OpenGL REQUIRED)# 设置库文件路径set(QT_LIBRARIES Qt5::Widgets Qt5::OpenGL)#added# 生成可执行程序并链接库add_executable(qwtdemo  src/traj_graph.cpp)target_link_libraries(qwtdemo ${QT_LIBRARIES} ${catkin_LIBRARIES}    qwtplot3d ) </code></pre><p><strong>特别注意:</strong></p><pre><code>file(GLOB_RECURSE QT_MOC RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} FOLLOW_SYMLINKS    include/qtgui/*.hpp include/qtgui/*.h    )        </code></pre><p>这一句如果直接使用<em>.h,则会在建立的包内匹配</em>h(include src…),b方式即使把提供头文件包含进来也没问题,<br>a方式出错 需要排除qwtplot3d提供的头文件 这里我新建了一个文件include/qwt</p><pre><code>#  a方式出错 error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;/home/yang/project/cam/test/build/qtgui/include/qwt/moc_qwt3d_surfaceplot.cpp:78: error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;</code></pre><p>注意到上面只处理了头文件包含,对于库文件有多种处理方式,库文件又分为静态库和动态库,可参考<a href="https://www.zhihu.com/question/20484931/answer/69553616" target="_blank" rel="noopener">Linux 中的动态链接库和静态链接库是干什么的？</a></p><ol><li><p>指定相对位置(推荐,成功率高)</p><pre><code> # 把库文件.so复制到项目内与src同级目录lib, 然后在CmakeLists.txt指定相对位置 LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/lib)   ## 添加动态库路径</code></pre></li><li><p>指定绝对位置</p><pre><code> # CmakeLists.txt 添加库文件路径(之前存放的路径) LINK_DIRECTORIES(/opt/qt59/lib/x86_64-linux-gnu/qtcreator/)   ## 添加动态库路径</code></pre></li><li><p>添加路径到变量LD_LIBRARY_PATH</p><pre><code> # ~/.bashrc 下添加下面这句,然后重开终端启动qtcreator 但是我没成功 export LD_LIBRARY_PATH=/opt/qt59/lib/x86_64-linux-gnu/qtcreator:${LD_LIBRARY_PATH}</code></pre></li><li><p>修改/etc/ld.so.conf,添加路径,运行sudo ldconfig命令</p><p> 这是一个系统动态链接库路径配置文件,我尝试过/etc/ld.so.conf 添加库文件路径<br> 以及在指定的目录下增加XXX.conf都不行,最后是直接拷贝到包含的一个目录下成功的(/usr/lib/x86_64-linux-gnu/)</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/qq_41800188/article/details/87891586" target="_blank" rel="noopener">Ubuntu Linux 16.04 LTS + Qt5.5.1 + Qwtplot3d配置安装</a></li><li><a href="https://blog.csdn.net/EastonWoo/article/details/37658141" target="_blank" rel="noopener">QT5 r 加入qwtplot3d 三维库</a></li><li><a href="https://blog.csdn.net/zxh2075/article/details/54629318?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">linux下添加动态链接库路径的方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="2020/04/21/mysql/"/>
      <url>2020/04/21/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><pre><code>-- 显示数据库show databases;-- 显示表格show tables;-- 创建一个名称为car的数据库。create database car;-- 使用数据库 caruse car;-- 删除数据库car-- drop database car;-- 显示表格内容select * from tableName;-- 创建表create table brand (id int primary key auto_increment, factory varchar(255), name varchar(255), price int, sum int, sell int, last int);-- 删除brand表-- drop table brand;-- 插入数据insert into brand(factory,name,price,sum, sell, last) values(&#39;一汽大众&#39;, &#39;奥迪A6&#39;, 36, 50, 8, 42);-- 更新数据-- update brand set sell=5 , last=70 where factory=&#39;上海大众&#39; and name=&#39;桑塔纳&#39;;</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="无法插入中文"><a href="#无法插入中文" class="headerlink" title="无法插入中文"></a>无法插入中文</h3><ol><li><p>临时修改</p><ul><li><p>查看客户端 编码字符 状态</p><pre><code>  status;  // Client characterset: utf8  #Server characterset 和 Db     characterset 都是utf8</code></pre></li><li><p>查看所有编码字符</p><pre><code>  show variables like&#39;%char%&#39;;</code></pre></li><li><p>修改设置(gbk 也是支持中文)            </p><pre><code>  set character_set_database=utf8;  set character_set_server=utf8;</code></pre></li></ul></li><li><p>永久修改修改配置文件</p><ul><li><p>针对未创建的表</p><pre><code>  sudo vim /etc/mysql/my.cnf  # 末尾添加  [client]  default-character-set=utf8  [mysqld]  character-set-server=utf8</code></pre><p>  /etc/init.d/mysql restart  #重启服务</p></li><li><p>针对已经创建的表</p><pre><code>  alter table `tablename` convert to character set utf8;</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根轨迹</title>
      <link href="2020/03/28/%E6%A0%B9%E8%BD%A8%E8%BF%B9/"/>
      <url>2020/03/28/%E6%A0%B9%E8%BD%A8%E8%BF%B9/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#根轨迹定义">根轨迹定义</a></li><li><a href="#根轨迹准则">根轨迹准则</a></li><li><a href="#应用">应用</a></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="根轨迹定义"><a href="#根轨迹定义" class="headerlink" title="根轨迹定义"></a>根轨迹定义</h2><p>一个基本的反馈系统传递函数为</p><script type="math/tex; mode=display">\frac{Y(s)}{R(s)}=\mathcal{T}(s)=\frac{D_{c}(s) G(s)}{1+D_{c}(s) G(s) H(s)}</script><p>极点为分母等于0时对应的根,换一种方式,求解根在K从0到无穷大对应的轨迹,<br>就可以得到不同K下系统的极点,从而得到系统的脉冲响应函数</p><script type="math/tex; mode=display">1+K L(s)=0 \text { where } L(s)=\frac{b(s)}{a(s)}</script><p><img src="/2020/03/28/根轨迹/close-loop.png" alt="close-loop"></p><p>根轨迹不局限于系统增益K,也可以求解相对于任何在特征方程中线性的参数的根轨迹</p><p>比如在求解K=1是不同c下的根轨迹</p><script type="math/tex; mode=display">1+G(s)=1+\frac{1}{s(s+c)}</script><script type="math/tex; mode=display">1+c \frac{s}{s^{2}+1}=0</script><h2 id="根轨迹准则"><a href="#根轨迹准则" class="headerlink" title="根轨迹准则"></a>根轨迹准则</h2><p>L(s)</p><ul><li>b(s) 极点个数为n 用x表示</li><li>a(s) 零点个数为m 用o表示</li></ul><ol><li><p>n条根轨迹从L(s)极点出发,m条轨迹终止于L(s)零点;<br>n&gt;m,则有n-m条根轨迹从极点指向无穷,反之m-n条轨迹从无穷指向零点</p><p> 从根轨迹公式 $a(s)+K b(s)=0$ 可以得出K=0时,a(s)=0,即为L(s)的极点,K趋向于无穷时,b(s)=0,为L(s)的零点</p></li><li><p>根轨迹在实轴上从左往右奇数点左边有根轨迹.</p><p> 根轨迹方程的一种表示 $L(s)=-\frac{1}{K}$ 从复数相位看左边的相位=右边的相位=180°</p><ul><li>用$\psi_{i}$表示零点对应项在复平面上任意一点对应的相角度,即零点指向对应点构成向量的角度</li><li><p>用$\phi_{i}$表示极点对应项在复平面上任意一点对应的相角度,即极点点指向对应点构成向量的角度</p><script type="math/tex; mode=display">\sum \psi_{i}-\sum \phi_{i}=180^{\circ}+360^{\circ}(l-1)</script><p>为保证相位不难理解实轴上根轨迹需要在奇数点左边<br><img src="/2020/03/28/根轨迹/measureing phase.png" alt="example"></p></li></ul></li><li><p>对于很大的s和K,n-m条根轨迹的渐近线为从实轴上中心点 $s=\alpha$出发的射线,射线角度 $\phi_{l}$ </p><script type="math/tex; mode=display">\begin{aligned} \phi_{l} &=\frac{180^{\circ}+360^{\circ}(l-1)}{n-m}, \quad l=1,2, \ldots, n-m \\ \alpha &=\frac{\sum p_{i}-\sum z_{i}}{n-m} \end{aligned}</script><p> 当K很大时变换根轨迹方程</p><script type="math/tex; mode=display">1+K \frac{\Pi_{i=1}^{m}\left(s-z_{i}\right)}{(s-\alpha)^{n-m} \Pi_{i=1}^{m}\left(s-z_{i}\right)}=0</script><p> 从而得到</p><script type="math/tex; mode=display">\begin{aligned} &(n-m) \alpha+\sum z_{i}=\sum p_{i}\\ &\alpha=\frac{\sum p_{i}-\sum z_{i}}{n-m} \end{aligned}</script></li><li><p>一或多个极点从一个点离开的方向</p><script type="math/tex; mode=display">q \phi_{l, d e p}=\sum \psi_{i}-\sum \phi_{i}-180^{\circ}-360^{\circ}(l-1)</script><p> 可以用一个很靠近极点的点来推导角度,到达零点的方向也可类似推导</p><script type="math/tex; mode=display">q \psi_{l, a r r}=\sum \phi_{i}-\sum \psi_{i}+180^{\circ}+360^{\circ}(l-1)</script><p> 可用于靠近虚轴方向的判断,看是否忘复平面左边走</p></li><li><p>同一个点可以有q个根,从点离开的方向</p><script type="math/tex; mode=display">\frac{180^{\circ}+360^{\circ}(l-1)}{q}</script></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><script type="math/tex; mode=display">H(s)=\frac{s-z}{s-p}</script><ul><li>超前补偿器:|z|&lt;|p|</li><li>滞后补偿器:|p|&lt;|z|<br>可以看补偿器的伯德图来理解</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>Feedback Control of Dynamic Systems by Gene F. Franklin</li><li><a href="https://www.bilibili.com/video/BV1JJ411i7ph?t=498" target="_blank" rel="noopener">DR_CAN自动控制原理</a>         </li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 根轨迹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2020/03/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2020/03/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>常用的排序算法:冒泡,归并,快排</p><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>快速排序采用分治策略:找到一个轴点,比它小的放在左侧,大的放在右侧,不断划分</p><p>最坏情况O(n^2),大多数情况下平均效率O(nlogn),常系数比其它的小,实际的平均运行时间比同类的更少.<br>但是快速排序无法保证数据之间的相对次序(主要针对重复元素)</p><pre><code>#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;// [lo hi) sorttemplate &lt;typename T&gt;int partition(T arr[], int lo, int hi){    int index = lo + rand()%(hi-lo);//    swap arr[lo] and arr[index]    T mi = arr[index];    arr[index] = arr[lo];    arr[lo] = mi;    hi--;  // point to last data    // &lt; 勤于交换 相对于&lt;=更好,能较为均衡划分     while(lo &lt; hi){        while(lo &lt; hi){            if(mi &lt; arr[hi]){ hi--; }            else{arr[lo++] = arr[hi]; break;}        }        while(lo &lt; hi){            if(arr[lo] &lt; mi){lo++; }            else{arr[hi--] = arr[lo]; break;}        }    }    arr[lo] = mi;    return lo;}template &lt;typename T&gt;void quicksort(T arr[], int length, int lo, int hi){//    judge the input    if(hi &lt; lo || hi - lo &gt; length|| arr == NULL){        cout &lt;&lt; &quot;invalid input&quot;;        exit(1);    }    if(hi-lo &lt; 2)        return;//    partition and sort    int middle = partition(arr, lo, hi);    quicksort(arr, length, lo, middle);    quicksort(arr, length, middle+1, hi);}// overridetemplate &lt;typename T&gt;void quicksort(T arr[], int length){    quicksort(arr, length, 0, length);}</code></pre><h1 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h1><p>从中间分成两部分,然后分别排序,最后归并<br>每一层递归消耗时间稳定在$\Theta(n)$,共有$\Theta\left(\log _{2} n\right)$层,共计$\Theta(\text {n} 1 \text {ogn})$</p><pre><code>template &lt;typename T&gt;void merge(T arr[], int lo, int middle, int hi){    int len_l = middle - lo;    int len_r = hi - middle;    T *temp_left = new T[len_l];    for(int i=0;i&lt;len_l;i++){temp_left[i] = arr[lo+i]; }    T *temp_right = arr + middle;    T *glo_arr = arr + lo;    for(int i=0,j=0,k=0;j&lt; len_l || k &lt; len_r;){        if(j &lt; len_l &amp;&amp; (temp_left[j] &lt;= temp_right[k] || k == len_r)){glo_arr[i++] = temp_left[j++];}        if(k &lt; len_r &amp;&amp; (temp_right[k] &lt; temp_left[j] || j == len_l)){glo_arr[i++] = temp_right[k++];}    }    delete [] temp_left;}template &lt;typename T&gt;void mergesort(T arr[], int length, int lo, int hi){//    judge the input    if(hi-lo &gt; length || hi&lt;lo){        cout&lt;&lt; &quot;invalid input&quot;;        exit(1);    }    if(hi - lo &lt; 2)        return;    int middle = (lo + hi)&gt;&gt;1;    mergesort(arr, length, lo, middle);    mergesort(arr, length, middle, hi);    merge(arr, lo, middle, hi);}template &lt;typename T&gt;void mergesort(T arr[], int length){    mergesort(arr, length, 0, length);}     </code></pre><h1 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h1><p>复杂度O(n^2)</p><pre><code>template &lt;typename T&gt;void bubblesort(T arr[], int length){    for(int i=0;i&lt;length-1;i++){        for(int j=0;j&lt;length-1-i;j++){            if(arr[j] &gt; arr[j+1]){                T temp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = temp;            }        }    }}  </code></pre>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解补码</title>
      <link href="2020/03/13/%E7%90%86%E8%A7%A3%E8%A1%A5%E7%A0%81/"/>
      <url>2020/03/13/%E7%90%86%E8%A7%A3%E8%A1%A5%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>这里取8位有符号数来说明</p><h1 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码,反码,补码"></a>原码,反码,补码</h1><p>这里针对有符号数</p><ul><li>原码:最高位表示符号,整数为0,负数为1,其余部分为数绝对值的二进制表示.如-3 表示为1000 0011</li><li>反码:正数反码为本身,负数,保留符号位,其余位取反</li><li>补码:整数补码为本身,负数,保留符号位,其余为取反加1</li><li>形式值:将符号位作为实际含义,1000 0001 原码表示-1 ,形式值表示2^7+2^0 (考虑符号位) </li></ul><p>计算机的加减乘除是最基本的运算,需要设计得尽可能简单,设计的初衷就是想用一种编码实现加减 <strong>a-b = a+(-b)</strong></p><ol><li><p>原码,人脑最容易理解的方式,但是计算机不同,需要额外处理符号位是很麻烦,<br> 1-1=0000 0001(原)+1000 0001(原)=1000 0010(原)=-2 这是不符号运算的</p></li><li><p>反码,原码1000 0110 的补码是1111 1001.可以看出负数的补码(形式值)与自身的绝对值之和为1111 1111 (255)<br>这里只看数值运算,结合整数的补码就是本身,反码的实质就是取余运算 %1111 1111 (mod 255),理解可结合下面<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E7%A0%81" target="_blank" rel="noopener">这张图</a><br> <img src="/2020/03/13/理解补码/fanma.png" alt="反码"><br> 还有一种理解:不看符号位,对于数值部分取反之后和之前和恒为0111 1111,可以看出是对数值部分取余即%0111 1111(%127).</p><p> 反码存在的问题,</p><ol><li>0 的表示有两种,浪费了一个二进制数 0000 0000(原) 1000 0000(原) 反码分别是0000 0000 和 1111 1111</li><li>无法保证减法运算,如 2-1 = 0000 0010(反) + 1111 1110(反) = 0000 0000(原)<br> 1-1 之类是对的1111 1111(反) = 1000 0000(原) </li></ol></li><li><p>补码,同反码一样,不过多了+1,相当于%256 (1000 0000)</p><ol><li>引入加1之后巧妙解决了0的表示问题,0000 0000(原) 和1000 0000(原)对应的补码都是0000 0000(补)<br> 那现在用1000 0000表示什么数呢? 1000 0000(补) + 0000 0001(补)=1000 0001(补)=1111 1111(原)=-127<br> 所以用1000 0000表示-128,没有对应的原码和反码 所以8为有符号二进制为[-128,127]</li><li><p>保证了减法运算,这里用了<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98" target="_blank" rel="noopener">同余的性质</a>  </p><script type="math/tex; mode=display">\left.\begin{array}{l}a \equiv b(\bmod m) \\c \equiv d(\bmod m)\end{array}\right\} \Rightarrow\left\{\begin{array}{c}a \pm c \equiv b \pm d(\bmod m) \\a c \equiv b d(\bmod m)\end{array}\right.</script><p> 如(2-1)%256 = (2 + (-1))%256 = (2+(-1%256)) %256 = 1 最后一步%256 是通过高位溢出达到的</p></li><li><p>用补码的第二种解释%128,解释为什么负数补码的补码就是负数本身,因为保留了符号位,数值部分两次取余%128%128为本身<br> 如给定1000 0001(原),则取补码为1111 1111(补),再求补码1000 0001</p></li><li><p>但是为什么反码不对呢?反码也是取余,主要是因为反码0的两种表示方式值相差1</p><p> 0+1 = 1000 0000(原) + 0000 0001(原)=1111 1111(反)+0000 0001(反)=0000 0000=0<br> 即0+1=0;这才是问题所在,0的两种表达方式导致了溢出处理有问题</p></li></ol></li></ol><h1 id="补码性质"><a href="#补码性质" class="headerlink" title="补码性质"></a>补码性质</h1><p>写这里是因为一道剑指offer的题解,很精妙:<a href="https://www.nowcoder.com/profile/9536154/codeBookDetail?submissionId=17465787" target="_blank" rel="noopener">输入一个整数,输出该数二进制表示中1的个数.其中负数用补码表示.</a></p><p>首先需要说明的是数在计算机中存储是用补码的形式</p><p>针对a-1的问题</p><ol><li>首先看正数,a-1 就是a的二进制从右至左第一位1借位,对应位变0,右边的都变成1 如0000 1100 - 1 = 0000 1011</li><li>负数,还是要用到同余 (a-1)%256 = ((a%256)-1)%256 如(-5-1)%256 等式左边=250=右边=1111 1010-1=1111 1001 同正数一样<br><strong>总的来说补码表示的数可以直接按照正数的加减法来运算(包括-1),这也是补码设计的初衷:统一加减法</strong>即计算机运算直接用补码的形式值来计算,输出转换为原码就可以了</li></ol><p>注意:负数右移或者/2左边补1,最小的数是-1(即1111 1111),所以在求一个数有多少位1时不要动这个数,而是移动取的位,比如a &amp; b,是把b左移,而不是把原数右移</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/zl10086111/article/details/80907428" target="_blank" rel="noopener">原码、反码、补码知识详细讲解（此作者是我找到的讲的最细最明白的一个）</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8" target="_blank" rel="noopener">维基百科:补码</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98" target="_blank" rel="noopener">同余</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ string与c风格字符串</title>
      <link href="2020/02/22/c-string%E4%B8%8Ec%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/02/22/c-string%E4%B8%8Ec%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组，大小比单词多一个</p><p>不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。</p><p>建议使用c++ string</p><pre><code>char greeting[6] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;}; char greeting[] = &quot;Hello&quot;;  </code></pre><h3 id="c-操作c风格字符串"><a href="#c-操作c风格字符串" class="headerlink" title="c++操作c风格字符串"></a>c++操作c风格字符串</h3><p>复制,连接,查找,比较,<strong>需要#include \<cstring\></cstring\></strong></p><p><strong>strlen(s1)获得的长度不包含空字符’\0’,string类的length()也是一样,</strong></p><pre><code>#include &lt;cstring&gt;  strcpy(s1, s2);   //复制字符串 s2 到字符串 s1strcat(s1, s2);     //连接字符串 s2 到字符串 s1 的末尾strlen(s1);         //返回字符串 s1 的长度 不包含空字符&#39;\0&#39;strcmp(s1, s2);     //如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0strchr(s1, ch);     //返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置strstr(s1, s2);     //返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置</code></pre><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>c++ 支持上述所有操作,并增加了功能</p><pre><code> append() -- 在字符串的末尾添加字符 直接用str1+str2也可以 find() -- 在字符串中查找字符串 insert() -- 插入字符 length() -- 返回字符串的长度 不包含空字符&#39;\0&#39; replace() -- 替换字符串 substr() -- 返回某个子字符串 ...</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>常量字符串不能修改<br> <strong>p指向常量字符串(位于常量存储区),内容不能修改</strong>    </p><pre><code> // p a存放在栈区,&quot;string&quot;字面值存放在常量区 char *p = &quot;string&quot;; //可以访问单个字符p[2] 不能直接更改p[2] = &#39;I&#39; char a[] = &quot;string&quot;; //这里字符数组会把&quot;string&quot;拷贝到栈区,可以直接更改a[2] = &#39;I&#39; </code></pre><p> 一、程序的内存分配</p><ul><li>栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量值等；</li><li>堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统OS回收。注意它与数据结构中的堆是两回事，<strong>分配方式倒是类似于链表</strong>； （malloc,new,free,delete）</li><li>全局区(静态区 static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放；</li><li>文字常量区：常量字符串就是放在这里，程序结束后由系统释放；</li><li><p>程序代码区：存放函数体的二进制代码。</p><p>栈区系统分配,速度快,但是程序员无法控制;堆区用起来方便,但是速度慢,容易产生内存碎片</p></li></ul></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/Castiellee929/article/details/88628617" target="_blank" rel="noopener">char *p = “abcdefg”； 常量字符串”abcdefg”位于静态存储区，通过p不能修改该字符串常量</a>    </li><li><a href="https://blog.csdn.net/dongfanglanyi/article/details/81386752?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">char *p = “abcd”; 和 char a[] = “abcd”的区别</a>    </li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅克比矩阵零空间</title>
      <link href="2020/02/19/%E9%9B%85%E5%85%8B%E6%AF%94%E7%9F%A9%E9%98%B5%E9%9B%B6%E7%A9%BA%E9%97%B4/"/>
      <url>2020/02/19/%E9%9B%85%E5%85%8B%E6%AF%94%E7%9F%A9%E9%98%B5%E9%9B%B6%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>先来看广义逆阵</p><h1 id="广义逆阵"><a href="#广义逆阵" class="headerlink" title="广义逆阵"></a>广义逆阵</h1><p>广义逆也称为伪逆（pseudoinverse），有些时候，伪逆特指摩尔－彭若斯广义逆(M-P逆)。</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>彭若斯条件</p><script type="math/tex; mode=display">\begin{aligned}&A A^{\mathrm{g}} A=A\\&A^{\mathrm{g}} A A^{\mathrm{g}}=A^{g}\\&\left(A A^{\mathrm{g}}\right)^{\mathrm{T}}=A A^{\mathrm{g}}\\&\left(A^{\mathrm{g}} A\right)^{\mathrm{T}}=A^{\mathrm{g}} A\end{aligned}</script><p>若<script type="math/tex">{A^{\rm{g}}}</script>满足条件1,则为A的广义逆阵;满足条件1和2,则为A的广义反身逆阵;<br>4个条件都满足则为摩尔-彭若斯逆(M-P逆)</p><p>除此之外还有其他广义逆阵包括左侧逆阵,右侧逆阵等</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>求解线性方程组  </p><script type="math/tex; mode=display">\eqalign{  & Ax = b  \cr   & x = {A^{\rm{g}}}b + \left[ {I - {A^{\rm{g}}}A} \right]w \cr}</script><h2 id="M-P逆"><a href="#M-P逆" class="headerlink" title="M-P逆"></a>M-P逆</h2><p>任意矩阵都存在M-P逆,且唯一,是应用最广泛的一种逆矩阵</p><p>计算方法</p><ol><li><p>满秩分解</p><script type="math/tex; mode=display"> \begin{aligned} \mathbf{A}=\mathbf{B C}, \mathbf{B} \in \mathbf{C}^{n \times r}, \mathbf{C} \in \mathbf{C}^{r \times n}, & \operatorname{rank}(\mathbf{B})=\operatorname{rank}(\mathbf{C})=r \\ \mathbf{A}^{+}=\mathbf{C}^{\mathrm{H}}\left(\mathbf{C} \mathbf{C}^{\mathrm{H}}\right)^{-1}\left(\mathbf{B}^{\mathrm{H}} \mathbf{B}\right)^{-1} \mathbf{B}^{\mathrm{H}} \end{aligned}</script></li><li><p>奇异值分解svd</p><script type="math/tex; mode=display"> \begin{aligned} &A=U\left(\begin{array}{ll} {\Delta} & {0} \\ {0} & {0} \end{array}\right) V^{H}\\ &A^{+}=V\left(\begin{array}{cc} {\Delta^{-1}} & {0} \\ {0} & {0} \end{array}\right)^{\mathrm{H}} U^{H} \end{aligned}</script></li></ol><h1 id="雅克比矩阵零空间"><a href="#雅克比矩阵零空间" class="headerlink" title="雅克比矩阵零空间"></a>雅克比矩阵零空间</h1><p>雅克比矩阵是关节空间到笛卡尔空间(机械臂末端)的映射,求解方程得</p><script type="math/tex; mode=display">\matrix{   {\delta x = J\delta q} \hfill  \cr    {\delta q = {J^\# }\delta x + \left[ {I - {J^\# }J} \right]\delta {q_0}} \hfill  \cr  }</script><p>其中<script type="math/tex">{J^\# }</script>为J的伪逆矩阵,从这里可以看出对于冗余机械臂(此时雅克比矩阵具有零空间)<br>可以在保证末端位置不变的情况下关节运动</p><h2 id="冗余机械臂关节空间力矩"><a href="#冗余机械臂关节空间力矩" class="headerlink" title="冗余机械臂关节空间力矩"></a>冗余机械臂关节空间力矩</h2><p>推导过程在pdf已经很详细了,这里摘取结论,资料出自<a href="https://cs.stanford.edu/groups/manips/teaching/cs327a/" target="_blank" rel="noopener">Advanced Robotic Manipulation</a><br><img src="/2020/02/19/雅克比矩阵零空间/redundancy.png" alt="冗余机械臂关节空间和任务空间"><br><img src="/2020/02/19/雅克比矩阵零空间/velocity_force.png" alt="velocity_force"></p><p>这里需要注意的是关节空间线性方程组求解时选择不同伪逆会有不同结果在pdf里面推导出来的逆是为了保证在对应零空间施加关节力矩不会影响操作空间加速度</p><p><strong>不清楚的是<a href="https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/src/cartesian_impedance_example_controller.cpp" target="_blank" rel="noopener">franka笛卡尔空间阻抗控制</a><br>以及这里使用的<a href="https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/include/franka_example_controllers/pseudo_inversion.h" target="_blank" rel="noopener">矩阵求伪逆</a>多了一个参数的作用</strong></p><div class="row">    <embed src="Redundancy-19.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://zh.wikipedia.org/zh/%E5%B9%BF%E4%B9%89%E9%80%86%E9%98%B5#cite_note-James-4" target="_blank" rel="noopener">维基百科:广义逆阵</a></li><li><a href="https://blog.csdn.net/u013528298/article/details/80558315" target="_blank" rel="noopener">雅克比矩阵零空间</a></li><li><a href="https://studywolf.wordpress.com/2013/09/17/robot-control-5-controlling-in-the-null-space/" target="_blank" rel="noopener">ROBOT CONTROL PART 5: CONTROLLING IN THE NULL SPACE</a></li><li><a href="https://blog.csdn.net/u013528298/article/details/79952949" target="_blank" rel="noopener">冗余机器人以及雅克比伪逆矩阵</a></li><li><a href="https://cs.stanford.edu/groups/manips/teaching/cs327a/" target="_blank" rel="noopener">斯坦福课程:Advanced Robotic Manipulation</a></li><li>书籍:矩阵论 杨明 刘先忠 华中科技大学出版社</li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雅克比矩阵 </tag>
            
            <tag> 伪逆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构c++</title>
      <link href="2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c/"/>
      <url>2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c/</url>
      
        <content type="html"><![CDATA[<p>常用复杂度:常数,对数,线性,多项式,指数.<br>O(1),O(logn)、O(sqrt(n))、O(n)、O(nlogn)、O(n^2)、和O(2^n)</p><h1 id="输入规模"><a href="#输入规模" class="headerlink" title="输入规模"></a>输入规模</h1><p>对算法复杂度的界定都是相对于输入规模而言.</p><p>严格地说,所谓待计算问题的输入规模,应严格定义为“用以描述输入所需的空间规模”。</p><ol><li><p>例子</p><pre><code> int countOnes(unsigned int n) { //统计整数n癿二迕刢展开中数位1癿总数：O(logn)     int ones = 0; //计数器复位     while (0 &lt; n) { //在n缩减至0乀前，反复地         ones += (1 &amp; n); //检查最低位，若为1则计数         n &gt;&gt;= 1; //右秱一位     }     return ones; //迒回计数 } //等效亍glibc癿内置函数int __builtin_popcount (unsigned int n)</code></pre><p> 现对于n本身数值来说,复杂度为log(n);相对于n的二进制展开的宽度$r=1+\left\lfloor\log _{2} n\right\rfloor$(向下取整),则复杂度为O(r)</p><p> 这里选择后一种表达方式O(r),前一种称为伪对数复杂度        </p></li></ol><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>Fibonacci数:线性递归</p><pre><code>__int64 fib(int n, __int64&amp; prev) { //计算Fibonacci数列第n顷(线性逑弻版):入口形式fib(n, prev)    if (0 == n) //若刡达逑弻基,则        { prev = 1; return 0; } //直接叏值:fib(-1) = 1, fib(0) = 0        else { //否则        __int64 prevPrev; prev = fib(n - 1, prevPrev); //逑弻计算前两顷        return prevPrev + prev; //其和即为正解      }} //用辅劣发量记弽前一顷,迒回数列癿弼前顷,O(n)</code></pre><p>原二分递归版本中对应于fib(n - 2)的另一次递归,在这里被省略掉了。其对应<br>的解答,可借助形式参数的机制,通过变量prevPrev“调阅”此前的记录直接获得。</p><p>更高效的方式是迭代,这里注意对已经计算出来的变量进行调阅的方式</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/about?jwt_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvd25lciI6Im5ld194dWV0YW5neCIsInVzZXJfaWQiOjEwODMzMjMzfQ.wmH12o6YjppbHX4TzGdkpjfJHPmG4xSjHlZUBenKAOM&amp;owner=new_xuetangx" target="_blank" rel="noopener">数据结构(c++语言版)第三版_邓俊辉</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ #pragma once</title>
      <link href="2020/02/05/c-pragma-once/"/>
      <url>2020/02/05/c-pragma-once/</url>
      
        <content type="html"><![CDATA[<p>在C/C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式</p><ol><li><p>#ifndef指令防止代码块重复引用</p><pre><code> #ifndef _CODE_BLOCK #define _CODE_BLOCK // code #endif// _CODE_BLOCK </code></pre><p> 保证同一份文件不会被包含两次，也能够保证不同文件完全相同的内容不会被包含两次<br> <strong>(编译时需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，#ifndef会使得编译时间相对较长)</strong></p></li><li><p>#pragma once指令，在想要保护的文件开头写入</p><pre><code> #pragma once   </code></pre><p> 只能针对一个文件(物理上的一个文件,而不是指内容相同的两个文件),不能针对一个头文件中的一段代码.<br> 如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。</p><p> 不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度较快</p></li></ol><p>总结: #ifndef更加灵活，兼容性好，#pragma once操作简单，效率高。         </p>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT坐标系统 </title>
      <link href="2020/02/03/QT%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/02/03/QT%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>QPaintDevice、QPaintEngine和QPainter是 Qt 绘制系统的三个核心类</p><p>坐标系统，也就是QPaintDevice上面的坐标。默认坐标系统位于设备的左上角，也就是坐标原点 (0, 0)。x 轴方向向右；y 轴方向向下。在基于像素的设备上（比如显示器），坐标的默认单位是像素，在打印机上则是点（1/72 英寸）.</p><p>为了避免获取不到真实的坐标值,建议使用QRectF.这个类的两个函数QRectF::right()和QRectF::bottom()是正确的。</p><p>QPainter是一个状态机.QPainter提供了内置的函数：save()和restore()。save()就是保存下当前状态；restore()则恢复上一次保存的结果。这两个函数必须成对出现：QPainter使用栈来保存数据，每一次save()，将当前状态压入栈顶，restore()则弹出栈顶进行恢复.</p><h1 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h1><p>QPainter:逻辑坐标 QPaintDevice:物理坐标</p><p>QPainter,window代表窗口坐标,viewport代表物理坐标,这两个是映射关系(坐标scale)</p><p>setWindow() 设置窗口,实际绘制窗口;<br>setViewport() 设置物理绘制区域</p><p><strong>QPainter使用的都是逻辑坐标,注意和物理坐标的对应关系</strong></p><p><img src="/2020/02/03/QT坐标系统/coordinate.png" alt="坐标变换关系"></p><p>QPainter传入的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）.</p><p>整个回执流程可以看成直接在设置的setWindow()里面绘制,可能需要平移旋转绘制坐标系,所得图像经过物理坐标和窗口坐标的缩放比例进行缩放得到</p><pre><code>painter.translate(400, 0); // 绘制用坐标系向右平移 400px</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://www.devbean.net/2012/11/qt-study-road-2-coordinate-system/" target="_blank" rel="noopener">坐标系统</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT事件</title>
      <link href="2020/02/01/QT%E4%BA%8B%E4%BB%B6/"/>
      <url>2020/02/01/QT%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Qt 的事件是整个 Qt 框架的核心机制之一</p><p>包括很多事件:鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等.</p><p>每个事件都对应一个处理函数 mouseEvent(),keyPressEvent()…</p><p>如此多的事件处理函数,必定有个地方对其分发 event()</p><h1 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h1><p><strong>当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！</strong></p><p>Qt 的事件对象有两个函数：accept()和ignore().一般很少使用</p><ol><li><p>如果一个事件处理函数调用了一个事件对象的accept()函数，<br>这个事件就不会被继续传播给其<strong>父组件</strong>；<br>如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者.</p></li><li><p>事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。这么一来，如果你自己实现事件处理函数，不调用QWidget的默认实现，<br>你就等于是接受了事件；如果你要忽略事件，只需调用QWidget的默认实现。</p></li></ol><p><strong>事件的传播是在组件层次上面的,而不是依靠类继承机制.</strong><br>(CustomButtonEx的事件传播给了父组件CustomWidget，而不是它的父类CustomButton)</p><h1 id="事件分发-event"><a href="#事件分发-event" class="headerlink" title="事件分发 event()"></a>事件分发 event()</h1><p>event()不负责事件处理,负责把事件分发给对应的事件处理函数(switch)</p><p>如果返回值为true,并且设置了accept(),那么qt认为这个事件已经处理完毕，<br>不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</p><p><strong>注意:在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播.</strong></p><p>继承类的event()函数处理之后对应其他事件需要调用父类的的event()函数,否则处理不了其他函数</p><h1 id="事件过滤器-eventFilter"><a href="#事件过滤器-eventFilter" class="headerlink" title="事件过滤器 eventFilter()"></a>事件过滤器 eventFilter()</h1><p>需要先安装对应的事件过滤器</p><pre><code>textEdit-&gt;installEventFilter(this);</code></pre><p>如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序.    </p><p>返回true则表示过滤,返回false表示不过滤.保险起见需要调用父类的eventFilter()</p><p><strong>注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，<br>Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃.</strong></p><p>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p><h1 id="事件处理顺序"><a href="#事件处理顺序" class="headerlink" title="事件处理顺序"></a>事件处理顺序</h1><ol><li>重写paintEvent()、mousePressEvent()等事件处理函数.这是最普通、最简单的形式，同时功能也最简单.</li><li>重写event()函数.event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数.</li><li>在特定对象上面安装事件过滤器.该过滤器仅过滤该对象接收到的事件.</li><li>在QCoreApplication::instance()上面安装事件过滤器.该过滤器将过滤所有对象的所有事件，<br>因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器.全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件.<br>全局过滤器有一个问题：只能用在主线程.</li><li>重写QCoreApplication::notify()函数.这是最强大的,和全局事件过滤器一样提供完全控制，<br>并且不受线程的限制.但是全局范围内只能有一个被使用(因为QCoreApplication是单例的).(一般不推荐用`)</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://www.devbean.net/2012/10/qt-study-road-2-event-summary/" target="_blank" rel="noopener">Qt 学习之路 2（22）：事件总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中argc argv理解</title>
      <link href="2020/01/22/c-%E4%B8%ADargc-argv%E7%90%86%E8%A7%A3/"/>
      <url>2020/01/22/c-%E4%B8%ADargc-argv%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>经常发现main函数这样写</p><pre><code>int main(int argc, char *argv[]){}</code></pre><p>先来看关于char的几种类型</p><h1 id="char-char-char-a-char-a"><a href="#char-char-char-a-char-a" class="headerlink" title="char * ,char ** ,char a[ ] ,char *a[ ]"></a><code>char * ,char ** ,char a[ ] ,char *a[ ]</code></h1><pre><code>char * : 指向字符的指针,本质上存储是一个地址,地址中对应的内容为charchar a[ ]:字符数组,数组里面每一个都是一个charchar** a:二级指针,a是一个指向char * 的指针,保存的是char*的地址char *a[ ] :[ ]的优先级高于*,所以首先是一个数组,数组里面元素为指向char *的指针</code></pre><p>c语言没有字符串,用字符数组代替;c语言中字符串常量本质上是一个地址</p><p><strong>C语言中操作字符串是通过它在内存中的存储单元的首地址进行的,这是字符串的终极本质</strong></p><pre><code>char *s;s = &quot;China&quot;;   //&quot;China&quot;字符串常量,存放的是C的地址</code></pre><p><strong>字符指针可以用 间接操作符 *取其内容,也可以用数组的下标形式 [],数组名也可以用 *操作,因为它本身表示一个地址</strong>    </p><h1 id="argc-argv"><a href="#argc-argv" class="headerlink" title="argc argv"></a>argc argv</h1><ol><li>argc为int:运行程序所带参数个数(包括程序本身名字,这点类似Linux下bash编程)</li><li>char* argv[]:存放内容包括 程序绝对路径+程序运行所带参数(全部转化为字符串)</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://blog.csdn.net/daiyutage/article/details/8604720" target="_blank" rel="noopener">深入 <code>char * ,char ** ,char a[ ] ,char *a[]</code> 内核</a></li><li>    </li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科式加速度</title>
      <link href="2020/01/13/%E7%A7%91%E5%BC%8F%E5%8A%A0%E9%80%9F%E5%BA%A6/"/>
      <url>2020/01/13/%E7%A7%91%E5%BC%8F%E5%8A%A0%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="科里奥利力"><a href="#科里奥利力" class="headerlink" title="科里奥利力"></a>科里奥利力</h1><p>科里奥利力（英语：Coriolis Force；简称科氏力）是一种惯性力,<br>是对旋转体系中进行直线运动的质点由于惯性相对于旋转体系产生的直线运动的偏移的一种描述.</p><p>绝对加速度计算公式=相对加速度+牵连加速度+科式加速度</p><ul><li>相对加速度:动点相对于动坐标系的加速度</li><li>牵连加速度:动坐标系上与动点重合的点在全局坐标系下的加速度</li><li>科式加速度:动点相对于动坐标系运动产生的加速度</li></ul><script type="math/tex; mode=display">\begin{aligned}\mathbf{a}_{n} &=\mathbf{a}_{r}+\mathbf{a}_{e}+\mathbf{a}_{c} \\&=\mathbf{a}_{r}+\boldsymbol{a} \times \mathbf{r}^{\prime}+\mathbf{\omega} \times\left(\mathbf{\omega} \times \mathbf{r}^{\prime}\right)+2 \mathbf{\omega} \times \mathbf{v}_{r}\end{aligned}</script><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>如图,动点沿着直杆运动,直杆本身旋转运动</p><script type="math/tex; mode=display">\begin{array}{ll}{a_{e}=\lim _{\Delta t \rightarrow 0} \frac{v_{M 1}-v_{e}}{\Delta t},} & {\frac{d v_{e}}{d t}=\lim _{\Delta t \rightarrow 0} \frac{v_{e}^{\prime}-v_{e}}{\Delta t}} \\{a_{r}=\lim _{\Delta t \rightarrow 0} \frac{v_{r 2}-v_{r}}{\Delta t},} & {\frac{d v_{r}}{d t}=\lim _{\Delta t \rightarrow 0} \frac{v_{r}^{\prime}-v_{r}}{\Delta t}}\end{array}</script><p>科式加速度产生</p><script type="math/tex; mode=display">\frac{d v_{r}}{d t}=a_{r}+\omega_{e} \times v_{r}, \quad \frac{d v_{e}}{d t}=a_{e}+\omega_{e} \times v_{r}</script><p><img src="/2020/01/13/科式加速度/科式加速度.png" alt="科式加速度"></p><h2 id="坐标轴微分计算"><a href="#坐标轴微分计算" class="headerlink" title="坐标轴微分计算"></a>坐标轴微分计算</h2><script type="math/tex; mode=display">\frac{d i^{\prime}}{d t}=\omega \times i^{\prime}, \quad \frac{d j^{\prime}}{d t}=\omega \times j^{\prime}, \quad \frac{d k^{\prime}}{d t}=\omega \times k^{\prime}</script><p>直接物理含义推导,把向量平移到起点和旋转轴重合,相当于就是位置的微分,为速度</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A5%E5%88%A9%E5%8A%9B" target="_blank" rel="noopener">科里奥利力</a></li><li>理论力学第8版 哈尔滨工业大学理论力学教研室编</li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加速度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu配置grub,指定默认内核</title>
      <link href="2020/01/09/ubuntu%E9%85%8D%E7%BD%AEgrub-%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%86%85%E6%A0%B8/"/>
      <url>2020/01/09/ubuntu%E9%85%8D%E7%BD%AEgrub-%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="Boot-Loader-grub2"><a href="#Boot-Loader-grub2" class="headerlink" title="Boot Loader: grub2"></a>Boot Loader: grub2</h1><p>BIOS 读完信息后,接下来就是会到第一个开机装置<br>的 MBR 去读取 boot loader.这个 boot loader 可以具有选单功能、直接加载核心文件以及控制权<br>移交的功能等，,系统必须要有 loader 才有办法加载该操作系统的核心就是了.</p><p>由于MBR是整个硬盘的第一个 sector 内的一个区块,充其量整个大小也才 446 bytes 而已.即使<br>是 GPT 也没有很大的扇区来储存 loader 的数据.所以分两个阶段</p><ul><li>执行 boot loader 主程序:在MBR或者boot sector,通常是最小主程序</li><li>主程序加载配置文件: 配置文件在/boot下,读取了文件系统定义数据之后就能够认识文件系统并读取该文件系统的核心</li></ul><h2 id="磁盘分区槽在grub2中的代号"><a href="#磁盘分区槽在grub2中的代号" class="headerlink" title="磁盘分区槽在grub2中的代号"></a>磁盘分区槽在grub2中的代号</h2><p>/boot/grub/grub.cfg  里面有set root=’hd1,gpt5’  指/boot目录挂载的区域</p><p>第一颗『搜寻到的硬盘』代号为：『(hd0)』，而该颗硬盘的第一号分区槽为『(hd0,1)』</p><ul><li>第一颗(MBR):     (hd0) (hd0,msdos1) (hd0,msdos2) (hd0,msdos3)….</li><li>第二颗(GPT):     (hd1) (hd1,gpt1) (hd1,gpt2) (hd1,gpt3)….</li><li>第三颗 (hd2):    (hd2,1) (hd2,2) (hd2,3)….</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>修改/etc/default/grub,然后使用updata-grub更新/boot/grub/grub.cfg</p><ol><li><p>数字</p><pre><code> GRUB_DEFAULT=&quot;1&gt; 0&quot;     #表示第二个选单子菜单的第一个  只使用&quot;0&quot; 表示第一个选单</code></pre></li><li><p>ID</p><pre><code> GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.15.0-74-generic&quot;</code></pre><p> 可通过一下命令查看目前系统选单</p><pre><code> awk -F\&#39; &#39;/menuentry |submenu / {print $1 $2}&#39; /boot/grub/grub.cfg  </code></pre></li><li><p>saved   </p><pre><code>  GRUB_DEFAULT=saved     </code></pre><p> 代表使用 grub2-set-default 来设定哪一个 menuentry 为默认值的意思。通常预设为 0 </p></li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>调用了update-grub之后/boot/grub/grub.cfg并没有改变,查看文件内部发现grub.cfg是需要使用grub-mkconfig</p><pre><code> sudo grub-mkconfig -o /boot/grub/grub.cfg   # 可以先备份一下配置文件</code></pre></li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://github.com/UniversalRobots/Universal_Robots_ROS_Driver/blob/master/ur_robot_driver/doc/real_time.md" target="_blank" rel="noopener">Setup GRUB to always boot the real-time kernel</a></li><li>鸟哥的Linux私房菜-基础学习篇(第四版)         </li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>惯性张量</title>
      <link href="2019/12/30/%E6%83%AF%E6%80%A7%E5%BC%A0%E9%87%8F/"/>
      <url>2019/12/30/%E6%83%AF%E6%80%A7%E5%BC%A0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>动量: 物体质量与速度的乘积, $ L = r \cdot p$. 牛顿第二定理: 物体运动状态(动量)发生改变,表示物体受力,作用力的大小为动量$\mathbf P$的时变率, $\mathbf{F}=\frac{\mathrm{d} \mathbf{p}}{\mathrm{d} t}$</li><li>角动量: 物体的位置矢量与动量的叉积, $r \times L$. 当物体的转动状态发生改变时，表示物体受到力矩作用，而力矩就等于角动量$\mathbf L$的时变率,$\boldsymbol{\tau}=\frac{d \mathbf{L}}{d t}$</li></ul><h1 id="欧拉运动定理"><a href="#欧拉运动定理" class="headerlink" title="欧拉运动定理"></a>欧拉运动定理</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89%E9%81%8B%E5%8B%95%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">欧拉运动定理（Euler’s laws of motion）</a>是<a href="https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">牛顿运动定律 Newton’s laws of motion</a>的延伸，可以应用于多粒子系统运动或刚体运动，描述多粒子系统运动或刚体的平移运动、旋转运动分别与其感受的力、力矩之间的关系。</p><p>欧拉第一运动定理如下,可根据牛顿第二定理推导多粒子</p><script type="math/tex; mode=display">\mathbf{F}^{(e x t)}=\frac{\mathrm{d} \mathbf{p}}{\mathrm{d} t}</script><p>欧拉第二运动定理</p><script type="math/tex; mode=display">\tau_{O}^{(e x t)}=\frac{\mathrm{d} \mathbf{L}_{O}}{\mathrm{~d} t}</script><h2 id="惯性张量"><a href="#惯性张量" class="headerlink" title="惯性张量"></a>惯性张量</h2><ol><li><p>惯性张量推导<br> 角动量为物体的位置矢量与动量的叉积</p><script type="math/tex; mode=display"> \begin{aligned} \mathbf{L} &=\mathbf{r} \times \mathbf{P} \\ &=\mathbf{r} \times(m \mathbf{v}) \\ &=-m \mathbf{r} \times(\mathbf{r} \times \mathbf{w}) \\ &=-m[\mathbf{r}]([\mathbf{r}] \mathbf{w}) \\ &=-m[\mathbf{r}]^{2} \mathbf{w} \end{aligned}</script><p> 则有物体的惯性张量计算公式</p><script type="math/tex; mode=display"> \mathbf{I}=-m[\mathbf{r}]^{2}=m\left[\begin{array}{ccc} r_{y}^{2}+r_{z}^{2} & -r_{x} r_{y} & -r_{x} r_{z} \\ -r_{x} r_{y} & r_{x}^{2}+r_{z}^{2} & -r_{y} r_{z} \\ -r_{x} r_{z} & -r_{y} r_{z} & r_{x}^{2}+r_{y}^{2} \end{array}\right]=\left[\begin{array}{ccc} I_{x x} & I_{x y} & I_{x z} \\ I_{y x} & I_{y y} & I_{y z} \\ I_{z x} & I_{z y} & I_{z z} \end{array}\right]</script><p> 其中<strong>转动惯量</strong></p><script type="math/tex; mode=display"> \begin{array}{l} I_{x x} \stackrel{\text { def }}{=} \int\left(y^{2}+z^{2}\right) d m \\ I_{y y} \stackrel{\text { def }}{=} \int\left(x^{2}+z^{2}\right) d m \\ I_{z z} \stackrel{\text { def }}{=} \int\left(x^{2}+y^{2}\right) d m \end{array}</script><p> 矩阵对角元素,<strong>惯性积</strong>,有时候惯性矩前面没有负号</p><script type="math/tex; mode=display"> \begin{array}{l} I_{x y}=I_{y x} \stackrel{\text { def }}{=}-\int x y d m \\ I_{x z}=I_{z x} \stackrel{\text { def }}{=}-\int x z d m \\ I_{y z}=I_{z y} \stackrel{\text { def }}{=}-\int y z d m \end{array}</script><p> 选取坐标系姿态使得惯性积为0,则对这个坐标系,惯性张量是对角型的,<br> 此坐标系称为惯性主轴,相应的惯性矩为主惯性矩</p></li><li><p>惯性张量惯性张量在不同坐标系下的变换<br> 可由能量守恒定理推导</p><script type="math/tex; mode=display"> \begin{aligned} \frac{1}{2} \omega_{c}^{T} \mathcal{I}_{c} \omega_{c} &=\frac{1}{2} \omega_{b}^{T} \mathcal{I}_{b} \omega_{b} \\ &=\frac{1}{2}\left(R_{b c} \omega_{c}\right)^{T} \mathcal{I}_{b}\left(R_{b c} \omega_{c}\right) \\ &=\frac{1}{2} \omega_{c}^{T}\left(R_{b c}^{T} \mathcal{I}_{b} R_{b c}\right) \omega_{c} \end{aligned}</script><p> 则有变换关系为</p><script type="math/tex; mode=display"> \mathcal{I}_{c}=R_{c b} \mathcal{I}_{b} R_{c b}^{T}</script><p> 如果坐标系$\{c\}$的轴线不与惯性主轴对齐,则可以将惯性张量矩阵对角分解得到对角矩阵$\mathcal{I}_b$,<strong>又$R_{c b}$的列向量为坐标系$\{b\}$坐标轴在坐标系坐标系$\{c\}$下的表示,此列向量又是$\mathcal{I}_b$的特征向量</strong></p></li><li><p>欧拉力矩平衡方程推导</p><script type="math/tex; mode=display"> \begin{aligned} \tau_{O}^{(e x t)}=\frac{\mathrm{d} \mathbf{L}_{O}}{\mathrm{~d} t}=\frac{\mathrm{d}(\mathbf{I} \mathbf{w})}{\mathrm{d} t}=\dot{\mathbf{I}} \mathbf{w}+\mathbf{I} \mathbf{w} \\ \dot{\mathbf{I}}_{a} \mathbf{w}=\frac{\mathrm{d}\left(\mathbf{I}_{a}\right)}{\mathrm{d} t} \mathbf{w}=\frac{\mathrm{d}\left(R_{a b} \mathbf{I}_{b} R_{a b}^{\mathrm{T}}\right)}{\mathrm{d} t} \mathbf{w} &=\left([\mathbf{w}] R_{a b} \mathbf{I}_{b} R_{a b}^{\mathrm{T}}+R_{a b} \mathbf{I}_{b}\left([\mathbf{w}] R_{a b}\right)^{\mathrm{T}}\right) \mathbf{w} \\ &=[\mathbf{w}] \mathbf{I}_{a} \mathbf{w}+\mathbf{I}_{a}[\mathbf{w}]^{\mathrm{T}} \mathbf{w} \\ &=\mathbf{w} \times \mathbf{I} \mathbf{w} \end{aligned}</script><p> 其中坐标系$a$为世界坐标系,坐标系$b$为刚体质心坐标系,惯量矩阵$\mathbf I$在质心坐标系中不变,导数为0,质心坐标系相对世界坐标系姿态的求导为质心坐标系的在世界坐标系下的角速度,可参考角速度的推导</p></li></ol><h3 id="惯性张量性质"><a href="#惯性张量性质" class="headerlink" title="惯性张量性质"></a>惯性张量性质</h3><ol><li>坐标系姿态改变时,若A与C共原点,则$^{A} \mathbf{I}=_{C}^{A} \mathbf{R}^{C} \mathbf{I}_{C}^{A} \mathbf{R}^{\mathrm{T}}$</li><li><p>惯性张量的特征值和特征向量分别是刚体对应的主惯性矩和惯性主轴</p><p> 可用平行移轴矢量形式和定义证明</p><script type="math/tex; mode=display"> ^{A} \mathbf{I}=^{C} \mathbf{I}+m\left(\mathbf{p}_{c}^{\mathrm{T}} \mathbf{p}_{c} \mathbf{I}_{3}-\mathbf{p}_{c} \mathbf{p}_{c}^{\mathrm{T}}\right)</script><p> 式中 $P_c$为行量 $[x, y, z]$</p></li></ol><h2 id="伪惯性矩阵"><a href="#伪惯性矩阵" class="headerlink" title="伪惯性矩阵"></a>伪惯性矩阵</h2><script type="math/tex; mode=display">\overline{\mathbf{I}}=\iiint_{V} \mathbf{r r}^{\mathrm{T}} \mathrm{d} m</script><p>式中$r$为行向量$[x, y, z, 1]$</p><script type="math/tex; mode=display">\overline{\mathbf{I}}=\iiint_{V}\left[\begin{array}{cccc}{x^{2}} & {x y} & {x z} & {x} \\{x y} & {y^{2}} & {y z} & {y} \\{x z} & {y z} & {z^{2}} & {z} \\{x} & {y} & {z} & {1}\end{array}\right] \mathrm{d} m</script><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%89%E5%8B%95%E6%85%A3%E9%87%8F#%E6%85%A3%E6%80%A7%E5%BC%B5%E9%87%8F" target="_blank" rel="noopener">转动惯量</a></li><li><a href="https://mp.weixin.qq.com/s/dkOxmuTzOasvOZoMTH2nQg" target="_blank" rel="noopener">干货 | 机械臂的动力学（一）：牛顿欧拉法</a></li><li><a href="https://www.cnblogs.com/21207-iHome/p/7765508.html" target="_blank" rel="noopener">刚体质量分布与牛顿-欧拉方程</a></li><li>机器人学 建模 控制与视觉 熊友伦 华中科技大学出版社</li><li><a href="http://hades.mech.northwestern.edu/index.php/Modern_Robotics" target="_blank" rel="noopener">Modern Robotics mechanics,planning,and control</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉氏变换</title>
      <link href="2019/12/27/%E6%8B%89%E6%B0%8F%E5%8F%98%E6%8D%A2/"/>
      <url>2019/12/27/%E6%8B%89%E6%B0%8F%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#卷积响应">卷积响应</a></li><li><a href="#传递函数">传递函数</a></li><li><a href="#频率响应frequency-response">频率响应frequency response</a></li><li><a href="#伯德图">伯德图</a><ul><li><a href="#典型函数频率响应">典型函数频率响应</a></li><li><a href="#典型函数的时域响应">典型函数的时域响应</a></li></ul></li><li><a href="#附加零极点的作用">附加零极点的作用</a></li><li><a href="#pid控制">PID控制</a></li><li><a href="#其他">其他</a></li><li><a href="#引用">引用</a></li><li><a href="#附录">附录</a><ul><li><a href="#拉式变换表">拉式变换表</a></li></ul></li></ul><!-- /code_chunk_output --><p>线性时不变系统(LTI)<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><ul><li>线性:满足叠加原理,输出信号为各输入单独对应输出的叠加:<br>系统输入$x_{k}(t)$对应输出$y_k(t)$, 那么输入$\sum_{k}c_kx_k(t)$对应输出$\sum_{k}c_ky_k(t)$, 同样可以拓展到积分<br>线性系统非常重要，主要由于我们能够解，另外物理基本定理通常是线性的，电学规律的麦克斯韦方程组就是线性的，量子力学的伟大定律也是线性方程<sup><a href="#fn_4" id="reffn_4">4</a></sup></li><li>时不变:系统参数不随时间变化,即输入信号时间滞后,输出信号形状不变,时间滞后相同<br>输入$x_t$对应输出$y_t$, 那么输入延后$x_{t-\tau}$对应输出$y_{t-\tau}$<br>线性时不变系统响应: 输入信号与系统的冲击响应的卷积, 即把输入分成简单信号分别求响应后求和</li></ul><p>拉式变换时线性变换<br>$\mathcal{L}(af(t)+bg(t))=a\mathcal{L}f(t)+b\mathcal{L}g(t)$</p><ul><li><p>常用简单变换<br>$\mathcal{L}t^n=\int_{0}^{+\infty}e^{-st}t^ndt=\frac{n!}{s^{n+1}}$<br>$\mathcal{L}e^{at}=\frac{1}{s-a}$<br>$\mathcal{L}1=\frac{1}{s}$   阶跃信号<br>$\mathcal{L}\dot f=sF-f0$</p></li><li><p>拉式反变换: 待推导确认<br>$f=\mathcal{L}^{-1}F$<br>$\mathcal{L}^{-1}(aF+bG)=a\mathcal{L}^{-1}F+b\mathcal{L}^{-1}G$</p></li><li><p><strong>时移</strong><br>阶跃信号$u_{t}$时移后为$u_{t-c}$, 即从$t=c$开始信号从0变为1, 对应$u_t=u_{t-c}$<br>$\mathcal{L}u_t=\int_0^{+\infty}u_ts^{-st}dt=\int_c^{+\infty}s^{-st}dt=\frac{e^{-cs}}{s}$<br>$\mathcal{L}u_tf_{t-c}=\int_c^{+\infty}f_{t-c}s^{-st}dt=e^{-cs}\mathcal{L}f_t=e^{-cs}F$</p></li><li><p>终值定理<br>$\mathcal{L}(f’)=\int_0^{+\infty}f’s^{-st}dt=sF(s)-f(0)$<br>取极限得到$\lim_{s \to 0} \int_0^{+\infty}f’s^{-st}dt=f(+\infty )-f(0)=\lim_{s \to 0}sF(s)-f(0)$, 所以$f(+\infty )=\lim_{s \to 0}sF(s)$</p></li></ul><p>拉式变换<sup><a href="#fn_2" id="reffn_2">2</a></sup>可用来解方程<a href="https://tutorial.math.lamar.edu/classes/de/LaplaceIntro.aspx" target="_blank" rel="noopener">Solving IVP’s With Laplace Transforms</a><br>求系统在一般输入信号下的响应,把一般输入信号转换分解成简单的基本信号(脉冲信号和指数函数信号),<br>然后由叠加原理得到一般输入的响应.傅里叶变换形式中有指数函数分解,正交函数,够丰富</p><h2 id="卷积响应"><a href="#卷积响应" class="headerlink" title="卷积响应"></a>卷积响应</h2><p>参考<sup><a href="#fn_3" id="reffn_3">3</a></sup>将输入分解成单位脉冲,脉冲响应的和为系统的响应</p><script type="math/tex; mode=display">y(t)=\int_{-\infty}^{\infty} u(\tau) h(t-\tau) d \tau</script><p>直观理解就是把输入函数划分为无穷多个脉冲, 每个脉冲对应的响应的和<br>变量代换$\tau_{1}=t-\tau$得</p><script type="math/tex; mode=display">y(t)=\int_{\infty}^{-\infty} u\left(t-\tau_{1}\right) h\left(\tau_{1}\right)\left(-d \tau_{1}\right)=\int_{-\infty}^{\infty} h(\tau) u(t-\tau) d \tau</script><p>直观理解就是脉冲响应每个时间对应的所有输入的和,这里是固定脉冲响应的每个时刻,上面是固定输入函数的时刻<br>这就是卷积<sup><a href="#fn_5" id="reffn_5">5</a></sup>, <strong>卷积定理: 时域或频域的卷积时对应另一个域的乘积</strong><br>针对两个函数的拉式变换<br>$F(s)=\int_{-\infty}^{+\infty}e^{-su}f(u)du$<br>$G(s)=\int_{-\infty}^{+\infty}e^{-sv}g(v)dv$</p><p>$F(s)\cdot G(s)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}e^{-s(u+v)}f(u)g(v)dudv$<br>令$t=u+v$则<br>$F(s)\cdot G(s)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}e^{-st}f(u)g(t-u)dudt=\int_{-\infty}^{+\infty}e^{-st}\int_{-\infty}^{+\infty}f(u)g(t-u)dudt=\int_{-\infty}^{+\infty}e^{-st}(f*g)dt$</p><p>时域卷积: 输出信号 = 输入信号 <em> 系统时域脉冲响应 = $\mathcal{L^{-1}}$ ($\mathcal{L}$输入信号 ·  $\mathcal{L}$时域脉冲响应)<br>$\mathcal{L}$输出信号 = $\mathcal{L}$输入信号 ·  $\mathcal{L}$时域脉冲响, 所以系统的传递函数就是脉冲响应(频域, 即时域脉冲响应函数的拉式变换). <em>*这个性质非常重要, 系统的输出为输入与脉冲响应的卷积, 通过拉式变换变换成拉式域的乘积,避免了卷积的复杂计算</em></em></p><p>卷积定理可用于理解滤波器设计, FIR数字滤波器本质上就是用输入信号与一些列系数的卷积</p><p><img src="/2019/12/27/拉氏变换/卷积.png" alt="卷积"></p><h2 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h2><p>传递函数定义: 零初始条件下,系统输出的拉式变换与系统输入的拉式变换的比值, $G(s)=\frac{X(s)}{U(s)}$. 可以通过卷积推导$x(t)=u(t)\ast g(t)$, 即系统的输出是输入信号与系统脉冲响应的卷积, 两边拉式变换得到前式(前提是零初始条件), 即传递函数就是系统脉冲响应的拉式变换.<br>非零初始条件: 在初始时刻赋予系统能量,使得系统达到初始状态,脉冲输入.以简单1阶系统为例,$\frac{dx}{dt}+ax=u$, 两边拉式变换得到$sX(s)-x_0+aX(s)=U(s)$, 即$G(s)=\frac{X(s)}{U_1(s)}=\frac{1}{s+a}$, 其中$U_1(s)=x_0+U(s)$, 相当于系统有两个输入, 其中初始条件$x_0$,对应脉冲输入.可以两个输入分别求响应后再加起来得到最后的输出(LTI)<br>基本信号指数函数${e^{st}}$作为输入,得到传递函数就是脉冲响应的拉氏变换$H(s)$</p><script type="math/tex; mode=display">\begin{aligned}y(t) &=\int_{-\infty}^{\infty} h(\tau) u(t-\tau) d \tau \\&=\int_{-\infty}^{\infty} h(\tau) e^{s(t-\tau)} d \tau \\&=\int_{-\infty}^{\infty} h(\tau) e^{s t} e^{-s \tau} d \tau \\&=\int_{-\infty}^{\infty} h(\tau) e^{-s \tau} d \tau e^{s t} \\&=H(s) e^{s t}\end{aligned}</script><p>根据定义域不同分为双边拉式变换$[-\infty, +\infty]$, 单边拉式变换$[0, +\infty]$,单边认为之前时刻输入都是0，和实际更符合。这里需要函数$f(t)$分段连续: 有限断点、上下界有限</p><p><img src="/2019/12/27/拉氏变换/拉氏变换.png" alt="拉氏变换"></p><h2 id="频率响应frequency-response"><a href="#频率响应frequency-response" class="headerlink" title="频率响应frequency response"></a>频率响应frequency response</h2><p>频率响应通过线性时不变系统对正弦输入的<strong>稳态响应</strong>来分析系统的性能.选用正弦信号是因为所有信号都可以通过傅里叶变换分解成正弦信号的和且更容易通过物理元器件实现.其他信号包括指数信号, 脉冲信号</p><ul><li>传递函数分析<br>针对一般正弦输入<script type="math/tex; mode=display">u_t=M\sin (wt+\phi)=A\sin (wt)+B\cos (wt)=\frac{A}{2j}(e^{jwt}-e^{-jwt})+ \frac{B}{2}(e^{jwt}+e^{-jwt})</script>拉式变化得到<script type="math/tex; mode=display">\mathcal{L}u=\frac{A}{2j}(\frac{1}{s-jw}-\frac{1}{s+jw}) +\frac{B}{2}(\frac{1}{s-jw}+\frac{1}{s+jw})=\frac{Aw+Bs}{s^2+w^2}</script>输出<script type="math/tex; mode=display">X(s)=U(s)G(s)=\frac{Aw+Bs}{(s+jw)(s-jw)}\frac{N(s)}{D(s)}  =\frac{K_1}{s+jw}+\frac{K_2}{s-jw}+\frac{c_1}{s+s_{p1}}+\cdots +\frac{c_n}{s+s_{pn}}</script>其中$K_1=\frac{B+Aj}{2}G(-jw)$,$K_2=\frac{B-Aj}{2}G(jw)$<br>输出$x(t)=\mathcal{L}X(s)=K_1e^{-jwt}+K_2e^{jwt}+c_1e^{s_{p1}t} +\cdots +c_ne^{s_{pn}t}$,需要传递函数所有极点的实部都小于0才能保证系统的稳定,也才有分析频率响应的意义,对应的稳态响应为$x(t)=K_1e^{-jwt}+K_2e^{jwt}$, 这里是实数信号,通过公式$\overline{x(t)}=x(t)$也可以得到$\overline{K_1}=K_2$, 即系数共轭.$\overline{G(jw)} =\int_{-\infty }^{+\infty} fe^{jwt}dt=G(-jwt)$,即$G(jw)$,$G(-jw)$共轭<br>所以<script type="math/tex; mode=display">x(t)=\frac{B+Aj}{2}G(-jw)e^{-jwt}+\frac{B-Aj}{2}G(jw)e^{jwt}=|G(jw)|M\sin (\angle G(jw)+wt+\phi)</script>所以这里对应幅值和相位都有改变,幅值的比值就是幅频响应,相位改变就是相频响应.</li><li>指数信号分析<br>首先使用欧拉公式把正弦(余弦)信号表示成两个指数函数的和<br>$A \cos (\omega t)=\frac{A}{2}\left(e^{j \omega t}+e^{-j \omega t}\right)$<br>再使用上式中令$s=jw$,则对于$u(t)=e^{jwt}$的响应为$y(t)=H(jw)e^{jwt}$,$u(t)=e^{-jwt}$的响应为$y(t)=H(-jw)e^{-jwt}$,所以最终响应:<script type="math/tex; mode=display">y(t)=\frac{A}{2}\left[H(j \omega) e^{j \omega t}+H(-j \omega) e^{-j \omega t}\right]</script>令$H(j \omega)=M(\omega) e^{j \varphi(\omega)}$,则有<script type="math/tex; mode=display">\begin{aligned}y(t) &=\frac{A}{2} M\left(e^{j(\omega t+\varphi)}+e^{-j(\omega t+\varphi)}\right) \\&=A M \cos (\omega t+\varphi)\end{aligned}</script>其中:<script type="math/tex; mode=display">M=|H(j \omega)|, \varphi=\angle H(j \omega)</script>同理可以得到输入$sin(wt)$, 对应系统输出$Asin(wt+\phi)$, 其中幅值和相位差都是脉冲响应传递函数引入的<br>也就是说传递函数为$H(s)$的系统,如果输入为$A$的正弦信号,那么输出也是同频率的幅值为$AM$正弦信号,且相位有$\varphi$的移动,这里分析得到的结果直接就是稳态响应, 瞬态的在哪里?</li></ul><h2 id="伯德图"><a href="#伯德图" class="headerlink" title="伯德图"></a>伯德图</h2><p>伯德图就是不同频率下传递函数幅值和相位的响应</p><p>分贝(dB, Decibel)<sup><a href="#fn_6" id="reffn_6">6</a></sup>, “分”（deci-）指十分之一，单位是“贝”或“贝尔”, 纪念Alexander Graham Bell, 通常很少用bel,一般只用decibel. 分别为能量比值, 定义为测量功率与参考功率比值对数的10倍</p><script type="math/tex; mode=display">L_{dB}=10\log_{10}\frac{P_m}{P_r}</script><p>如果用幅值,因为幅值的平方对应功率,所以对应用幅值表示为</p><script type="math/tex; mode=display">L_{dB}=10\log_{10}\frac{P_m}{P_r}=20\log_{10}\frac{M_o}{M_i}</script><p>对数可以把乘法转换为加法, 通常加法更容易计算和绘图$20\log MN=20\log M+20\log N$, <strong>对于串联系统$G=G_1G_2=A_1e^{i\theta _1}A_2e^{i\theta _2}=A_1A_2e^{i(\theta _1+\theta _2)}$,幅值相乘,相位相加</strong>.对应幅值比例$20\log |G|=20\log |G_1|+20\log |G_2|=20\log A_1+20\log A_2$, 即直接把各自幅值直接相加, 图像上可以分别绘制单个简单传递函数幅值(dB),然后进行相加</p><h3 id="典型函数频率响应"><a href="#典型函数频率响应" class="headerlink" title="典型函数频率响应"></a>典型函数频率响应</h3><ul><li>1阶系统<br>$G=\frac{a}{s+a}$, 幅值$|G|=\frac{a}{\sqrt{w^2+a^2}}$, $\angle G=-\tan^{-1} \frac{w}{a}$(可以分别把分子分母用$Ae^{i\theta}$表示, 使用复数运算)时频率响应如下, 可以通过上面的技巧进行手绘<br>当$w\ll a$时, $|G|=1$, $\angle G=0$, 即水平线<br>当$a\ll w$时, $|G|=\frac{a}{w}$, 对应斜率-20dB/10倍频率直线,$\angle G=-\frac{\pi}{2}$,即水平线, 这就是对应的渐近线, 手绘即可得到大致图形<br>当$w=a$时为截止频率, $|G|=\frac{1}{\sqrt{2}}$, 即对应功率为原来一半<br><strong>1阶系统高频部分输入的幅值被有效抑制,对应低通滤波器</strong>.$G=\frac{1}{s+1}$就是一阶巴特沃斯滤波器(Butterworth Filter)<br><img src="/2019/12/27/拉氏变换/firstOrderBode.png" alt="一阶系统"></li><li>2阶系统<script type="math/tex; mode=display">H(s)=\frac{\omega_{n}^{2}}{s^{2}+2 \zeta \omega_{n} s+\omega_{n}^{2}}=\frac{\omega_{n}^{2}}{\left(s+\zeta \omega_{n}\right)^{2}+\omega_{n}^{2}\left(1-\zeta^{2}\right)}</script>式中$\omega_{n}$为无阻尼<strong>自然频率</strong>,$\zeta$为阻尼比.<br>分析传递函数幅值求最大值对应频率为$w=w_n\sqrt{1-2\xi ^2}$, 即为共振频率(也叫<strong>阻尼固有频率</strong>, Damped Natural Frequency), 对应需要满足$\xi &lt; \sqrt{0.5}$, 当$\xi$很小时就是约等于固有频率. 当$\xi=0$时, $|G|=\frac{w_n^2}{w_n^2-w^2}$, 当$w=w_n$时, $|G|\to +\infty $, 系统不稳定, 符合临界稳定(根在虚轴上)但不满足BIBO稳定.日常生活中也有很多共振现象,比如小提琴通过共振的箱体放大琴弦本生振动的音量<br><img src="/2019/12/27/拉氏变换/secondOrder.png" alt="二阶系统"><br>二阶系统对应的根为<script type="math/tex; mode=display">s=-\sigma \pm j \omega_{d}</script><script type="math/tex; mode=display">\sigma=\zeta \omega_{n} \text { and } \omega_{d}=\omega_{n} \sqrt{1-\zeta^{2}}</script>通过查表或者借助拉式变换的位移性质推导得到系统的单位脉冲响应的输出为<script type="math/tex; mode=display">h(t)=\frac{\omega_{n}}{\sqrt{1-\zeta^{2}}} e^{-\sigma t}\left(\sin \omega_{d} t\right) 1(t)</script>据此可以分析$s$平面不同位置的输出变换趋势.</li><li>积分器, $G=\frac{1}{s}$<br>如下图所示,<strong>频率很低处输出幅值比输入大, 需要额外能量, 所以积分器无法通过被动元件实现</strong>, 需要额外供能<br><img src="/2019/12/27/拉氏变换/intBode.png" alt="积分环节"></li><li>微分, $G=s$<br>和积分类似,在频率较高地方,幅值比输入大, 需要额外供能<br><img src="/2019/12/27/拉氏变换/dfBode.png" alt="微分环节"></li><li>比例控制器, 不改变相位, 幅值同比例</li><li>超前补偿器, 如$G=\frac{s+1}{s+10}=\frac{1}{10}(s+1)(\frac{1}{0.1s+1})$, 可以看成3个传递函数串联, 分别绘制幅频响应后叠加即可得到最后的响应如下.不需要额外供能, 相位超前<br><img src="/2019/12/27/拉氏变换/FWBode.png" alt="超前补偿器"></li><li>滞后补偿器, 如$G=\frac{0.1s+1}{s+1}$, 相位滞后<br><img src="/2019/12/27/拉氏变换/BFBode.png" alt="滞后补偿器"></li><li>PD控制器, 高频部分幅值放大, 需要必须要滤波器去除高频信号才能提高稳定性</li></ul><h3 id="典型函数的时域响应"><a href="#典型函数的时域响应" class="headerlink" title="典型函数的时域响应"></a>典型函数的时域响应</h3><ul><li>1阶系统<br>输入阶跃信号1, $X(s)=\frac{1}{s}\frac{a}{s+a}$, 输出$x=\mathcal{L}^{-1}(\frac{1}{s-0}-\frac{1}{s+a})=e^{0t}-e^{-at}=1-e^{-at}$<br>时间常数(Time Constant):$\tau =\frac{1}{a}$, 对应$x\approx 0.63$<br>调节时间(稳定时间, Settling Time):$T_s=t\tau=\frac{4}{a}$, 对应$x(T_s)\approx 0.98$, 即系统输出与终值差距2%时间(后续时间差值都在次范围内)</li><li>2阶系统<br>主要指标包括上升时间,最大超调量,稳定时间.针对阶跃信号1, $X(s)=\frac{1}{s}\frac{w_n^2}{s^2+2\zeta w_ns+w_n^2}$, 系统的3个根分别为$s_{p1}=0,s_{p2}=-\zeta w_n+w_n\sqrt{\zeta ^2-1} ,s_{p3}=-\zeta w_n-w_n\sqrt{\zeta ^2-1}$, 每个根决定了系统的输出, 可以借助1阶系统稳定时间分析得到2阶系统稳定时间为$T_s=\frac{4}{\zeta w_n} $, 这是针对有虚部解的情况. 如果2个都是实根, 取最小根的稳定时间 </li></ul><h2 id="附加零极点的作用"><a href="#附加零极点的作用" class="headerlink" title="附加零极点的作用"></a>附加零极点的作用</h2><p>这里都是直接在最后的传递函数上增加零点和极点，和后面的pd、pi控制不同，后面是在开环传递函数基础上增加，研究闭环传递函数</p><ol><li><p>附加零点</p><ul><li>零点在左半平面分成两项就是原来的响应+原来响应的导数。导致增加超调和减小上升时间</li><li>零点在右半平面分成两项就是原来的响应-原来响应的导数。导致减小超调，可能引起节约响应刚开始朝错误的方向运动（有右半平面的零点为非最小相位系统）</li></ul></li><li><p>附加极点<br>延长了上升时间</p></li></ol><h2 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h2><p>这里和前面分开，增加的控制项是直接作用于开环传递函数</p><ul><li>P控制，提高比例增益可以降低稳态误差，但高增益导致系统不稳定</li><li>I控制，具有消除稳态误差的鲁棒性，但会降低系统的稳定性（根轨迹想右压）</li><li>D控制，<strong>提高阻尼增加系统的稳定性</strong></li></ul><p><img src="/2019/12/27/拉氏变换/反馈控制重要公式.png" alt="反馈控制重要公式(来自引用3)"><br>带宽等于闭环特征根的自然频率：对于闭环阻尼$\zeta=0.7$，$\omega_{BW}=\omega_{n}$，其他阻尼比，带宽近似，误差不超过2倍。可以用于估计上升时间</p><p>穿越频率$\omega_{c}$:幅值为1或者0dB处的频率</p><p>相位阈度PM=30°一般任务是达到满意的最低值</p><p>频率响应稳定设计简单准则: 调整幅值曲线的斜率,使之在附近的10倍频程内以斜率为-1穿过幅值1的曲线(相位-90°左右,PM在90°左右)</p><p>对于标准的二阶系统,相位阈度和系统闭环阻尼如下:</p><script type="math/tex; mode=display">\zeta \cong \frac{\mathrm{PM}}{100}</script><p>二阶系统,伯德图中幅值的峰值与阻尼比关系如下:</p><script type="math/tex; mode=display">|G(j \omega)|=\frac{1 \mid}{2 \zeta} \quad \text { at } \omega=\omega_{n}</script><h2 id="其他"><a href="#其他" class="headerlink" title="　其他"></a>　其他</h2><ol><li>二阶系统中工程上常取$\zeta = 0.7$作为最饥饿阻尼洗漱</li><li>当引入的实数极点与主导极点的模值之比大于５时，非主导极点对时间响应的影响可以忽略．（主导极点：左半复平面离虚轴最近，且周围没有零点的极点，其余极点远离虚轴）</li><li>在系统开环放大洗漱比较适当，动态性能比较好的情况下，略去开环系统小时间常数环节(系数相对其他项较小的项)不会引起较大误差；当系统开环系数较大，动态性能较差的情况下需要慎重（自动控制原理-第四版-高国燊-P102）</li><li>惯性环节$G = {K \over {Ts + 1}}$过渡时间为$3T$,即时间响应稳定在稳态值的0.05附近</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote id="fn_1"><sup>1</sup>. <a href="https://en.wikipedia.org/wiki/Linear_time-invariant_system" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Linear_time-invariant_system</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://en.wikipedia.org/wiki/Laplace_transform" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Laplace_transform</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. Franklin, Gene F.Feedback control of dynamic systems / Gene F. Franklin, J. David Powell,<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><p>Abbas Emami-Naeini. — Seventh edition</p><blockquote id="fn_4"><sup>4</sup>. <a href="https://www.feynmanlectures.caltech.edu/I_25.html" target="_blank" rel="noopener">https://www.feynmanlectures.caltech.edu/I_25.html</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. <a href="https://en.wikipedia.org/wiki/Convolution" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Convolution</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. <a href="https://en.wikipedia.org/wiki/Decibel" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Decibel</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="拉式变换表"><a href="#拉式变换表" class="headerlink" title="拉式变换表"></a>拉式变换表</h3><div class="row">    <embed src="Laplace_Table.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动控制原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下wps缺少字体</title>
      <link href="2019/12/22/ubuntu%E4%B8%8Bwps%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93/"/>
      <url>2019/12/22/ubuntu%E4%B8%8Bwps%E7%BC%BA%E5%B0%91%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h1><ol><li>下载字体<a href="https://github.com/yangbenbo/wps-font-symbols/archive/master.zip" target="_blank" rel="noopener">https://github.com/yangbenbo/wps-font-symbols/archive/master.zip</a></li><li><p>解压并复制到字体文件夹</p><p> unzip wps-font-symbols-master.zip<br> sudo cp -r wps-font-symbols-master /usr//share/fonts/</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/u014241313/article/details/91070843" target="_blank" rel="noopener">Linux Wps 缺少字体</a>    </li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS遇到的问题</title>
      <link href="2019/12/21/ROS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2019/12/21/ROS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="终端结束所有节点之后显示仍有节点"><a href="#终端结束所有节点之后显示仍有节点" class="headerlink" title="终端结束所有节点之后显示仍有节点"></a>终端结束所有节点之后显示仍有节点</h1><p>清理node,否则影响查看节点通信</p><pre><code>rosnode listrosnode cleanup</code></pre><h1 id="程序排错"><a href="#程序排错" class="headerlink" title="程序排错"></a>程序排错</h1><p>首先看<strong>循环</strong>,是否调用ros::spinOnce(),对应的数据是否更新</p><p>好几次是因为循环没有更新数据,排错废了不少时间</p><ul><li>没有调用ros::spinOnce(),导致没有处理回调函数,也就没有更新数据</li><li>回调函数处理后的数据是否放入对应变量,有时候用的是中间变量,导致更新的数据没有放进去</li></ul><p>ROS也有异步更新的机制,之前用过,出过一次问题,可以根据需要选择更新的机制</p><h1 id="KDL和trac-ik库使用"><a href="#KDL和trac-ik库使用" class="headerlink" title="KDL和trac-ik库使用"></a>KDL和trac-ik库使用</h1><p>在ubuntu16+ros kinetic 和ubuntu18+ros melodic中不一样<br>后一版本中需要用于初始化正逆解对象的KDL::Chain一直存在，可作为类成员变量，可能是后一版本中进行了优化，减少了拷贝的次数</p><h1 id="远程通信"><a href="#远程通信" class="headerlink" title="远程通信"></a>远程通信</h1><p>When a ROS node advertises a topic, it provides a hostname:port combination (a URI) that other nodes will contact when they want to subscribe to that topic.<br><strong>It is important that the hostname that a node provides can be used by all other nodes to contact it.</strong><br>注意需要知道相互的主机名到ip的映射,否则可能会有问题,有一次没配置主机名的映射,从机可以获取主机的会话题信息,但是无法连接上主机的server</p><p>例子:remote为主机名master,本地主机名为slave</p><pre><code>hostname    # 查看本机主机名 hostname# 修改ip映射 主机加上从机的hostname 和 ip# 从机加上主机的hostname 和 ip    sudo vim /etc/hosts # 修改ros 环境变量vim ~/.bashrc# 主机 增加 如下  localhost可以直接使用ip或者主机名(master,slave)export ROS_HOSTNAME=localhostexport ROS_MASTER_URI=http://localhost:11311# 从机增加如下export ROS_HOSTNAME=localhostexport ROS_MASTER_URI=http://master:11311</code></pre><h2 id="rosrun-rqt-tui-rqt-gui-报错-segfaults"><a href="#rosrun-rqt-tui-rqt-gui-报错-segfaults" class="headerlink" title="rosrun rqt_tui rqt_gui 报错 segfaults"></a>rosrun rqt_tui rqt_gui 报错 segfaults</h2><p>问题描述:<br>可以使用<code>rqt</code>打开,但是无法使用<code>rosru rqt_gui rqt_gui</code>打开,导致无法使用easy-hand-eye标定包</p><p>通过查阅<a href="https://github.com/ros-visualization/rqt/issues/114" target="_blank" rel="noopener">rqt segfaults on kinetic #114</a><br><a href="https://answers.ros.org/question/253655/rqt-segmentation-fault-following-tutorials/" target="_blank" rel="noopener">rqt segmentation fault following tutorials</a><br>得知问题主要是PyQt version的原因,所以试过了链接中的方法,都不太行,最后是卸载了qt5*,然后重新安装rqt_gui,发现只要安装rqt之后就无法通过<code>rosrun</code>的方式打开`</p><pre><code>sudo apt remove qt5*sudo apt install ros-kinetic-rqt-gui</code></pre><h2 id="“Failed-to-fetch-current-robot-state”-when-running-getCurrentPose-1187"><a href="#“Failed-to-fetch-current-robot-state”-when-running-getCurrentPose-1187" class="headerlink" title="“Failed to fetch current robot state” when running getCurrentPose #1187"></a>“Failed to fetch current robot state” when running getCurrentPose #1187</h2><p>描述:使用moveit的时候出现无法获取机械臂当前状态信息k</p><p>解决方案:</p><pre><code>// 异步处理回调函数,处理更新ros::AsyncSpinner spinner(1); spinner.start();</code></pre><h2 id="多个工作空间activate-即Sourcing-from-multiple-workspaces"><a href="#多个工作空间activate-即Sourcing-from-multiple-workspaces" class="headerlink" title="多个工作空间activate,即Sourcing from multiple workspaces"></a>多个工作空间<code>activate</code>,即<code>Sourcing from multiple workspaces</code></h2><p>描述,想要多个ROS空间的环境变量同时工作</p><ul><li>如果使用clion编译则可以不用管,直接source cmake-build-debug/devel/setup.bash</li><li><p>使用<code>catkin</code>编译则需要注意空间<a href="https://answers.ros.org/question/205976/sourcing-from-multiple-workspaces/" target="_blank" rel="noopener">Sourcing from multiple workspaces</a><br><code>catkin_make</code> 第一次运行会生成<code>devel</code>文件夹,并创建<code>setup.bash</code>,这个文件会覆盖所有其他已经被<code>source</code>的空间(除了ROS本身的安装空间),如果需要多个空间同时<code>active</code><br><strong>注意只需要在第一次编译的时候移除文件夹devel,然后重编译.之后改动就正常编译就行</strong></p><pre><code>  # 需要新加空间的地方  catkin_make  rm -rf devel/  catkin_make  source devel/setup.bash</code></pre></li></ul><h2 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h2><p>可以调整CPU频率，intel的cpu默认省电模式，频率较低，可能会导致延时大<br>使用cpufreq，参考<a href="https://frankaemika.github.io/docs/troubleshooting.html" target="_blank" rel="noopener">franka操作</a></p><h2 id="Gazebo第一次加载太慢"><a href="#Gazebo第一次加载太慢" class="headerlink" title="　Gazebo第一次加载太慢"></a>　Gazebo第一次加载太慢</h2><p>把<a href="https://bitbucket.org/osrf/gazebo_models/downloads/" target="_blank" rel="noopener">模型</a>放在指定目录下 <code>~/.gazebo/models</code> 下保证模型顺利加载</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="http://wiki.ros.org/ROS/NetworkSetup" target="_blank" rel="noopener">ROSNetworkSetup</a>             </li></ol>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="2019/12/15/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>2019/12/15/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#arprarp">ARP/RARP</a><ul><li><a href="#ip地址">IP地址</a></li></ul></li><li><a href="#icmp">ICMP</a></li><li><a href="#tcpudp">TCP/UDP</a></li><li><a href="#csmacd">CSMA/CD</a></li><li><a href="#遇到的问题">遇到的问题</a></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><p> TCP/IP 协定家族中，其层阶关係如下<br><img src="/2019/12/15/网络基础/TCPIPfamily.png" alt><br>TCP/IP 的资料流是逐层传递的<br><img src="/2019/12/15/网络基础/TCPIPdata.png" alt></p><p>OSI 7层:前3属网络群组,后4属于使用者群组</p><p>TCP/IP 运作举例</p><ol><li>应用程式阶段：妳打开瀏览器，在瀏览器上面输入网址列，按下 [Enter]。此时网址列与相关资料会被瀏览器包成一个资料， 並向下传给 TCP/IP 的应用层；</li><li>应用层：由应用层提供的 HTTP 通讯协定，將来自瀏览器的资料包起来，並给予一个应用层表头，再向传送层丟去；</li><li>传送层：由於 HTTP 为可靠连线，因此將该资料丟入 TCP 封包內，並给予一个 TCP 封包的表头，向网路层丟去；</li><li>网路层：將 TCP 包裹包进 IP 封包內，再给予一个 IP 表头 (主要就是来源与目標的 IP 囉)，向链结层丟去；</li><li>链结层：如果使用乙太网路时，此时 IP 会依据 CSMA/CD 的標准，包裹到 <strong>MAC</strong> 讯框中，並给予 MAC 表头，再转成位元串后， 利用传输媒体传送到远端主机上。</li></ol><p><strong>IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。</strong><br><img src="/2019/12/15/网络基础/OSI_TCPIP.png" alt="OSI与TCP/IP"></p><h2 id="ARP-RARP"><a href="#ARP-RARP" class="headerlink" title="ARP/RARP"></a>ARP/RARP</h2><ol><li>ARP 协定:Address Resolution Protocol,获取目标IP对应的物理地址,实际传输都是靠物理地址.<br>ARP 是 TCP/IP 设计者利用乙太网的广播性质﹐设计出来的位址解释协定。</li><li>RARP 协定:Reverse Address Resolution Protocol,利用广播,查询网路上其它主机而得到自己的 IP 位址.</li><li>PROXY ARP:代理 (Proxy) ARP 通常用来在路由器上代为回答在它后面的某个网路主机的 ARP 请求。<br>这是一种欺骗手法﹐因为查询端会以为目標主机就是路由器本身﹐但事实上﹐机器是在另一个网路里面。</li></ol><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p><img src="/2019/12/15/网络基础/IPHead.png" alt><br>在局域网内可通过ip广播来传递资料,非目标主机会自动丢弃资料(通过物理地址判断)</p><p>同一局域网内设置成不同ip网段,广播地址不同造成无法透过广播的方式进行连线,需要路由(router)</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ol><li><p>IP划分<br> <img src="/2019/12/15/网络基础/IPSection.png" alt><br> 127 (即二进位的 01111111) 需要特別一提：它是保留给本机回路测试使用的﹐<br> 它不可以被运用於实际的网路中，其中的 127.0.0.1 则代表任何一台 IP 主机本身.</p><ul><li>主机号位置全为0    整个网段的地址</li><li>主机号位置全为1    广播地址</li></ul></li><li><p>私有IP<br> 住主要用于组建局域网</p><p> 由於 Internet 的爆炸性成长﹐IP 的位址买少见少﹐而且在很多机构里﹐<br> 也不是所有机器都有必要使用註册的 IP 位址。於是﹐我们就在 A﹑B﹑C 这三个层级里面﹐<br> 各划出一些位址范围保留给私有位址所用﹐它们分別是﹕</p><ul><li>10.0.0.0 - 10.255.255.255</li><li>172.16.0.0 - 172.31.255.255</li><li><p>192.168.0.0 - 192.168.255.255</p><p>限制:</p></li><li>私有位址的路由资讯不能对外散播;</li><li>使用私有位址作为来源或目的位址的封包﹐不能透过 Internet 来转送;</li><li>关於私有位址的参考纪录﹐只能限於內部网路使用</li></ul></li><li><p>Subnet:划分子网,从Host ID中借位<br> <img src="/2019/12/15/网络基础/Subnet.png" alt="Subnet"></p></li><li>Supernet:从NET ID中借位使用的是 CIDR (Classless Inter-Domain Routing)技术.可不必理会 IP 的开首字元﹐你可以隨便设定您的 Net Mask 长度。<br> <img src="/2019/12/15/网络基础/Supernet.png" alt="Supernet"></li></ol><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP 的全名是『 Internet Control Message Protocol, 网际网路讯息控制协定 』。 基本上，ICMP 是一个错误侦测与回报的机制，最大的功能就是可以確保我们网路的连线状態与连线的正確性！</p><p>ICMP 同样是透过 IP 封包来进行资料传送的啦！因为在 Internet 上面有传输能力的就是 IP 封包啊！ </p><p>应用:使用ping 与 traceroute透过 ICMP 封包的辅助来確认与回报网路主机的状態。</p><p>设定防火墙的时候,容易忽略的就是这个 ICMP 的封包(只会记住 TCP/UDP),基本上，ICMP 封包也不应该全部都挡掉喔! </p><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p>针对TCP表头,主要注意6个Control FLag.相应的TCP3次握手也主要是从这个来的</p><ul><li>Urgent data:当 URG 被设定为 1 的时候﹐表示紧急资料的封包，接收端需优先处理。</li><li>Acknowledge field significant:当 ACK 为 1 的时候﹐表示此封包的 Acknowledge Number 是有效的﹐也就是用来回应上一个封包。一般都会为 1。一般只有只有第一个封包没有设。</li><li>Push function:如果 PSH 为 1 的时候﹐该封包连同传送缓衝区的其它封包应立即进行传送，而无需等待缓衝区满了才送。接收端必须儘快將此资料交给程式处理。</li><li>Reset:如果 RST 为 1 的时候﹐连线会被马上结束，而无需等待终止確认手续。</li><li>Synchronize sequence number:如果 SYN 为 1 时﹐表示要求双方进行同步处理﹐也就是要求建立连线。</li><li>No more data fro sender (Finish):如果封包的 FIN 为 1 的时候﹐就表示传送结束﹐然后双方发出结束回应﹐进而正式进入 TCP 传送的终止流程。</li></ul><p><img src="/2019/12/15/网络基础/TCPHead.png" alt="TCPHead"><br>Sequence 和 Acknowledge 是 TCP 传送中的重要检测手段.<br><img src="/2019/12/15/网络基础/TCPTrans.png" alt="TCPTrans"><br><img src="/2019/12/15/网络基础/UDPHead.png" alt="UDPHead"><br>TCP 提供的是一个连线导向(Connection Oriented)的可靠传输.<br>UDP 则是一个非连线型(Connectionless)的非可靠传输协定﹐<br>它並不会运用確认机制来保证资料是否正確的被接收、<br>不需要重传遗失的资料、资料的接收可不必按顺序进行、<br>也不提供回传机制来控制资料流的速度。<br>因此﹐ UDP 信息可能会在网路传送过程中丟失﹑重复﹑或不依顺序﹐<br>而且抵达速度也可能比接收端的处理速度还快。</p><ul><li>TCP: 传送可靠,程序可省略可靠机制,但速度慢</li><li>UDP: 传输量大,迅速,但是不可靠,需要程序自行提供可靠机制</li></ul><h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h2><p>乙太网路的传输协定 CSMA/CD (Carrier Sense Multiple Access with Collision Detection) </p><p>虽然讯框会在整个网段(segment)中用广播的方式传递﹐而且所有节点都会收到讯框﹐<br>然而﹐只有目的位址符合自己实体位址的讯框才会被接收下来。<br>因此，不管上层协定是哪一种(可以是 TCP/IP 也可以是其它)，<br>在底层的传送若是使用 Ethernet 的话，就得使用 <strong>MAC (Media Access Control) </strong>实体位址.</p><ol><li><p>监听媒体使用情况 (Carrier Sense)：A 主机要发送网路封包前，需要先对网路媒体进行监听，<br>確认没有人在使用后， 才能够发送出讯框；</p></li><li><p>多点传输 (Multiple Access)：A 主机所送出的资料会被集线器复製一份，<br>然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的资料，<br>B, C, D 三部电脑都能够接收的到！但由於目標是 D 主机，因此 B 与 C 会將此讯框资料丟弃，而 D 则会抓下来处理；</p></li><li><p>碰撞侦测 (Collision Detection)：该讯框资料附有检测能力，<br>若其他主机例如 B 电脑也刚好在同时间发送讯框资料时，<br>那么 A 与 B 送出的资料碰撞在一块 (出车祸) ，此时这些讯框就是损毁，<br>那么 A 与 B 就会各自隨机等待一个时间， 然后重新透过第一步再传送一次该讯框资料。</p></li></ol><p><img src="/2019/12/15/网络基础/csmacd.gif" alt="CSMA/CD连线"></p><p>每张乙太网路卡出厂时，就会赋予一个独一无二的卡號，那就是所谓的 MAC (Media Access Control)</p><ol><li><p>HUB 单纯的是一个 repeater﹐当它从一个 port (和 TCP 协定的 port 不一样﹐这里<br>是指插网路线的接孔)接收信號进来之后﹐会將这个信號原原本本的送到所有其它<br>port 上﹐不管哪些 port 是接到哪一台机器。</p></li><li><p>而 switch 呢﹖它自己有一份 table﹐记录著哪个 port 接到哪些 MAC 位址设备上。<br>当信號从一个 port 进来之后﹐会检查这个 frame 的 destination 是哪个 MAC﹐然<br>后按 table 找到这个 MAC 对应的 port ﹐而仅將信號往这个 port 送﹐其它的 port<br>就不送了。</p></li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>网络地址无法访问<br> 很可能是域名解析的问题. 站长工具超级ping,找出能用的ip,然后改hosts<br> <a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">http://tool.chinaz.com/dns/</a>   产看其他地方获得的ip<br> <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a>   查看ip</p><pre><code> # 编辑host文件 增加ip映射 sudo vim /etc/hosts 192.30.253.112, 192.30.253.113  github.com</code></pre></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE#CSMA/CD" target="_blank" rel="noopener">载波侦听多路访问</a></li><li><a href="http://linux.vbird.org/linux_server/0110network_basic.php#ps11" target="_blank" rel="noopener">基础网络概念</a></li><li><a href="http://www.study-area.org/network/networkfr2.htm" target="_blank" rel="noopener">网络基础</a> </li></ol>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word排版</title>
      <link href="2019/12/14/word%E6%8E%92%E7%89%88/"/>
      <url>2019/12/14/word%E6%8E%92%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="点-point-pt"><a href="#点-point-pt" class="headerlink" title="点(point,pt)"></a>点(point,pt)</h1><p>是印刷所使用的长度单位，用于表示字型的大小，也用于余白（字距、行距）等其他版面构成要素的长度。</p><p><img src="/2019/12/14/word排版/中文字号.png" alt="中文字号"></p><h1 id="使用word模板样式"><a href="#使用word模板样式" class="headerlink" title="使用word模板样式"></a>使用word模板样式</h1><p>可将模板中的样式导入到需要用的文档</p><p><img src="/2019/12/14/word排版/导出样式.png" alt="导出样式"></p><h1 id="中英文对照"><a href="#中英文对照" class="headerlink" title="中英文对照"></a>中英文对照</h1><p>学术上专业用语对照查询<br><a href="http://dict.cnki.net/dict_result.aspx" target="_blank" rel="noopener">cnki翻译助手</a></p><h1 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h1><p><strong>word中千万不要手动拖动图片大小</strong></p><p>在visio 设置图纸大小和字号(pt)</p><p>mathtype设置好字号，公式、字母直接复制visio中</p><p>图片插入到word后不要拖动调整大小</p><p>ps中同理设置字号，图像大小</p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>mathtype 可以插入公式序号 引用(双击公式序号) </p><p>可以先在mathtype设置好格式，存储为样板(10pt)</p><h1 id="批量修改word图片为灰度图或彩图"><a href="#批量修改word图片为灰度图或彩图" class="headerlink" title="批量修改word图片为灰度图或彩图"></a>批量修改word图片为灰度图或彩图</h1><p>Alt+F11 进入宏界面-&gt;插入-&gt;模块-&gt;粘贴下列代码-&gt;F5运行</p><pre><code>Sub xx()Dim i As IntegerFor i = 1 To ActiveDocument.InlineShapes.CountIf ActiveDocument.InlineShapes(i).Type = 3 ThenActiveDocument.InlineShapes(i).PictureFormat.ColorType = msoPictureGrayscaleEnd IfNextEnd Sub</code></pre><p>几种样式如下</p><ul><li>自动：msoPictureAutomatic</li><li>黑白：msoPictureBlackAndWhite</li><li>灰度：msoPictureGrayscale</li><li>冲蚀：msoPictureMixed</li><li>水印：msoPictureWatermark</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><a href="/2019/12/04/word参考文献交叉引用/" title="交叉引用">交叉引用</a><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li>维基百科 <a href="https://zh.wikipedia.org/wiki/%E9%BB%9E_(%E5%8D%B0%E5%88%B7" target="_blank" rel="noopener">点 (印刷)</a>)</li><li><a href="https://wenwen.sogou.com/z/q807873456.htm" target="_blank" rel="noopener">Word文档里的图片怎么批量修改图片颜色灰度变回彩色</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word参考文献交叉引用</title>
      <link href="2019/12/04/word%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/"/>
      <url>2019/12/04/word%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="word参考文献交叉引用"><a href="#word参考文献交叉引用" class="headerlink" title="word参考文献交叉引用"></a>word参考文献交叉引用</h1><p>参考文献交叉引用可以实现正文中引用链接到参考文献，避免参考文献引用出错</p><ol><li>参考文献排序</li><li><p>插入-&gt; 交叉引用 -&gt; 选择对应的文献</p><p> <img src="/2019/12/04/word参考文献交叉引用/插入.png" alt="交叉引用"></p></li></ol><h2 id="实现-1-5-形式"><a href="#实现-1-5-形式" class="headerlink" title="实现[1-5]形式"></a>实现[1-5]形式</h2><ul><li><p>第一种方式： 插入之后，选择不想出现的部分,然后选择字体-&gt; 隐藏即可</p><p>  <img src="/2019/12/04/word参考文献交叉引用/隐藏.png" alt="隐藏"></p></li><li><p>第二种方式：</p><ol><li><p>插入交叉引用1,5，右击切换域代码</p><pre><code> 导纳控制{ REF _Re26341043 \r \h }{ REF _Ref26341045 \r \h }</code></pre></li><li><p>增加代码</p><pre><code> 导纳控制{ REF _Re26341043 \r \h \#&quot;[0&quot;}{ REF _Ref26341045 \r \h \#&quot;0]&quot;}</code></pre></li><li>更新域代码,添加 “-“, ctrl+shift++ 切换为上标</li></ol></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://www.jianshu.com/p/e6f71f8ba19a" target="_blank" rel="noopener">Word|如何使用交叉引用标注参考文献</a>    </li><li><a href="https://jingyan.baidu.com/article/25648fc15c03439191fd0033.html" target="_blank" rel="noopener">word参考文献交叉引用的连续多项引用?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效工具</title>
      <link href="2019/11/30/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/"/>
      <url>2019/11/30/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="截图识别公式"><a href="#截图识别公式" class="headerlink" title="截图识别公式"></a>截图识别公式</h2><p><a href="https://mathpix.com/" target="_blank" rel="noopener">mathpix</a> 一款优秀的截图识别公式软件,支持Linux,Windows,Mac,IOS,Android<br>ubuntu 安装</p><pre><code>sudo apt updatesudo apt install snapdsudo snap install mathpix-snipping-tool</code></pre><h2 id="截图识别文字"><a href="#截图识别文字" class="headerlink" title="截图识别文字"></a>截图识别文字</h2><p>效果不是很好,没有windows上截图识别工具好用,如果大量截图识别建议windows<br>ubuntu上截图软件gnome-screenshot 进行截取需要被文字识别的图片；利用文字识别OCR软件tesseract，进行识别将结果输出，复制到文件和剪切板<br>参考<a href="https://zhuanlan.zhihu.com/p/114917496" target="_blank" rel="noopener">Linux系统（ubuntu）一键OCR识别图片截图文字转文本</a></p><h3 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h3><p>在设置-&gt;键盘-&gt;自定义快捷键处增加,名字随意,建议为shell名字,命令则为OCR.sh的绝对路径.然后录制快捷键就额可以</p><h2 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h2><p>使用配置文件json更加方便，输入ctrl + shift + P， 搜索settings会出来json和UI选项，可以根据需要选择</p><p>参考<a href="https://blog.csdn.net/qq_15601471/article/details/120739777" target="_blank" rel="noopener">VS Code的的使用之如何设置以及什么是workspace</a><br>默认设置 &lt; 用户设置&lt;远程设置&lt; 工作区设置&lt;文件夹设置</p><p>默认设置：VS Code的默认值不可编辑修改，当没有提供其它设置的值时候或者提供的是无效值的时候，VS Code提供的默认设置生效；<br>用户设置：此设置对所有项目生效，如果提供了有效设置会覆盖比它权重低的设置；<br>远程设置：如果使用了VS Code的远程开发功能将会显示此Tab，此设置对该远程机器生效，如果提供了有效设置会覆盖比它权重低的设置；<br>工作区设置：默认情况下每打开一个文件夹就是一个工作区，如果提供了有效设置会覆盖比它权重低的设置；<br>文件夹设置：如果启用了多个工作区就会展示此设置，可以为工作区下面的每个文件夹添加独立设置，如果提供了有效设置会覆盖比它权重低的设置，这个设置也是权限最高的设置因为就在当前文件夹下。</p><p>当前配置settings.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pasteImage.path&quot;: &quot;$&#123;currentFileDir&#125;/images/&quot;,</span><br><span class="line">  &quot;pasteImage.basePath&quot;: &quot;$&#123;currentFileDir&#125;/images/&quot;,</span><br><span class="line">  &quot;workbench.settings.editor&quot;: &quot;json&quot;,</span><br><span class="line">  // 自动保存</span><br><span class="line">  &quot;files.autoSave&quot;: &quot;afterDelay&quot;,</span><br><span class="line">  // 字号</span><br><span class="line">  &quot;editor.fontSize&quot;: 17,</span><br><span class="line">  &quot;editor.fontFamily&quot;: &quot;JetBrains Mono NL, &apos;等线&apos;&quot;,</span><br><span class="line">  // code snippet</span><br><span class="line">  &quot;editor.suggestSelection&quot;: &quot;recentlyUsedByPrefix&quot;,</span><br><span class="line">  &quot;vsintellicode.modify.editor.suggestSelection&quot;: &quot;automaticallyOverrodeDefaultValue&quot;,</span><br><span class="line">  // 默认 lf 结尾; </span><br><span class="line">  // linux / mac / win 上的文件结尾符不一样; Git 对于不同的结尾符，在不同平台上可能会引发不一致问题</span><br><span class="line">  &quot;files.eol&quot;: &quot;\n&quot;,</span><br><span class="line">  // vscode update tips</span><br><span class="line">  &quot;update.mode&quot;: &quot;none&quot;,</span><br><span class="line">  // delete confirm</span><br><span class="line">  &quot;explorer.confirmDelete&quot;: false,</span><br><span class="line">  ///////////////////////////////////// 插件 ////////////////////////////////////////////</span><br><span class="line">  // Internal terminal 插件 Code Runner</span><br><span class="line">  &quot;code-runner.runInTerminal&quot;: true,</span><br><span class="line">  &quot;code-runner.fileDirectoryAsCwd&quot;: true,</span><br><span class="line">  // extension update</span><br><span class="line">  &quot;extensions.autoUpdate&quot;: &quot;onlyEnabledExtensions&quot;,</span><br><span class="line">  &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">  &quot;workbench.colorTheme&quot;: &quot;Darcula&quot;,</span><br><span class="line">  //  在按下 Tab 键时进行 Tab 补全，将插入最佳匹配建议</span><br><span class="line">  &quot;editor.tabCompletion&quot;: &quot;on&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="高效插件"><a href="#高效插件" class="headerlink" title="高效插件"></a>高效插件</h3><ul><li>var-translate: 中英互转</li><li>Code Runner</li><li>Markdown Preview Enhanced</li><li>darcula: Clion主题方案(或者使用默认Dark Modern)</li><li>Git Graph</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>可以使用<a href="https://www.jetbrains.com/zh-cn/lp/mono/" target="_blank" rel="noopener">JetBrains Mono NL</a>, 下载之后直接安装即可使用，如果不知道选哪一个就直接Regular</p><h3 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h3><p>可以打开自动同步，这样在不同的电脑可以使用同一份，可以直接使用微软账号登录即可</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://zjinc36.github.io/2020/06/14/Ubuntu%E4%B8%AD%E4%B8%80%E9%94%AEOCR%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E6%88%AA%E5%9B%BE%E6%96%87%E5%AD%97%E8%BD%AC%E6%96%87%E6%9C%AC/" target="_blank" rel="noopener">Ubuntu中一键OCR识别图片截图文字转文本</a></li><li><a href="https://blog.csdn.net/qq_21567385/article/details/122795215" target="_blank" rel="noopener">聊聊vscode配置settings.json知其所以然（附大量配置）</a></li><li><a href="https://blog.csdn.net/qq_21567385/article/details/106775038" target="_blank" rel="noopener">vscode翻译插件最佳搭配、翻译变量、划词翻译、中译英（提高生产效率）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> efficiency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mathtype常用配置</title>
      <link href="2019/11/30/mathtype%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>2019/11/30/mathtype%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><pre><code>ctrl + L    下标ctrl + H    上标ctrl + B    向量 公式样式  原本快捷键和其他软件冲突了,重新设置新的即可Alt + B     math 样式</code></pre><h1 id="获取公式对应的LaTex格式-方便hexo博客使用"><a href="#获取公式对应的LaTex格式-方便hexo博客使用" class="headerlink" title="获取公式对应的LaTex格式 方便hexo博客使用"></a>获取公式对应的LaTex格式 方便hexo博客使用</h1><ol><li><p>mathtype 复制粘贴选项<br> 选择AMSTex 或者 MathML 2.0(no namespace)<br> <img src="/2019/11/30/mathtype常用配置/mathtype.png" alt="选项">   </p></li><li><p><strong>mathpix</strong> 截图识别公式<br>使用<a href="https://mathpix.com/" target="_blank" rel="noopener">mathpix</a>,简单高效</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> equation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傅里叶变换理解</title>
      <link href="2019/11/30/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%90%86%E8%A7%A3/"/>
      <url>2019/11/30/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#向量正交">向量正交</a></li><li><a href="#正交函数3">正交函数</a><ul><li><a href="#三角函数集合">三角函数集合</a></li><li><a href="#指数函数集合">指数函数集合</a></li></ul></li><li><a href="#傅里叶变换">傅里叶变换</a></li><li><a href="#拉式变换">拉式变换</a></li><li><a href="#z变换">z变换</a></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><p>用正交函数理解傅里叶变换，详细推到请看<sup><a href="#fn_4" id="reffn_4">4</a></sup></p><h2 id="向量正交"><a href="#向量正交" class="headerlink" title="向量正交"></a>向量正交</h2><p>向量正交：两个向量内积为0</p><script type="math/tex; mode=display">\langle {\bf{a} },{\bf{b} }\rangle  = 0</script><p>一个向量可以分解到一组正交基上（坐标系）</p><p>向量a在向量b上的投影长度</p><script type="math/tex; mode=display">c = { {\langle {\bf{a} },{\bf{b} }\rangle } \over {\langle {\bf{b} },{\bf{b} }\rangle } }</script><p>如果$b$是坐标轴上的单位向量或者方向沿着坐标轴方向，则$c$就是对应的坐标</p><h2 id="正交函数3"><a href="#正交函数3" class="headerlink" title="正交函数3"></a>正交函数<sup><a href="#fn_3" id="reffn_3">3</a></sup></h2><p>函数正交：两个函数内积为0,这是向量内积的推广,向量的元素足够多推广到积分</p><script type="math/tex; mode=display">\langle f,g\rangle  = 0</script><p>引入函数内积，在向量内积的基础上变成了积分（对应点的内积），这里是复变函数内积</p><script type="math/tex; mode=display">\left\langle g_{i}, g_{j}\right\rangle=\int_{i_{i}}^{t_{2}} g_{i}(t) \cdot g_{j}^{*}(t) d t</script><p>一个函数f在另一个函数g上的投影</p><script type="math/tex; mode=display">c_{i}=\frac{\left\langle f, g_{i}\right\rangle}{\left\langle g_{i}, g_{i}\right\rangle}=\frac{1}{k_{i}} \int_{t}^{t_{i}} f(t) \cdot g_{i}(t) d t</script><p>一个函数可以分解到一组完备正交函数集合上，三角函数集合和指数函数集合都是完备正交函数集合</p><h3 id="三角函数集合"><a href="#三角函数集合" class="headerlink" title="三角函数集合"></a>三角函数集合</h3><p>三角函数分解</p><script type="math/tex; mode=display">\begin{array}{l}{f(t)=a_{0}+\sum_{n=1}^{+\infty} a_{n} \cos n \omega_{1} t+\sum_{n=1}^{+\infty} b_{n} \sin n \omega_{1} t} \\ {a_{0}=\frac{\langle f, 1\rangle}{\langle 1,1\rangle}=\frac{1}{T_{1}} \int_{t_{0}}^{t_{0}+T_{1}} f(t) d t} \\ {a_{n}=\frac{\left\langle f, \cos n \omega_{1} t\right\rangle}{\left\langle\cos n \omega_{1} t, \cos n \omega_{1} t\right\rangle}=\frac{2}{T_{1}} \int_{t_{0}}^{t_{0}+T_{1}} f(t) \cdot \cos n \omega_{1} t d t} \\ {b_{n}=\frac{\left\langle f, \sin n \omega_{1} t\right\rangle}{\left\langle\sin n \omega_{1} t, \sin n \omega_{1} t\right\rangle}=\frac{2}{T_{1}} \int_{t_{0}}^{t_{0}+T_{1}} f(t) \cdot \sin n \omega_{1} t d t}\end{array}</script><p>其中</p><script type="math/tex; mode=display">\omega_{1}=\frac{2 \pi}{T_{1}}</script><h3 id="指数函数集合"><a href="#指数函数集合" class="headerlink" title="指数函数集合"></a>指数函数集合</h3><p>指数函数分解</p><script type="math/tex; mode=display">\begin{aligned}\left\langle e^{j n \omega_{1} t}, e^{j m \omega_{1} t}\right\rangle &=\int_{t_{0}}^{t_{0}+T_{1}} e^{j n \omega_{1} t} \cdot e^{-j m \omega_{1} t} d t \\ &=\int_{t_{0}}^{t_{0}+T_{1}} e^{j(n-m) \omega_{1} t} d t=\left\{\begin{array}{ll}{T_{1}} & {n=m} \\ {0} & {n \neq m}\end{array}\right.\end{aligned}</script><p>则对应的函数分解为</p><script type="math/tex; mode=display">\begin{array}{l}{f(t)=\sum_{n=-\infty}^{+\infty} F_{n} e^{j n \omega_{1} t}} \\ {F_{n}=\frac{\left\langle f(t), e^{j n \omega_{1} t}\right\rangle}{\left\|e^{j n \omega_{1} t}\right\|_{2}}=\frac{1}{T_{1}} \int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \omega_{1} t} d t}\end{array}</script><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>周期无穷大，$\mathop {\lim }\limits_{ {T_1} \to \infty } {1 \over { {T_1} }} = {1 \over {2\pi } }dw$. 加和变成了积分，时间从0开始到无穷大，如下式所示，内层就是傅里叶变换，外层就是反变换</p><script type="math/tex; mode=display">\begin{array}{l}{f(t)=\sum_{n=-\infty}^{+\infty} \frac{1}{T_{1}} \int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \omega_{1} t} d t e^{j n \omega_{1} t}} \\ {f(t)=\frac{1}{2 \pi} \int_{-\infty}^{\infty} \int_{0}^{\infty} f(t) e^{-j \omega t} d t e^{j \omega t} d w}\end{array}</script><p>窗函数<sup><a href="#fn_1" id="reffn_1">1</a></sup>表达式如下</p><script type="math/tex; mode=display">\operatorname{rect}\left(\frac{t}{a}\right)=\Pi\left(\frac{t}{a}\right)=\left\{\begin{array}{ll}0, & \text { if }|t|>\frac{a}{2} \\\frac{1}{2}, & \text { if }|t|=\frac{a}{2} \\1, & \text { if }|t|<\frac{a}{2}\end{array}\right.</script><p>时域窗函数傅里叶变换</p><script type="math/tex; mode=display">\int_{-\infty}^{\infty} \operatorname{rect}(t) \cdot e^{-j 2 \pi f t} d t=\frac{\sin (\pi f)}{\pi f}=\operatorname{sinc}(f)</script><p>频域窗函数傅里叶反变换</p><script type="math/tex; mode=display">\frac{1}{2\pi} \int_{-\infty}^{\infty}  \operatorname{rect}(t) \cdot e^{j w t} d w=\frac{1}{2\pi}\int_{-\frac{a}{2}}^{\frac{a}{2}} e^{j w t} d w=\frac{\sin (\frac{a}{2}t)}{\pi t}=\frac{2}{a\pi}\operatorname{sinc}(\frac{a}{2}t)</script><p>从这里可以看出时域窗函数傅里叶变换是<code>Sinc function</code><sup><a href="#fn_2" id="reffn_2">2</a></sup>, 频域窗函数傅里叶反变换也是</p><h2 id="拉式变换"><a href="#拉式变换" class="headerlink" title="拉式变换"></a>拉式变换</h2><p>傅里叶变换要求时域绝对可积，为满足这个条件，在原函数前面乘一个指数衰减函数${e^{ - at}}$, $a$为满足收敛的任意实数。则傅里叶变换变成了</p><script type="math/tex; mode=display">X(s) = \int_0^\infty  x (t){e^{ - at}}{e^{ - jwt}}dt = \int_0^\infty  x (t){e^{ - (a + jw)t}}dt = \int_0^\infty  x (t){e^{ - st}}dt</script><p>拉式变换是傅里叶变换的推广，傅里叶变换是拉式变换在虚轴上的投影。</p><h2 id="z变换"><a href="#z变换" class="headerlink" title="z变换"></a>z变换</h2><p>连续时间傅里叶变换针对连续信号，拉式变换解决了函数不可积问题，针对离散信号，积分变成求和，傅里叶变换变换为$\sum_{n=-\infty}^{\infty} x[n] e^{-j \omega n}$同样函数需要满足绝对可和的条件，类似拉式变幻，这里乘${a^{ - n}}$,$a$为满足收敛的任意实数，则公式变为</p><script type="math/tex; mode=display">\sum\limits_{n =  - \infty }^\infty  x [n]{a^{ - n}}{e^{ - j\omega n}} = \sum\limits_{n =  - \infty }^\infty  x [n]{(a{e^{j\omega }})^{ - n}} = \sum\limits_{n =  - \infty }^\infty  x [n]{z^{ - n}}</script><p>$z = a{e^{j\omega }}$是极坐标形式复数，定义为离散信号的复频率。可以看出$z$是在复平面上是一个圆。傅里叶变换定义域在虚轴，$z$变换定义在圆上。</p><p>至于为什么$z$变换不像拉式变换那样乘${e^{ - an}}$的原因还不太理解，可以参考<sup><a href="#fn_5" id="reffn_5">5</a></sup>中的回到</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote id="fn_1"><sup>1</sup>. <a href="https://en.wikipedia.org/wiki/Rectangular_function" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rectangular_function</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://en.wikipedia.org/wiki/Sinc_function" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sinc_function</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://blog.csdn.net/Einstellung/article/details/77478203" target="_blank" rel="noopener">https://blog.csdn.net/Einstellung/article/details/77478203</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">纯干货数学推导_傅里叶级数与傅里叶变换</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. <a href="https://www.zhihu.com/question/22085329/answer/103926934" target="_blank" rel="noopener">https://www.zhihu.com/question/22085329/answer/103926934</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu解压文件名字无法显示中文(中文乱码)</title>
      <link href="2019/11/23/ubuntu%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>2019/11/23/ubuntu%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<ol><li><p>zip解压文件名乱码</p><p> 由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等。因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。</p><pre><code> unzip -O gbk xxx.zip         unzip -O gbk xxx.zip -d xxx  ## 解压到指定文件夹    </code></pre></li><li><p>gedit 文件内容乱码 </p><pre><code> gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&#39;UTF-8&#39;,&#39;CURRENT&#39;,&#39;GB18030&#39;,&#39;ISO-8859-15&#39;,&#39;UTF-16&#39;]&quot;</code></pre></li><li><p>vim 中文乱码</p><pre><code> # 建议修改本地配置文件 sudo gedit /etc/vim/vimrc   # 系统配置文件 sudo gedit .vimrc   # 本地配置文件 # 增加下面内容 set fileencodings=utf-8,gb2312,gbk,gb18030 set termencoding=utf-8 set encoding=prc        </code></pre></li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://blog.csdn.net/weixin_40009624/article/details/79019907" target="_blank" rel="noopener">ubuntu 16.4解压中文名文件夹，中文乱码</a>      </li><li><a href="https://blog.csdn.net/w7619370/article/details/53024281" target="_blank" rel="noopener">Ubuntu 16.04 解压缩zip文件中文乱码</a>    </li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt记录</title>
      <link href="2019/11/22/qt%E7%BA%AA%E8%A6%81/"/>
      <url>2019/11/22/qt%E7%BA%AA%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>不清楚多看qt帮助文档,介绍非常详细</p><h1 id="常用函数使用"><a href="#常用函数使用" class="headerlink" title="常用函数使用"></a>常用函数使用</h1><ol><li><p>QString的arg()函数可以自动替换掉QString中出现的占位符。</p><pre><code> QString(&quot;[%1, %2]&quot;).arg(x).arg(y); // 加粗居中 QString(&quot;&lt;center&gt;&lt;h1&gt;Press:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(QString::number(event-&gt;x()),QString::number(event-&gt;y())); // 数字转字符串也可以用 QString::number(num);</code></pre></li><li><p>打印<br> 打印出错信息</p><pre><code> #define cout qDebug() &lt;&lt; &quot;[&quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt;&quot;]&quot;</code></pre><p> \n正常表示(换行)</p><pre><code> qDebug().noquote() &lt;&lt; str;  //直接用qDebug() \r和\n都不能正常显示             </code></pre></li><li><p>event事件<br> <strong>event()函数主要用于事件的分发</strong></p><p> 事件处理之后一定要调用父类相应事件处理函数,不然信号就不会继续往后穿,或者使用ignore()函数,如果使用accept()函数就相当如接受信号,不继续传</p><p> 事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）</p><pre><code> bool CustomWidget::event(QEvent *e) {     if (e-&gt;type() == QEvent::KeyPress) {         QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(e);//强制类型转换         if (keyEvent-&gt;key() == Qt::Key_Tab) {             qDebug() &lt;&lt; &quot;You press tab.&quot;;             return true;         }     }     return QWidget::event(e);//必要的，重新处理其他事件 }</code></pre><ul><li>如果传入事件被处理,需要返回true,否则返回false,那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</li><li><p>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。</p><p>可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；<strong>对于其它我们不关心的事件，则需要调用父类的event()函数继续转发</strong>，否则这个组件就只能处理我们定义的事件了。</p><p><strong>注意:</strong>QWidget中有一个mouseTracking属性,该属性用于设置是否追踪鼠标,默认是false(至少鼠标点击一次才会追踪).只有鼠标被追踪时,mouseMoveEvent()才会发出.</p><p>  EventLabel *label = new EventLabel;<br>  label-&gt;setMouseTracking(true);</p></li></ul></li><li><p>控制调用触发信号<br> 比如模拟按钮点击效果</p><pre><code> ui.pushButton-&gt;clicked();  </code></pre><p> 获取所有button</p><pre><code> QList&lt;QPushButton *&gt;  m_button_list = this-&gt;findChildren&lt;QPushButton *&gt;();</code></pre></li></ol><h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><p>Qt 的绘图系统: 使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</p><p>绘图设备是指继承QPainterDevice的子类.</p><ul><li>QPixmap   针对屏幕进行了优化,和平台相关,不能对图片进行修改</li><li>QBitmap QBitmap是QPixmap的一个子类，它的色深限定为1(只有两种状态,黑白),可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap.</li><li>QImage    和平台无关,可以对图片进行修改,可以在线程中绘图,专门为图像的像素级访问做了优化。</li><li>QPicture  保存绘图的状态(<strong>二进制文件</strong>),记录和重现  </li></ul><p>QImage与QPixmap之间的转换:</p><pre><code>fromImagetoImage </code></pre><h2 id="Graphics-View-Framework-提供了一种接口，用于管理大量自定义的-2D-图形元素，并与之进行交互"><a href="#Graphics-View-Framework-提供了一种接口，用于管理大量自定义的-2D-图形元素，并与之进行交互" class="headerlink" title="Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互"></a>Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互</h2><p>如果你的图像中包含了成千上万的直线、多边形之类，管理这些对象要比管理QPainter的绘制语句容易得多。并且，<br>这些图形对象也更加符合面向对象的设计要求：一个很复杂的图形可以很方便的复用。</p><h1 id="非模态对话框析构"><a href="#非模态对话框析构" class="headerlink" title="非模态对话框析构"></a>非模态对话框析构</h1><p>设置对话框属性即可,避免子函数结束造成对话框对象析构,<br>或者堆上创建对象一直存在(设置父对象容易造成对话框一直占用资源)</p><pre><code>dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);</code></pre><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>读取:</p><ul><li>QDataStream:二进制文件读取  </li><li>QTextStream:自动将 Unicode 编码同操作系统的编码进行转换;也会将换行符进行转换 </li></ul><p>有关文件本身信息,可以通过QFileInfo获取</p><pre><code>QFileInfo info(file);qDebug() &lt;&lt; info.baseName();                        // 获取应用程序执行时的当前路径QDir::currentPath()</code></pre><p><strong>最好使用 Qt 整型来进行读写,比如程序中的qint32.<br>这保证了在任意平台和任意编译器都能够有相同的行为.</strong></p><h2 id="魔术数字"><a href="#魔术数字" class="headerlink" title="魔术数字"></a>魔术数字</h2><p>二进制输出中经常使用的一种技术,放在文件开头用于标示文件</p><p>二进制格式是人不可读的，并且通常具有相同的后缀名(比如 dat 之类),<br>因此我们没有办法区分两个二进制文件哪个是合法的.<br>所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性.</p><h2 id="tcp实现简单文件传输"><a href="#tcp实现简单文件传输" class="headerlink" title="tcp实现简单文件传输"></a>tcp实现简单文件传输</h2><p><strong>数字和特定长度字符串相互转换</strong></p><pre><code>QString str = QString(&quot;%1&quot;).arg(10, 4, 10, QChar(&#39;0&#39;));qDebug() &lt;&lt;str&lt;&lt;&quot;num &quot;&lt;&lt;str.toInt();</code></pre><p>为防止TCP粘包,通常在开头增加一个或一组固定长度数字表示数据包的大小,类型(类型可用enum+switch)等</p><pre><code>//封包quint16 totalLen = numLen + buff.size();  //数据位长度可自定义,和一次读取大小有关QString lenStr = QString(&quot;%1&quot;).arg(totalLen, numLen, 10, QChar(&#39;0&#39;));buffSend.append(lenStr).append(buff);tcpsocket-&gt;write(buffSend);buffSend.clear();//解包quint16 lenMsg = QString(mybuffer.left(4)).toInt();QByteArray msg = mybuff.mid(numLen, lenMsg-numLen);mybuff = mybuff.right(mybuff.size()-lenMsg);  //总缓存区</code></pre><p>其实这里有考虑过使用QDataStream,但是由于通过”&lt;&lt;”写入会有其他信息,<br>导致大小不是想要的,通常使用writeRawData来避免  </p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code>robotarm = new robotArm();  //robotArm继承QObjectconnect(ui.pushButton, &amp;QPushButton::clicked, robotarm, &amp;robotArm::InitPos);QThread *pthread = new QThread(this);robotarm-&gt;moveToThread(pthread);pthread-&gt;start();</code></pre><h2 id="Qt信号自定义数据类型"><a href="#Qt信号自定义数据类型" class="headerlink" title="Qt信号自定义数据类型"></a>Qt信号自定义数据类型</h2><p>原生的信号与槽连接传参，只支持基本的数据类型，比如char,int, float,double.<br>直接使用自定义信号,比如结构体,类等编译不会报错,执行会报错<br>有两种方法</p><ol><li><p>注册自定义类型</p><pre><code> #include&lt;QMetaType&gt;        qRegisterMetaType&lt;joydata&gt;(&quot;joydata&quot;); //自定义类型对应的变量和名称</code></pre></li><li><p>使用直接连接方式<code>Qt::DrectConnection</code>,这种方式在需要把耗时槽函数放在子线程不适用(队列连接)</p><pre><code> connect(&amp;subThread,SIGNAL(ui.pushButton, &amp;QPushButton::clicked, robotarm, &amp;robotArm::InitPos, Qt::DrectConnection);</code></pre></li></ol><h2 id="QSharedMemory实现进程间通信"><a href="#QSharedMemory实现进程间通信" class="headerlink" title="QSharedMemory实现进程间通信"></a>QSharedMemory实现进程间通信</h2><p>分享端的逻辑：</p><p>1.创建一个QSharedMemory，并设置一个key值；</p><p>2.查看这个内存是不是被使用，如果被使用就断开；</p><p>3.调用create进行创建；(即使报已经存在也没关系,连接上照样使用)</p><p>4.使用memcpy把要写入的数据放入QSharedMemory中（内部一般会使用互斥锁技术，锁住资源）</p><p>读取端逻辑：</p><p>1.创建一个QSharedMemory，把key值设置为分享端相同的key值；</p><p>2.使用attach连接上这个QSharedMemory；(<strong>先调用isAttached()判断是否需要attach，如果已经attach则再调用attach会返回false</strong>)</p><p>3.以读取字节的方式读取QSharedMemory中的数据（内部一般会使用互斥锁技术，锁住资源）；</p><p>4.使用detach端口对这个QSharedMemory的连接。        </p><p><strong>注意：分享端create后会自动attach上,不用调用detach,否则共享内存直接释放掉了.<br>接收端每次attach,detach.需要保证始终有一个进程attach在sharedmemory上,通常是分享的一端</strong></p><p>分享端:</p><pre><code>m_shared_memory = new QSharedMemory(&quot;shared&quot;, this);if(m_shared_memory-&gt;isAttached()){    if(!m_shared_memory-&gt;detach()){        qDebug() &lt;&lt; &quot;shared memory detach failed&quot;;        return;    }}if(!m_shared_memory-&gt;create(1)){    qDebug()&lt;&lt;m_shared_memory-&gt;errorString()&lt;&lt;&quot; created failed!&quot;;    return;}m_shared_memory-&gt;lock();char *to = static_cast&lt;char*&gt;(m_shared_memory-&gt;data());char msg = &#39;L&#39;;memcpy(to, &amp;msg, 1);m_shared_memory-&gt;unlock();</code></pre><p>数据接受端:</p><pre><code>m_shared_memory = new QSharedMemory(&quot;shared&quot;, this);if(!m_shared_memory-&gt;isAttached()){    if(!m_shared_memory-&gt;attach()){        qDebug() &lt;&lt; &quot;attach shared memory failed&quot;;        return;    }}m_shared_memory-&gt;lock();char *to = static_cast&lt;char*&gt;(m_shared_memory-&gt;data());char msg = &#39;L&#39;;memcpy(to, &amp;msg, 1);m_shared_memory-&gt;unlock();m_shared_memory-&gt;detach();</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.cnblogs.com/tid-think/p/9300457.html" target="_blank" rel="noopener">Qt信号与槽传递自定义数据类型——两种解决方法</a></li><li><a href="https://it1995.blog.csdn.net/article/details/81738155?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5.control" target="_blank" rel="noopener">Qt工作笔记-进程间的通信（通过QSharedMemory）</a>                 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++函数指针</title>
      <link href="2019/11/16/c-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
      <url>2019/11/16/c-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="定义函数指针"><a href="#定义函数指针" class="headerlink" title="定义函数指针"></a>定义函数指针</h1><p>定义一个指针指向一个无参数无返回值的函数</p><pre><code>void (*funcPtr)();</code></pre><p><strong>大多数申明都是以右-左-右动作的方式工作</strong></p><p>针对复杂的定义,最好处理方式是从中间开始向外扩展.<br>“中间开始”(“funcPtr是一个…”),向右(没有东西,被括号挡住了),向左发现”*”(“…指针指向一个…”),向右发现空参数列表(“…没有带参数的函数…”),<br>向左发现void(“funcPtr是一个指针,它指向一个不带参数并返回void的函数)</p><p>这里<em>funcPtr需要括号是避免混淆 有void 指针<br>    void </em>funcPtr();    //一个返回void指针的函数,而不是一个变量</p><h1 id="复杂定义"><a href="#复杂定义" class="headerlink" title="复杂定义"></a>复杂定义</h1><pre><code>void * (*(*fp1)(int))[10];float (*(*fp2)(int,int,float))(int);typedef double (*(*(*fp3)())[10])();fp3 a;    int (*(*fp4())[10])();</code></pre><ul><li>fp1 是一个指向函数的指针,接受int参数,返回一个指向含有10个void指针数组的指针    </li><li>fp2 是一个指向函数的指针,该函数接受int,int,double,返回一个指向函数的指针,该函数接受int,返回float</li><li>fp3 指向函数的指针,该函数无参数,返回一个指向含有10个指向函数指针数组的指针,这些函数不接受参数且返回double 又定义a是ftp3类型的一个</li><li>fp4 是一个返回指针的函数,改指针指向含有10个函数指针的数组,这些函数返回整型值    </li></ul><h1 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h1><p>函数func()的地址 就是func 或者使用更加明显的语法&amp;func()</p><pre><code>void (*fp)() = func;</code></pre><p>指向函数的指针数组</p><pre><code>#define DF(N) void N() { cout &lt;&lt; &quot;function &quot; #N&quot; called...&quot; &lt;&lt;endl; }DF(a);DF(b);DF(c);void (*func_table[])() = {a,b,c};</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://book.douban.com/subject/6558198/" target="_blank" rel="noopener">C++编程思想</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make宏编译</title>
      <link href="2019/11/02/make%E5%AE%8F%E7%BC%96%E8%AF%91/"/>
      <url>2019/11/02/make%E5%AE%8F%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<ul><li>简化编译时所需要下达的指令;</li><li>若在编译完成之后,修改了某个原始码文件,<br>则 make 仅会针对被修改了的文件进行编译,其他的 object file不会被更动;</li><li>最后可以依照相依性来更新 (update) 执行档。</li></ul><h1 id="语法变量"><a href="#语法变量" class="headerlink" title="语法变量"></a>语法变量</h1><pre><code>目标(target): 目标文件 1 目标文件 2&lt;tab&gt;gcc -o 欲建立的执行文件 目标文件 1 目标文件 2</code></pre><ul><li>在 makefile 当中的 # 代表批注;</li><li><tab> 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符;</tab></li><li>目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。 </li></ul><p>makefile 示例 两个target<br><strong>$@:代表目前的目标(target)</strong></p><pre><code>    main: main.o haha.o sin_value.o cos_value.o        gcc -o main main.o haha.o sin_value.o cos_value.o -lm    clean:        rm -f main main.o haha.o sin_value.o cos_value.o     # 简化重复内容之后如下    # $@:代表目前的目标(target)    LIBS = -lm    OBJS = main.o haha.o sin_value.o cos_value.o    main: ${OBJS}        gcc -o $@ ${OBJS} ${LIBS}    clean:        rm -f main ${OBJS}  </code></pre><p>调用</p><pre><code>    make  (make main)   #调用main对象    make clean          #调用clean    make clean main     #先clean 再main</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol><li>变量与变量内容以『=』隔开,同时两边可以具有空格;</li><li>变量左边不可以有 <tab> ,例如上面范例的第一行 LIBS 左边不可以是 <tab>;</tab></tab></li><li>变量与变量内容在『=』两边不能具有『:』<br>;</li><li>在习惯上,变数最好是以『大写字母』为主;</li><li>运用变量时,以 ${变量} 或 $(变量) 使用;</li><li>在该 shell 的环境变量是可以被套用的,例如提到的 CFLAGS 这个变数!</li><li><p>在指令列模式也可以给予变量。 </p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>gcc 在进行编译的行为时,会主动的去读取 CFLAGS 这个环境变量,所以,你可以直接在 shell<br>定义出这个环境变量,也可以在 makefile 文件里面去定义,更可以在指令列当中给予</p><p> CFLAGS=”-Wall” make clean main      #指令中指定 或者在makefile中定义变量<br>环境变量取用规则</p></li><li>make 指令列后面加上的环境变量为优先;</li><li>makefile 里面指定的环境变量第二;</li><li>shell 原本具有的环境变量第三。    </li></ol><h1 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h1><ol><li><p>diff  行对比</p><pre><code> diff -Naur passwd.old passwd.new &gt; passwd.patch    # 生成补丁文件 diff /etc/rc0.d/ /etc/rc5.d/                       # 比较布姆下相同文件名</code></pre></li><li><p>patch</p><p> 用来更新源码安装的源文件,使用规则</p><pre><code> patch -p 数字 &lt; patch_file patch -R  -p 数字 &lt; patch_file    #回复旧文件</code></pre><p> patch_file 第一行写的是这样:</p><pre><code> *** /home/guest/example/expatch.old</code></pre><p> 『patch -p0 &lt; patch_file 』时,则更新的文件是『 /home/guest/example/expatch.old 』,</p><p> 『patch -p1 &lt; patch_file』,则更新的文件为『home/guest/example/expatch.old』,</p><p> 『patch -p4 &lt; patch_file』则更新『expatch.old』</p><p> <strong>-pxx 那个 xx 代表『拿掉几个斜线(/)』的意思!</strong>  </p></li><li>cmp 字节对比 可以用来对比binary             <h1 id="动态函数库-so-静态函数库-a"><a href="#动态函数库-so-静态函数库-a" class="headerlink" title="动态函数库.so  静态函数库.a"></a>动态函数库.so  静态函数库.a</h1>将常用到的动态函式库先加载内存当中 (快取, cache),需要 ldconfig 与 /etc/ld.so.conf协助</li><li>首先,我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』,注意喔, 是目录而不是文件;</li><li>接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中;</li><li><p>同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中</p><pre><code> ldconfig [-f conf] [ -C cache] ldconfig [-p]       #列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料!)</code></pre><p> 将动态函式库所在的目录名称写入<br> /etc/ld.so.conf.d/yourfile.conf 当中,然后执行 ldconfig 就可以  </p></li><li><p>查看可执行binary文件含有的动态函数库</p><pre><code> ldd [-vdr] [filename]      </code></pre><h1 id="检查软件正确性"><a href="#检查软件正确性" class="headerlink" title="检查软件正确性"></a>检查软件正确性</h1><p>目前广泛应用的加密机制 MD5 SHA1 SHA256 计算文件的指纹码</p></li></ol><p>md5sum/sha1sum/sha356sum</p><pre><code>md5sum/sha1sum/sha256sum [-bct] filename</code></pre><p>可以把Linux上的重要文件进行指纹数据库的建立,然后定期以shell script的方式检查    </p><h1 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h1><ol><li>缺少依赖库<br> 查看文件夹下对应的config.log 里面有对应的debug信息</li><li><p>没有那个文件或目录  X11/Intrinsic.h</p><pre><code> yum provides */Intrinsic.h   # 使用了正则表达式 需要头文件属于哪个包 安装就好            </code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1></li><li><a href="http://linux.vbird.org/new_linux.php" target="_blank" rel="noopener">鸟哥Linux基础</a>   </li><li><a href="https://blog.csdn.net/king_on/article/details/7799695" target="_blank" rel="noopener">xpenguins 的安装（问题来源于鸟哥基础篇）</a>        </li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 正则表达式</title>
      <link href="2019/11/02/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2019/11/02/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-的正则表达式"><a href="#Linux-的正则表达式" class="headerlink" title="Linux 的正则表达式"></a>Linux 的正则表达式</h1><p>Linux有两套库可以使用POSIX PCRE 前面一种是Linux自带的</p><ol><li><p>分隔符-分隔单词</p><pre><code> \&lt; \&gt; \&lt;[a-z]at\&gt;     # 后面这种行也会被匹配到  %$bat!* </code></pre><p> “单词”指的是两侧由非单词字符分隔的字符串.非单词字符指字母 数字 下划线之外的任何字符</p></li><li><p>位置匹配</p><pre><code> ^a      # a开头 t$      # t结尾</code></pre></li><li><p>重复</p><pre><code> *       重复0次或多次 +       重复1次或多次 ?       重复0次或者1次 {n}     重复n次 {n,}    重复n次或者更多 {n,m}   重复n-m次</code></pre></li><li><p>子表达式-分组</p><pre><code> egrep &quot;(or){2,}&quot;  xx/xx     # or重复2次或更多</code></pre></li><li><p>反义</p><p> 放在[]中,注意与匹配开头的 ^ 区别</p><pre><code> ^[^y]   # 不以字母y开头的所有行</code></pre></li><li><p>分支<br> 正则表达式简单执行”与”的组合 使用| 或者</p><pre><code> ^h|t&amp;   # h开头或者t结尾</code></pre></li><li><p>转义<br> \ 取消所有元字符的特殊含义</p><pre><code> \.  # 匹配.</code></pre></li><li><p>逆向引用</p><p> 子表达式(分组)捕获的内容可以在正则表达式的其他地方使用  使用 \1 表示引用第一个分组捕获内容</p><pre><code> (\&lt;.*\&gt;).?( )*\1    # 表示 匹配 某个单词出现后 紧跟0或1个标点符号以及任意多个空格后再次出现这个单词的行                                        </code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab中常见问题</title>
      <link href="2019/10/24/matlab%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>2019/10/24/matlab%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>matlab中sin(x) sind(x) </p><p> 都是计算正弦的函数　第一个输入单位为弧度　第二个为度</p><p> 对于特殊角的三角函数为有理数的　最好使用sind　很多时候为了保证计算精度会使用符号计算</p><pre><code> sin(pi) = 1.2246e-16 sind(180) = 0 vpa(sind(180),32) = 0.0   % 设置显示精度　32位</code></pre><p> 小数转为有理分式      </p><pre><code> rat(0.3)   </code></pre></li><li><p>关于reshape<br> reshape是按照列来重新排列 不要想当然 之前一个sigma_cube数据(1667x3 其中每个3x3是一个sigma)就是排错了   </p></li><li><p>多个数组生成全组合<br> <code>fullfact</code>, 有时候为了编译不相关变量和所有组合, 可以使用这个函数</p><pre><code> % 得到3组关节角度的全排列, 与使用循环是一致的 th1 = 0 : 1 : 10; th2 = 10 : 1 : 20; th3 = 20 : 1 : 30; index = fullfact([length(th1), length(th2), length(th3)]); spaceJoint = [th1(index(:, 1))&#39;, th2(index(:, 2))&#39;, th3(index(:, 3))&#39;];</code></pre></li><li><p>matlab变参数个数输入</p><ul><li>nargin: 参数个数</li><li><p>varargin: 函数输入元胞数组<br>参考<a href="https://ww2.mathworks.cn/help/matlab/matlab_prog/support-variable-number-of-inputs.html" target="_blank" rel="noopener">支持可变数量的输入</a></p><p>比如定义的写gif函数, 默认是追加方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function writeGif(gcf, file, varargin)</span><br><span class="line">switch nargin</span><br><span class="line">    case 2</span><br><span class="line">        init = false;</span><br><span class="line">    case 3</span><br><span class="line">        init = varargin&#123;1&#125;;</span><br><span class="line">end</span><br><span class="line">F = getframe(gcf);</span><br><span class="line">I = frame2im(F);</span><br><span class="line">[I, map] = rgb2ind(I, 256);</span><br><span class="line">timeDelay = 0.02;</span><br><span class="line">if init</span><br><span class="line">    imwrite(I, map, file, &apos;gif&apos;, &apos;Loopcount&apos;, inf, &apos;DelayTime&apos;, timeDelay);</span><br><span class="line">else</span><br><span class="line">    imwrite(I, map, file, &apos;gif&apos;, &apos;WriteMode&apos;, &apos;append&apos;, &apos;DelayTime&apos;, timeDelay);</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul></li><li><p>同时给多个变量赋值<code>deal</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Y1, Y2, Y3, ...] = deal(X) % copies the single input to all the requested outputs. It is the same as Y1 = X, Y2 = X, Y3 = X, ...</span><br><span class="line">[Y1, Y2, Y3, ...] = deal(X1, X2, X3, ...) % is the same as Y1 = X1; Y2 = X2; Y3 = X3; ...</span><br></pre></td></tr></table></figure></li><li><p>数据单维索引变换成二维索引<code>ind2sub</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = 3 * peaks;</span><br><span class="line">surf(data);</span><br><span class="line">[M, I] = max(data(:));</span><br><span class="line">[x, y] = ind2sub(size(data), I);</span><br><span class="line">P3 = arrow3([49 1 0], [y x data(x, y)], &apos;r2&apos;, 5, 5, 3);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘图</title>
      <link href="2019/10/24/%E7%BB%98%E5%9B%BE/"/>
      <url>2019/10/24/%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#matplotlib-绘图">matplotlib 绘图</a></li><li><a href="#matlab-绘图">matlab 绘图</a><ul><li><a href="#常用绘图命令">常用绘图命令</a><ul><li><a href="#命令查看">命令查看</a></li><li><a href="#图形窗口">图形窗口</a></li><li><a href="#坐标轴">坐标轴</a></li><li><a href="#文字标示">文字标示</a></li><li><a href="#栅格">栅格</a></li><li><a href="#图形覆盖保持">图形覆盖/保持</a></li><li><a href="#视角方向">视角方向</a></li><li><a href="#例子">例子</a></li></ul></li><li><a href="#遇到的问题">遇到的问题</a></li><li><a href="#参考">参考</a></li></ul></li></ul><!-- /code_chunk_output --><h1 id="matplotlib-绘图"><a href="#matplotlib-绘图" class="headerlink" title="matplotlib 绘图"></a>matplotlib 绘图</h1><p>NumPy 通常与 SciPy（Scientific Python）和 Matplotlib（绘图库）一起使用， 这种组合广泛用于替代 MatLab<br>使用参考<a href="https://matplotlib.org/stable/tutorials/index.html" target="_blank" rel="noopener">官方教程</a>中的<a href="https://matplotlib.org/stable/users/explain/quick_start.html#quick-start" target="_blank" rel="noopener">quick start</a><br>针对时间轴很坐标进行绘图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import matplotlib as mpl</span><br><span class="line">%matplotlib widget</span><br><span class="line"></span><br><span class="line">dates = np.arange(np.datetime64(&apos;2018-09-01 01:01:01.000000&apos;), np.datetime64(&apos;2018-09-01 01:01:02.200000&apos;),</span><br><span class="line">                  np.timedelta64(4, &apos;ms&apos;))</span><br><span class="line">data = np.random.random(len(dates))</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(dates, data, &quot;o&quot;)</span><br><span class="line">cdf = mpl.dates.ConciseDateFormatter(ax.xaxis.get_major_locator())</span><br><span class="line">ax.xaxis.set_major_formatter(cdf)</span><br></pre></td></tr></table></figure></p><h1 id="matlab-绘图"><a href="#matlab-绘图" class="headerlink" title="matlab 绘图"></a>matlab 绘图</h1><h2 id="常用绘图命令"><a href="#常用绘图命令" class="headerlink" title="常用绘图命令"></a>常用绘图命令</h2><h3 id="命令查看"><a href="#命令查看" class="headerlink" title="命令查看"></a>命令查看</h3><p>查看所有画图相关命令</p><pre><code>help graph2dhelp graph3d</code></pre><h3 id="图形窗口"><a href="#图形窗口" class="headerlink" title="图形窗口"></a>图形窗口</h3><pre><code>figure(n)    % 打开窗口nsubplot(m,n,p)   % m行n列窗口第p个</code></pre><h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><ul><li><p>axis([xmin xmax ymin ymax])</p></li><li><p>axis equal 使x,y轴的单位长度相同</p></li><li><p>axis square 出图为正方形</p></li><li><p>axis off 清除坐标刻度</p></li><li><p>semilogx,semilogy 绘制以x/y轴为对数坐标，以10为底，y/x轴为线性坐标的半对数坐标图形</p></li><li><p>loglog 绘制全对数坐标图，即x,y轴全取对数   </p></li></ul><h3 id="文字标示"><a href="#文字标示" class="headerlink" title="文字标示"></a>文字标示</h3><ul><li>text(x,y,‘字符串’) 在图形的指定坐标（x,y)处表示’字符串’中的内容</li><li>gtext(‘说明文字’）利用鼠标在图形的某一位置标示说明文字。执行完绘图命令后再执行gtext(‘说明文字‘）命令</li><li>title(‘字符串’）图形标题</li><li>xlabel(‘字符串‘),ylabel(‘字符串’),zlabel(‘字符串’)，设置x,y,z轴的坐标轴名称。如需输入特殊文字，用\开头</li><li>legend(‘字符串1’,‘字符串1’,‘字符串1’……）对图形上多条线按照绘图顺序进行说明 </li></ul><h3 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h3><ul><li>grid 给图形加栅格</li><li>grid on 给坐标系加栅格</li><li>grid off 删除当前坐标系的栅格</li><li>grid minor  细化栅格</li></ul><h3 id="图形覆盖-保持"><a href="#图形覆盖-保持" class="headerlink" title="图形覆盖/保持"></a>图形覆盖/保持</h3><ul><li>hold on 当前图形保持，且下条图形仍然绘制在该张图形上</li><li>hold off 新图覆盖旧图 </li></ul><h3 id="视角方向"><a href="#视角方向" class="headerlink" title="视角方向"></a>视角方向</h3><ul><li><p>view(az,el)                   给三维空间图形设置观察点的方位角az与仰角el</p></li><li><p>view([az,el])                 同上</p></li><li><p>view([x,y,z])                 将点(x,y,z)设置为视点</p></li><li><p>view(2)                       设置默认的二维形式视点，其中az = 0,el = 90,即从z轴上方观看</p></li><li><p><strong>view(3)</strong>                       设置默认的三维形式视点，其中az = -37.5, ell = 30</p></li><li><p>view(T)                       根据转换矩阵T设置视点，其中T为4*4阶的矩阵，如同用命令viewmtx生成的透视转换矩阵一样（注意：在2014版本中，这条命令好像没了）</p></li><li><p>[az,el]=view                  返回当前的方位角az与仰角el</p></li><li><p>T = view                      返回当前的4*4阶的转换矩阵T</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例子1</p><pre><code>clc;clear;close all;    % 清除变量　输入　关闭绘图scrsz = get(groot,&#39;ScreenSize&#39;);figure(&#39;Position&#39;,[1 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2]);  % 图像框为屏幕左上角1/4　像素limAxes = [-1.2 0.8 -1.1 0.9];xx = round(linspace(1,64,nbSamples));   % round 4舍5入clrmap = colormap(&#39;jet&#39;);clrmap = min(clrmap(xx,:),.95);colPegs = [[.9,.5,.9];[.5,.9,.5]];subplot(1,2,1); hold on; box on; title(&#39;Demonstrations&#39;);plot(b(1), b(2),&#39;.&#39;,&#39;markersize&#39;,30,&#39;color&#39;,colPegs(1,:)-[.05,.05,.05]);plot(Data(1,:), Data(2,:),&#39;-&#39;,&#39;linewidth&#39;,1.5,&#39;color&#39;,clrmap(n,:));axis(limAxes); axis square; set(gca,&#39;xtick&#39;,[],&#39;ytick&#39;,[]);  % 清除坐标轴刻度 axis off</code></pre><p>例子2</p><pre><code>f = figure;hold on;box on;P1 = plot(x, y,&#39;linewidth&#39;,1.2);P2 = plot(mean_force, 0,&#39;o&#39;,&#39;linewidth&#39;,1.2);   % 均值P3 = plot(threhold, 0,&#39;o&#39;,&#39;linewidth&#39;,1.2);   % 均值axis([0 28 0 0.14]);width = 240;   % 240pt  US letter 双栏 1pt = 1/72inch   1 inch = 25.4mmxlabel(&#39;\fontname{宋体}力模长\fontname{Times New Roman}(N)&#39;,&#39;Fontname&#39;, &#39;Times New Roman&#39;);% xlabel(&#39;Torque $M_x$ (Nm)&#39;,&#39;interpreter&#39;,&#39;latex&#39;,&#39;FontSize&#39;,8); % Latex格式的labelylabel(&#39;\fontname{宋体}概率&#39;,&#39;Fontname&#39;, &#39;Times New Roman&#39;);set(gcf,&#39;unit&#39;,&#39;points&#39;,&#39;PaperUnits&#39;,&#39;points&#39;,&#39;PaperPosition&#39;,[0,0,width,width/5*4],...    &#39;position&#39;,[500 300 width width/5*4],&#39;color&#39;,&#39;w&#39;,&#39;PaperSize&#39;,[width, width/5*4]);set(gca, &#39;Fontsize&#39;, 8);   % 坐标轴句柄，设置坐标轴刻度数字样式L1 = legend([P1 P2 P3],&#39;高斯分布&#39;,&#39;均值&#39;,&#39;阈值&#39;);set(L1,&#39;Location&#39;,&#39;northeast&#39;,&#39;Orientation&#39;,&#39;vertical&#39;,...    &#39;Fontname&#39;, &#39;宋体&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式% set(gca, &#39;XTick&#39;,0:4:20);  % 设置X轴刻度print(&#39;S:\PbD\graph\Force_threhold_change&#39;,&#39;-djpeg&#39;,&#39;-r600&#39;);</code></pre><p>legend 放置两排 需要鼠标拖动调整位置</p><pre><code>    L1 = legend([P1 P2 P3],&#39;X\fontname{宋体}变扰动力&#39;,&#39;Y\fontname{宋体}变扰动力&#39;,&#39;Z\fontname{宋体}变扰动力&#39;);    set(L1,&#39;Location&#39;,&#39;north&#39;,&#39;Orientation&#39;,&#39;horizontal&#39;,...        &#39;Fontname&#39;, &#39;Times New Roman&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式    ah=axes(&#39;position&#39;,get(gca,&#39;position&#39;),&#39;visible&#39;,&#39;off&#39;);    L2=legend(ah,[P4 P5 P6],&#39;X\fontname{宋体}恒扰动力&#39;,&#39;Y\fontname{宋体}恒扰动力&#39;,...        &#39;Z\fontname{宋体}恒扰动力&#39;,&#39;orientation&#39;,&#39;horizontal&#39;,&#39;location&#39;,&#39;north&#39;);    set(L2,    &#39;Fontname&#39;, &#39;Times New Roman&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式    set(L1,&#39;box&#39;,&#39;off&#39;);        % 根据需要可以去除legend边框    set(L2,&#39;box&#39;,&#39;off&#39;);</code></pre><p>去除图框白边    </p><pre><code>    set(gca,&#39;looseInset&#39;,[0 0 0 0]);       % 缩放坐标轴 去除图框白边 三维图不是很好用</code></pre><p>设置label等对象位置两种方式</p><pre><code>    x = xlabel(&#39;\fontname{宋体}力模长\fontname{Times New Roman}(N)&#39;);    set(x,&#39;Position&#39;,[0.1,0.1])    xlabel(&#39;\fontname{宋体}力模长\fontname{Times New Roman}(N)&#39;,&#39;Position&#39;,[0.1,0.1]);</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>想要坐标轴上的数据按照<code>小数点两边每三位留一个空格, 如1 234.567 8</code></p><p> 比如设置y轴数据为-5 000 和5 000</p><pre><code> set(gca, &#39;YTick&#39;,-5000:5000:8000, &#39;YTickLabel&#39;,{&#39;-5 000&#39;,&#39;0&#39;,&#39;5 000&#39;});</code></pre><p> <strong>如果使用其他操作可以参考matlab图像生成代码,然后根据生成的代码修改自己的绘图参数即可</strong></p><p> 使用代码定义好图像的大小和字体之后通过matlab的图像编辑器进行操作,<br> Edit -&gt; Axes Properties -&gt; 在Property Editor - Axes 中选中Ticks进行编辑<br> -&gt; 在Labels中需要的地方增加空格 -&gt; 退回图像编辑主窗口 -&gt; File -&gt; Generate Code</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/weixin_38452468/article/details/90171772" target="_blank" rel="noopener">Matlab常用绘图命令</a></li><li><a href="https://blog.csdn.net/seamanj/article/details/35790359" target="_blank" rel="noopener">MATLAB中的视角处理</a>     </li></ol>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用小技巧汇总</title>
      <link href="2019/10/20/%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
      <url>2019/10/20/%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="ps统一裁剪图片大小"><a href="#ps统一裁剪图片大小" class="headerlink" title="ps统一裁剪图片大小"></a>ps统一裁剪图片大小</h1><ol><li>窗口-&gt;动作　显示动作面板，在历史记录面板里面</li><li>新建动作组　录制动作</li><li>文件-&gt;自动-&gt;批处理</li></ol><p><strong>注意事项</strong>：<br>点击选项打开切换对话开关　可以在处理自动处理工程在裁剪处停止　手动调整裁剪的位置的大小</p><p><img src="/2019/10/20/实用小技巧汇总/切换对话开.png" alt="打开切换对话"> <img src="/2019/10/20/实用小技巧汇总/切换对话关.png" alt="关闭切换对话"></p><h1 id="ps矫正扫描件-ppt"><a href="#ps矫正扫描件-ppt" class="headerlink" title="ps矫正扫描件　ppt"></a>ps矫正扫描件　ppt</h1><p>扫描件</p><ul><li>复制图层　填充为白色　拉直工具(在不改变图像大小的情况下拉直)</li></ul><p>ppt</p><ul><li>透视裁剪 </li></ul><h1 id="视屏调整大小"><a href="#视屏调整大小" class="headerlink" title="视屏调整大小"></a>视屏调整大小</h1><ul><li>premiere 更改视频码率　选可变码率　</li></ul><p>码率：视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率</p><ul><li>固定码率：　</li><li>可变码率：视频信源本身的高峰信息量是变化的，能按信源本身的信息量去分配，从而有效地利用信息资源。</li></ul><h1 id="存放小文件到github方便下载"><a href="#存放小文件到github方便下载" class="headerlink" title="存放小文件到github方便下载"></a>存放小文件到github方便下载</h1><p>仓库名网址/archive/master.zip 即可下载仓库内容 不用到仓库地址点击下载</p><p>例如博客 <a href="/2019/12/22/ubuntu下wps缺少字体/" title="ubuntu下wps缺少字体">ubuntu下wps缺少字体</a> 中对应的下载字体<br><a href="https://github.com/yangbenbo/wps-font-symbols/archive/master.zip" target="_blank" rel="noopener">https://github.com/yangbenbo/wps-font-symbols/archive/master.zip</a></p><h1 id="markdown文件转pdf"><a href="#markdown文件转pdf" class="headerlink" title="markdown文件转pdf"></a>markdown文件转pdf</h1><p>安装chorme插件<a href="https://chrome.google.com/webstore/search/markdown?hl=en-US" target="_blank" rel="noopener">Markdown Preview Plus</a>,<br><strong>在插件detail中打开权限:Allow access to file URLs</strong>,然后浏览器打开文件即可预览,然后直接打印为pdf,注意需要选择A4或其他需要的类型</p><h1 id="文献管理zotero"><a href="#文献管理zotero" class="headerlink" title="文献管理zotero"></a>文献管理zotero</h1><p>开源软件<a href="https://www.zotero.org/" target="_blank" rel="noopener">zotera</a>可以很方便实现文献管理, 安装插件实现更多功能</p><ul><li>zotero-pdf-translate<br>  github搜索后下载<code>xpi</code>文件, 进入zotero 选择工具-&gt;附加组件-&gt;install add-on from file进行安装</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="http://www.sohu.com/a/258392499_99914465" target="_blank" rel="noopener">ps实用技能：如何统一裁剪图片大小</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯分布</title>
      <link href="2019/10/16/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83/"/>
      <url>2019/10/16/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="高斯分布表达式"><a href="#高斯分布表达式" class="headerlink" title="高斯分布表达式"></a>高斯分布表达式</h1><h3 id="一元高斯分布"><a href="#一元高斯分布" class="headerlink" title="一元高斯分布"></a>一元高斯分布</h3><script type="math/tex; mode=display">\mathcal{N}\left(x | \mu, \sigma^{2}\right)=\frac{1}{\left(2 \pi \sigma^{2}\right)^{\frac{1}{2}}} \exp \left\{-\frac{1}{2 \sigma^{2}}(x-\mu)^{2}\right\}</script><h3 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h3><script type="math/tex; mode=display">\mathcal{N}(\boldsymbol{x} | \boldsymbol{\mu}, \mathbf{\Sigma})=\frac{1}{(2 \pi)^{\frac{D}{2}}} \frac{1}{|\boldsymbol{\Sigma}|^{\frac{1}{2}}} \exp \left\{-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right\}</script><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>高斯分布依赖于下面二次型，即马氏距离</p><script type="math/tex; mode=display">\Delta^{2}=(\boldsymbol{x}-\boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})</script><p>协方差矩阵$\sum $可以取对称矩阵，<strong>任何非对称项都会从指数中消失</strong>（也可以从协方差矩阵定义看）可分解成对角矩阵</p><script type="math/tex; mode=display"></script><p>\begin{array}{l}{\Delta^{2}=[(\vec{X}-\vec{\mu})]^{\top}\left(Q \Lambda Q^{\top}\right)^{-1}[(\vec{X}-\vec{\mu})]} \\ {=\left[Q^{\top}(\vec{X}-\vec{\mu})\right]^{\top} \Lambda^{-1}\left[Q^{\top}(\vec{X}-\vec{\mu})\right]} \\ {=\left[Q^{\top}(\vec{X}-\vec{\mu})\right]^{\top}\left(\Lambda^{-\frac{1}{2}}\right)^{\top} \Lambda^{-\frac{1}{2}}\left[Q^{\top}(\vec{X}-\vec{\mu})\right]} \\ {=\left[\Lambda^{-\frac{1}{2}} Q^{\top}(\vec{X}-\vec{\mu})\right]^{\top}\left[\begin{array}{c}{\Lambda^{-\frac{1}{2}} Q^{\top}(\vec{X}-\vec{\mu})}\end{array}\right]} \\ {=\left[\left(Q \Lambda^{-\frac{1}{2}}\right)^{\top}(\vec{X}-\vec{\mu})\right]^{\top}\left[\left(Q \Lambda^{-\frac{1}{2}}\right)^{\top}(\vec{X}-\vec{\mu})\right]}\end{array}</p><script type="math/tex; mode=display"></script><p>含义：高斯分布中心在u,平移u之后高斯分布中心到原点，高斯分布椭圆轴拉伸变换成正圆，称一个旋转矩阵，将之前椭圆轴方向旋转到全局坐标系(Oxyz)，特别注意：变换矩阵Q</p><p>椭圆中心u,轴方向：变换矩阵Q的列向量<br><img src="/2019/10/16/高斯分布/高斯分布.png" alt="高斯分布"></p><h1 id="条件高斯分布"><a href="#条件高斯分布" class="headerlink" title="条件高斯分布"></a>条件高斯分布</h1><p>多元⾼斯分布的⼀个重要性质是，如果两组变量是联合⾼斯分布，那么以⼀组变量为条件，<br>另⼀组变量同样是⾼斯分布。类似地，任何⼀个变量的边缘分布也是⾼斯分布</p><h2 id="协方差矩阵-amp-精度矩阵-amp-分块矩阵求逆"><a href="#协方差矩阵-amp-精度矩阵-amp-分块矩阵求逆" class="headerlink" title="协方差矩阵&amp;精度矩阵&amp;分块矩阵求逆"></a>协方差矩阵&amp;精度矩阵&amp;分块矩阵求逆</h2><script type="math/tex; mode=display">\Sigma=\left(\begin{array}{cc}{\Sigma_{a a}} & {\Sigma_{a b}} \\ {\Sigma_{b a}} & {\Sigma_{b b}}\end{array}\right), \quad A=\left(\begin{array}{cc}{A_{a}} & {A_{b}} \\ {A_{b a}} & {A_{b b}}\end{array}\right), A=\Sigma^{-}</script><p>分块矩阵求逆</p><script type="math/tex; mode=display">\left(\begin{array}{cc}{\boldsymbol{A}} & {\boldsymbol{B}} \\ {\boldsymbol{C}} & {\boldsymbol{D}}\end{array}\right)^{-1}=\left(\begin{array}{cc}{\boldsymbol{M}} & {-\boldsymbol{M B D}^{-1}} \\ {-\boldsymbol{D}^{-1} \boldsymbol{C M}} & {\boldsymbol{D}^{-1}+\boldsymbol{D}^{-1} \boldsymbol{C M B D}^{-1}}\end{array}\right)</script><p>其中 $M=\left(A-B D^{-1} C\right)^{-}$</p><h2 id="完全平方项"><a href="#完全平方项" class="headerlink" title="完全平方项"></a>完全平方项</h2><p>通过对比二次型找到均值何方差的表达式</p><p>分解式如下</p><script type="math/tex; mode=display">\begin{aligned}-\frac{1}{2}(& \boldsymbol{x}-\boldsymbol{\mu}^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})=\\ &-\frac{1}{2}\left(\boldsymbol{x}_{a}-\boldsymbol{\mu}_{a}\right)^{T} \boldsymbol{\Lambda}_{a a}\left(\boldsymbol{x}_{a}-\boldsymbol{\mu}_{a}\right)-\frac{1}{2}\left(\boldsymbol{x}_{a}-\boldsymbol{\mu}_{a}\right)^{T} \boldsymbol{\Lambda}_{a b}\left(\boldsymbol{x}_{b}-\boldsymbol{\mu}_{b}\right) \\ &-\frac{1}{2}\left(\boldsymbol{x}_{b}-\boldsymbol{\mu}_{b}\right)^{T} \boldsymbol{\Lambda}_{b a}\left(\boldsymbol{x}_{a}-\boldsymbol{\mu}_{a}\right)-\frac{1}{2}\left(\boldsymbol{x}_{b}-\boldsymbol{\mu}_{b}\right)^{T} \boldsymbol{\Lambda}_{b b}\left(\boldsymbol{x}_{b}-\boldsymbol{\mu}_{b}\right) \end{aligned}</script><p>二次型</p><script type="math/tex; mode=display">-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})=-\frac{1}{2} \boldsymbol{x}^{T} \boldsymbol{\Sigma}^{-1} \boldsymbol{x}+\boldsymbol{x}^{T} \boldsymbol{\Sigma}^{-1} \boldsymbol{\mu}+\text {const}_{-} \text {value}</script><p>条件概率均值和协方差</p><script type="math/tex; mode=display">\begin{array}{l}{\mu_{a b}=\mu_{a}+\Sigma_{a b} \Sigma_{b b}^{-1}\left(x_{b}-\mu_{b}\right)=\mu_{a}-H_{a b}^{-1} A_{b b}\left(x_{b}-\mu_{b}\right)} \\ {\Sigma_{a b}=\Sigma_{a a}-\Sigma_{a b} \Sigma_{b b}^{-1} \Sigma_{b a}=\Lambda_{b b}^{-1}}\end{array}</script><h1 id="边缘高斯分布"><a href="#边缘高斯分布" class="headerlink" title="边缘高斯分布"></a>边缘高斯分布</h1><script type="math/tex; mode=display">p\left(\boldsymbol{x}_{a}\right)=\int p\left(\boldsymbol{x}_{a}, \boldsymbol{x}_{b}\right) \mathrm{d} \boldsymbol{x}_{b}</script><p>分解式对变量Xb积分</p><p>关于Xb的项</p><script type="math/tex; mode=display">-\frac{1}{2} \boldsymbol{x}_{b}^{T} \boldsymbol{\Lambda}_{b b} \boldsymbol{x}_{b}+\boldsymbol{x}_{b}^{T} \boldsymbol{m}=-\frac{1}{2}\left(\boldsymbol{x}_{b}-\boldsymbol{\Lambda}_{b b}^{-1} \boldsymbol{m}\right)^{T} \boldsymbol{\Lambda}_{b b}\left(\boldsymbol{x}_{b}-\boldsymbol{\Lambda}_{b b}^{-1} \boldsymbol{m}\right)+\frac{1}{2} \boldsymbol{m}^{T} \boldsymbol{\Lambda}_{b b}^{-1} \boldsymbol{m}</script><p>其中 $\boldsymbol{m}=\boldsymbol{\Lambda}_{b b} \boldsymbol{\mu}_{b}-\boldsymbol{\Lambda}_{b a}\left(\boldsymbol{x}_{a}-\boldsymbol{\mu}_{a}\right)$<br>容易求得变量的积分 现在看剩余部分变量Xa和常量</p><script type="math/tex; mode=display">\begin{array}{l}{\frac{1}{2}\left[\boldsymbol{A}_{b b} \boldsymbol{\mu}_{b}-\boldsymbol{A}_{b a}\left(\boldsymbol{x}_{a}-\boldsymbol{\mu}_{a}\right)\right]^{T} \boldsymbol{A}_{b b}^{-1}\left[\boldsymbol{A}_{b b} \boldsymbol{\mu}_{b}-\boldsymbol{A}_{b a}\left(\boldsymbol{x}_{a}-\boldsymbol{\mu}_{a}\right)\right]-\frac{1}{2} \boldsymbol{x}_{a}^{T} \boldsymbol{\Lambda}_{a a} \boldsymbol{x}_{a}+\boldsymbol{x}_{a}^{T}\left(\boldsymbol{A}_{a a} \boldsymbol{\mu}_{a}+\boldsymbol{A}_{b b} \boldsymbol{\mu}_{b}\right)+\text {const}_{-} \text {value}} \\ {=-\frac{1}{2} \boldsymbol{x}_{a}^{T}\left(\boldsymbol{A}_{a a}-\boldsymbol{A}_{a b} \boldsymbol{A}_{b b}^{-1} \boldsymbol{h}_{b a}\right) \boldsymbol{x}_{a}+\boldsymbol{x}_{a}^{T}\left(\boldsymbol{A}_{a b} \boldsymbol{A}_{b b}^{-1} \boldsymbol{A}_{b a}\right) \boldsymbol{\mu}_{a}+\text {const}_{-} \text {value }}\end{array}</script><p>通过对比得</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{E}\left[\boldsymbol{x}_{a}\right] &=\boldsymbol{\mu}_{a} \\ \operatorname{cov}\left[\boldsymbol{x}_{a}\right] &=\boldsymbol{\Sigma}_{a a} \end{aligned}</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对联合高斯分布</p><script type="math/tex; mode=display">\begin{array}{l}{\mathcal{N}(\boldsymbol{x} | \boldsymbol{\mu}, \Sigma)} \\ {x=\left(\begin{array}{l}{x_{a}} \\ {x_{b}}\end{array}\right), u=\left(\begin{array}{l}{\boldsymbol{\mu}_{a}} \\ {\boldsymbol{\mu}_{b}}\end{array}\right)} \\ {\boldsymbol{\Sigma}=\left(\begin{array}{cc}{\boldsymbol{\Sigma}_{a a}} & {\boldsymbol{\Sigma}_{a b}} \\ {\boldsymbol{\Sigma}_{b a}} & {\boldsymbol{\Sigma}_{b b}}\end{array}\right), \quad \boldsymbol{A}=\left(\begin{array}{cc}{\boldsymbol{A}_{a a}} & {\boldsymbol{A}_{b b}} \\ {\boldsymbol{A}_{b a}} & {\boldsymbol{A}_{b b}}\end{array}\right), \boldsymbol{A}=\boldsymbol{\Sigma}^{-}}\end{array}</script><p>条件概率</p><script type="math/tex; mode=display">\begin{aligned} p\left(\boldsymbol{x}_{a} | \boldsymbol{x}_{b}\right) &=\mathcal{N}\left(\boldsymbol{x}_{a} | \boldsymbol{\mu}_{a | b}, \mathbf{\Lambda}_{a a}^{-1}\right) \\ \boldsymbol{\mu}_{a | b} &=\boldsymbol{\mu}_{a}-\boldsymbol{\Lambda}_{a a}^{-1} \mathbf{\Lambda}_{a b}\left(\boldsymbol{x}_{b}-\boldsymbol{\mu}_{b}\right) \end{aligned}</script><p>边缘概率</p><script type="math/tex; mode=display">p\left(\boldsymbol{x}_{a}\right)=\mathcal{N}\left(\boldsymbol{x}_{a} | \boldsymbol{\mu}_{a}, \boldsymbol{\Sigma}_{a a}\right)</script><p><img src="/2019/10/16/高斯分布/条件边缘.png" alt="条件概率和边缘概率"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://www.microsoft.com/en-us/research/people/cmbishop/" target="_blank" rel="noopener">Pattern Recognition and Machine Learning</a></li><li><a href="https://zhuanlan.zhihu.com/p/58987388" target="_blank" rel="noopener">多元高斯分布完全解析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用软件快捷键</title>
      <link href="2019/10/07/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2019/10/07/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#ubuntu">ubuntu</a></li><li><a href="#qtcreator">qtcreator</a></li><li><a href="#visual-studio-code">visual studio code</a><ul><li><a href="#jupyter">jupyter</a></li><li><a href="#vscode-常用技巧">vscode 常用技巧</a></li><li><a href="#code配置c环境">code配置c++环境</a></li><li><a href="#code-配置python环境">code 配置python环境</a></li></ul></li><li><a href="#typora">Typora</a><ul><li><a href="#导出word">导出word</a></li></ul></li><li><a href="#chorme">chorme</a></li><li><a href="#matlab">matlab</a></li><li><a href="#simulink">simulink</a></li><li><a href="#clion">clion</a><ul><li><a href="#debug">debug</a></li><li><a href="#其他">其他</a></li><li><a href="#可能存在的问题">可能存在的问题</a></li></ul></li><li><a href="#pycharm">pycharm</a></li><li><a href="#qtcreator-1">QtCreator</a></li><li><a href="#word">word</a></li><li><a href="#excel">excel</a></li><li><a href="#常用软件">常用软件</a></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h2><p>有的需要自行设置　Setting-&gt;Keyboard-&gt;Shortcuts</p><p>相比Windows快捷键,很多只是多增加了ctrl  </p><ul><li>shift+1 切换到左边工作区　</li><li>ctrl+shift+1 把当前窗口移动到左边工作区 </li><li>shift+2 切换到左边工作区　</li><li>ctrl+shift+2 把当前窗口移动到右边工作区 </li></ul><h2 id="qtcreator"><a href="#qtcreator" class="headerlink" title="qtcreator"></a>qtcreator</h2><p>自定义快捷键:tools-&gt;options-&gt;environment-&gt;keyboard</p><pre><code>Esc    切换到代码编辑状态F1    查看帮助F2    在光标选中对象的声明和定义之间切换F4    头文件和源文件之间切换F10    单步跳过F11    单步进入Ctrl + B    编译工程Ctrl + /    多行注释/取消多行注释Alt + Enter    将光标移动到h文件中的方法声明，按Alt+Enter，再按回车键将在cpp中添加对应的方法实体Ctrl + Shift + &lt;    折叠代码块Ctrl + Shift + &gt;    展开代码块Ctrl + Alt + .      全部折叠/展开代码(自定义)Alt + 左    光标返回到上一位置Alt + 右    光标前进到下一位置Alt + [1-7]   快速打开对应窗口,和clion类似Ctrl + Shift + U    查找所有使用该符号的地方Ctrl + Shift + R    局部变量统一修改（将光标移动到需要更改的变量上,按Ctrl+Shift+ R,当前变量名称外框为红色时,表示已经已激活全局修改功能,当修改此处变量名称时将一同修改代码中所有使用该变量的变量名。），全局变量开启全局替换窗口Ctrl + I    代码格式化Ctrl + [    跳到代码块的头部Ctrl + ]     跳到代码块的尾部</code></pre><h2 id="visual-studio-code"><a href="#visual-studio-code" class="headerlink" title="visual studio code"></a>visual studio code</h2><p><a href="https://code.visualstudio.com/docs/getstarted/tips-and-tricks#_intellisense" target="_blank" rel="noopener">Tips and Tricks</a></p><ul><li>Multi cursor selection<br>Alt+Click 增加鼠标光标位置, 可以同时编辑,键盘快捷键 Ctrl+Alt+Up or Ctrl+Alt+Down</li></ul><p>Ctrl+Shift+L 增加鼠标光标位置到选中变量对应的所有位置</p><p>Shift+Alt+鼠标从起始位置拖动到终点位置  Column (box) selection</p><p>查看快捷键如折叠代码: F1-&gt;fold -&gt; ctrl + k ctrl + ] (需要先切换到对应文件) </p><p>代码自动提示插件: C++ Intellisense  (这个插件和Clang是冲突的,一个就可以了,跳转需要在<code>c_cpp_properties.json</code>中配置头文件目录)</p><p>vscode 配置参考<a href="https://blog.csdn.net/weixin_35695879/article/details/85254422?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.control" target="_blank" rel="noopener">ros项目调试:vscode下配置开发ROS项目</a></p><p>code自带快捷键</p><pre><code>F1  打开命令面板(Ctrl + Shift + P)Ctrl + P：按路径查找文件（**输入“？”显示所有主要信息**，输入“&gt;”就变成输入命令模式）F2    重命名F7  编译cmake程序(安装cmake-tool)F11    全屏ctrl + shift + F10  Peek DefinitionF12         跳转到引用, 如果有多个定义则是Peek Definition窗口F9 增加/取消断点shift + F12 找到所用引用alt + up/down   上下移动行alt+leftArrow/rightArrow 来回切换鼠标前后经过位置alt + 1/2/3...  切换编辑窗口alt + O   源文件和头文件切换(可以查看快捷键设置找到 切换/switch)Ctrl + K Ctrl + 0：全部折叠Ctrl + K Ctrl + J：全部展开Ctrl + Shift + [    折叠代码块Ctrl + Shift + ]    展开代码块Ctrl + k + [    递归折叠代码块Ctrl + k + ]    递归展开代码块Ctrl + K Ctrl + [：折叠选中部分Ctrl + K Ctrl + ]：展开选中部分ctrl + F    当前文件中查找ctrl + shift + F    整个文件夹中查找ctrl + B    侧边栏显隐(具体那一栏展开可以把鼠标放上去就可以看到快捷键)ctrl + N    新建文件 可以现在资源管理器对应文件夹点一下,这样保存就会在这里ctrl + shift + N    打开新窗口以打开多个文件夹项目ctrl + shift L      选中当前文件所有匹配的字 同时修改 谨慎使用 不区分大小写ctrl + shift + G    git版本管控ctrl + alt + Q    显示关闭Toggle Sidebar, 之前时ctrl + B, 改了ctrl + `    打开终端Ctrl + , : 打开设置面板Ctrl + E：查找选定内容Shift + Alt + F：格式化文档Ctrl + K Ctrl + F：格式化选定内容Ctrl + [：行减少缩进,类似Tab与Shift+Tab，但是不用非得到行首或者选中整行，可以直接使用Ctrl + ]：行增加缩进Ctrl+H    替换Ctrl+Z    撤销Ctrl+Y    重做Ctrl+W    关闭当前页面Shift+Alt+鼠标左键  多行编辑Shift+Alt+↓/↑    向上/下复制当前行Ctrl+D    选中当前半高亮内容（多次点击可选中下一个匹配的半高亮内容）ctrl + \    向右拆分窗口ctrl + K, ctrl + \  向下差分窗口ctrl + k, ctrl + S  打开键盘快捷键设置# 自定义或者查看快捷键,有的快捷键和系统冲突了也要改File -&gt; Preferences -&gt; Keyboard Shortcuts</code></pre><p>debug<br>断点</p><ul><li>Conditional breakpoints, 增加断点后可以右键编辑设置条件触发之后在触发断点</li><li>Function breakpoints, 函数的第一行触发</li></ul><p>debug console中想使用gdb命令需要增加<code>-exec</code>前缀</p><p>code使用ipython,后缀名可以使.py</p><pre><code># %% 指明是代码模块# %% [markdown]  指明是markdown笔记模块 在正常笔记基础之上注释了而已,如下# %% [markdown]# ## test markdown# content    # 快捷键基本和code自带的一直shift + Enter   运行当前节,如果在最后使用则会增加一节   转格式为jupyter     右键保存为jupyter</code></pre><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p>code搭配jupyter<sup><a href="#fn_1" id="reffn_1">1</a></sup>, 文件后缀名.ipynb</p><p>快捷键如下</p><pre><code># jupyter相关Enter   转入编辑模式ESC     退出编辑模式M       单元转入markdown模式Y       单元转入代码模式up/down 上下单元选择A   上方插入新单元B   下方插入新单元D + D   删除当前单元Z   撤销操作, 命令模式针对单元格之间的操作(针对内部代码编辑撤销 ctrl + z)Alt + up/down   向上向下移动行ctrl + shift + Alt + up/down   向上向下复制行shift + delete  删除行shift + Enter   运行当前节并前进到下一节,如果到了最后一节会新建一节ctrl + Enter    运行本单元L       显示与隐藏单元行号ctrl + H    单元内查找与替换ctrl + shift + \    调到匹配的括号</code></pre><p><strong>开启代码提示功能</strong></p><p>文件-首选项-设置 中搜索“prevent”,取消选中“控制在活动代码片段内是否禁用快速建议”(Snippets Prevent Quick Suggestions),重启即可</p><p>资源管理器隐藏不必要文件(包括untracked git file), ctrl + , 进入设置,搜索exclude 修改Files:Exclude模式即可,可以看到.git是排除在外的</p><pre><code>    // .vscode/settings.json中修改,排除如下文件    &quot;files.exclude&quot;: {        &quot;**/*.pyc&quot;: true,    // 所有目录匹配        &quot;**/.ipynb_checkpoints&quot;: true,        &quot;*.idea&quot;: true    // 当前目录匹配    }    </code></pre><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li>python绘图使用subplots出现标题重叠的解决方法<br>在<code>plt.show()</code>前增加<code>plt.tight_layout()</code>用于调整子图间距</li></ol><h3 id="vscode-常用技巧"><a href="#vscode-常用技巧" class="headerlink" title="vscode 常用技巧"></a>vscode 常用技巧</h3><ul><li>同步配置<br>参考官网教程<a href="https://code.visualstudio.com/docs/editor/settings-sync" target="_blank" rel="noopener">Settings Sync</a>, 同步插件等各项配置, 避免更换环境之后重新配置</li><li><p>Box Selection</p><ol><li>鼠标指针选定box第一个位置, shift+alt+鼠标左键选中box第二个位置，实现整个box内同步编辑</li><li>ctrl + alt + UpArrow/downArrow 向上或者向下多行一起边界选中</li></ol></li><li><p>Errors and worning<br>使用F8来回切换，待确认</p></li><li><p>vscode 记住密码<br>避免每次拉取代码都需要输入用户名和密码，在code终端输入<code>git config --global credential.helper store</code>命令，然后只需要输入1次代码，后续会自己记住</p></li></ul><h3 id="code配置c-环境"><a href="#code配置c-环境" class="headerlink" title="code配置c++环境"></a>code配置c++环境</h3><p>直接参考官网教程<a href="https://code.visualstudio.com/docs/cpp/config-mingw" target="_blank" rel="noopener">GCC on Windows</a>, 非常适合新手, 适当结合网上其他教程学习. 网上很多其他教程都是根据个人理解有删减所以不易理解<br>windows配置中文教程参考如下,建议不要自己直接复制配置文件, 需要搞清楚具体含义,否则出了问题也找不到</p><ul><li>运行环境参考<a href="https://blog.csdn.net/qq_45807140/article/details/112862592" target="_blank" rel="noopener">从零开始的vscode安装及环境配置教程(C/C++)(Windows系统)</a></li><li>MinGW配置参考<a href="https://blog.csdn.net/weixin_48468423/article/details/118950592" target="_blank" rel="noopener">VsCode安装和配置c/c++环境（超完整，小白专用）</a></li></ul><ol><li>配置编译环境, linux直接命令行<ul><li>官网下载<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/" target="_blank" rel="noopener">MinGW</a><br>翻到最下面, 优先选择<code>x86_64-posix-seh</code>, <ul><li>最上面是源代码,没有bin目录, 在线安装很慢 </li><li><code>x86-64</code>是64位系统用, <code>i686</code>是32位系统用</li><li><code>seh</code>结尾是纯64位编译器, <code>siji</code>包含32位和64位,但是需要增加参数-m32或者-m64;</li><li><code>posix</code>常用于跨平台,比win32兼容性更好</li></ul></li><li>增加系统环境变量: 搜索<code>编译系统环境变量</code>, 打开配置系统变量,再<code>path</code>中增加解压出来到<code>bin</code>目录</li></ul></li><li>vscode下载插件C/C++ 扩展,认准微软</li><li>生成c/c++配置文件: 告诉vscode编译器位置<br>F1 -&gt; C/C++编译配置 打开json文件 -&gt; 当前目录生成.vscode/c_cpp_properties.json文件 -&gt; 进入修改编译器路径为刚才的<code>bin</code>目录, <code>intelliSenseMode</code>选择<code>windows-gcc-x64</code></li><li>生成task文件:　选中c++源文件 -&gt; F5运行 -&gt; 选择C++(GDB/LLDB) -&gt; c/c++:g++.exe 生成活动文件</li><li>生成launch文件: 暂时不生成launch文件也能调试, 直接选中源文件 F5即可调试,断点都可以</li></ol><h3 id="code-配置python环境"><a href="#code-配置python环境" class="headerlink" title="code 配置python环境"></a>code 配置python环境</h3><p>下载<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python</a><br>code插件</p><ul><li>Code Runner</li><li>python</li></ul><p>python 模块</p><ul><li>matplotlib 绘图</li><li>SciPy 一个开源的 Python 算法库和数学工具包</li></ul><p>vscode可以终端运行python代码,选中代码行<code>shift enter</code>即会在python环境运行代码,相对而言只是代替复制粘贴(无法运行则需要首先输入<code>python</code>进入python环境终端)</p><p>python依赖的包比较多, 版本可能不兼容, 特别时迁移的时候就很麻烦, 可以使用终端一键导入<br>使用<strong>Requirements Files</strong><sup><a href="#fn_2" id="reffn_2">2</a></sup>, 实际测试发现并不是很好用, 当前还是记录了项目依赖的包进行单个安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt  # 在配置好的环境中导出依赖</span><br><span class="line">pip install -r requirements.txt # 在新环境中安装依赖</span><br></pre></td></tr></table></figure></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p><a href="https://typora.com.cn/" target="_blank" rel="noopener">Typora</a>是一款非常好用的markdown编辑器，内置了很多快捷键，比如插入表格等，甚至可以插入视频, <a href="https://blog.csdn.net/liyou123456789/article/details/122657783" target="_blank" rel="noopener">使用参考</a></p><p>标题(Ctrl+1(2，3，4，5，6))<br>字体(Ctrl+I斜体，Ctrl+B粗体)<br>源代码模式(Ctrl+/)<br>下划线(Ctrl+U)<br>删除线(Alt+Shift+5)<br>代码高亮(Ctrl+Shift+`)<br>代码段(Ctrl+Shift+K)<br>链接(Ctrl+K)<br>图片(Ctrl+C，Ctrl+V直接复制粘贴)<br>插入图片(Ctrl+Shift+I)<br>表格(Ctrl+T)<br>显示隐藏侧边栏(Ctrl+Shift+L)<br>显示大纲(Ctrl+Shift+1)<br>显示文档(Ctrl+Shift+2)<br>文档搜索(Ctrl+Shift+F)<br>内容搜索(Ctrl+F)</p><h3 id="导出word"><a href="#导出word" class="headerlink" title="导出word"></a>导出word</h3><p>markdown导出word可以避免公式二次编辑，虽然word自带的公式不好看<br><a href="https://blog.csdn.net/m0_37788308/article/details/78842540" target="_blank" rel="noopener">typora+pandoc: markdown互转word</a></p><p>下载<a href="https://github.com/jgm/pandoc/releases/tag/2.0.5" target="_blank" rel="noopener">pandoc</a>, windows选择<code>.msi</code>后缀，安装后重启typora就可以导出word了</p><h2 id="chorme"><a href="#chorme" class="headerlink" title="chorme"></a>chorme</h2><p>标签切换 ctrl+PgUp / ctrl+PgDn   (ctrl+Tab / ctrl+Shift+Tab)</p><h2 id="matlab"><a href="#matlab" class="headerlink" title="matlab"></a>matlab</h2><p>Ctrl+I  自动缩进（即自动排版，对多行有效）</p><p>F12     设置或取消断点</p><h2 id="simulink"><a href="#simulink" class="headerlink" title="simulink"></a>simulink</h2><p>打开模型浏览库： ctrl + shift + L</p><p>打开模型设置 ： Ctrl + H</p><p>视图放大：r</p><p>视图缩小：v</p><p>视图平铺到整个模型：空格/f</p><p>回到默认视图：1</p><p>用鼠标拖动视图：按住q或者p，用鼠标左键按住拖动。这个快捷键在视图比较大时候用到。</p><p>更新模型：ctrl+D</p><p>打开model explorer：ctrl+E</p><p>运行：ctrl+T</p><p>生成代码： ctrl+B</p><p>查看simple time： ctrl+J</p><p>按住ctrl 点击数据输入模块 和输出模块 会自动连线</p><h2 id="clion"><a href="#clion" class="headerlink" title="clion"></a>clion</h2><p>可以自行添加修改<br>Ctrl + Shift + D   //添加函数定义 Alt+Insert<br>Ctrl + Alt + home  // 设置-&gt;keymap-&gt;related symbol</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>鼠标放在变量上　查看变量值　ctrl+F1</p><p>F9 选择调试程序</p><p>shift+F9  //开始debug</p><p>ctrl+F9  //编译程序</p><p>ctrl+F2  //停止debug</p><p>ctrl+shift+F6    //evalute expression</p><p>ctrl+shift+S     //setting</p><p>ctrl+F8  //设置断点   ctrl+Shift+F8  断点详细设置　可以打开<strong>异常断点</strong>　抛出异常地方地址</p><p>调试的时候可以直接设置变量值</p><p>添加监视　watch</p><p>评估表达　即计算表达式的值　可把表达式值添加到watch ctrl+shift+enter</p><p>调试<code>#define PR(x) cout &lt;&lt; #x&quot;= &quot;&lt;&lt;x&lt;&lt;endl;</code>      之后直接调用  <code>PR(a)</code> 等效于<code>cout&lt;&lt;&quot;a= &quot;&lt;&lt;a&lt;&lt;endl;</code></p><p>clion还可以打开异常断点  抛出异常地方停止(默认打开的)</p><p>函数中使用<code>assert()</code>,如果想不启用  在<code>#include&lt;cassert&gt;</code> 前 <code>#define NDEBUG</code></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>F5  //运行程序</p><p>F10  //终止程序</p><p>shift+F10  //运行程序</p><p>ctrl+Tab+T  //调出clion终端</p><p>ctrl+D  //复制并粘贴对应行</p><p>Esc  //光标退回到程序界面，配合Alt+1 使用</p><p>ctrl+Home  //页面初始位置 End  多结合Ctrl 使用</p><p>ctrl+PageUp  //当前显示页面初始  PageDown</p><p>ctrl+Shift+F  //查找  ctrl+F</p><h3 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h3><ol><li>编译cmake出现错误.更改clion中的cmake为系统的  setting-&gt;Build,..-&gt;Toolchains-&gt;Cmake  选中~/bin/cmake</li><li>找不到路径（环境变量）的话需要在clion安装位置打开clion</li></ol><h2 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h2><ol><li>show execution point (F10)<br>显示目前项目所有断点</li><li>step over (F8)<br>下一步但仅限于设置断点的文件</li><li>step into (F7)<br>执行下一行</li><li>step into my code (Alt+Shift+F7)<br>执行下一行但忽略libraries（导入库的语句）</li><li>force step into (Alt+Shift+F7)<br>执行下一行忽略lib和构造对象等</li><li>step out (Shift+F8)<br>当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。</li><li>run to cursor (Alt+F9)<br>直接跳到下一个断点 </li></ol><h2 id="QtCreator"><a href="#QtCreator" class="headerlink" title="QtCreator"></a>QtCreator</h2><ol><li><p>帮助文件：F1 （光标在函数名字或类名上，按 F1 即可跳转到对应帮助文档，查看其详细用法）</p></li><li><p>.h 文件和对应.cpp 文件切换：F4</p></li><li><p>编译并运行：Ctrl + R</p></li><li><p>函数声明和定义(函数调用和定义)切换：F2</p></li><li><p>代码注释取消注释：Ctrl + / （选中代码再按快捷键）</p></li><li><p>字体变大变小：Ctrl + 鼠标滚轮向上向下</p></li><li><p>移动代码：选中所要移动的代码 -&gt; 按住 ctrl + shift -&gt; 键盘方向键</p></li><li><p>查找替换关键字：ctrl + f</p></li><li><p>快速打开代码所在目录：编辑模式下 -&gt; 选中项目文件 -&gt; 右击 -&gt; 选择“显示包含的目录”，即可显示项目所在目录（此方法同样可以打开代码文件所在目录）</p><h2 id="word"><a href="#word" class="headerlink" title="word"></a>word</h2></li></ol><p>Alt+Shift+ +　　　　　　扩展标题下的文本</p><p>Alt+Shift+ -　　　　　　折叠标题下的文本</p><p>F4      重复上一个操作，如果需要对图片进行类似格式刷的功能，可以批量插入图片，然后对其中一张进行调整，最后选中其他图片用F4即可</p><h2 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h2><p>Alt+Enter             换行</p><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><ol><li><strong>fbreader</strong>: linux 上epub阅读</li><li><strong>Mendley</strong>: 文献管理工具<br>免费；PDF的批注很好用，PDF文献识别准确率比NoteExpress好多了；有账号的话还可以多终端同步（外网使用效果好）<br>(缺点是对中文支持不好，识别的题目等都是乱码，需要手动粘贴 很麻烦)</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/desert187/article/details/23996821?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">详细，Qt Creator快捷键大全，附快捷键配置方法</a></li><li><a href="https://www.cnblogs.com/gwzz/p/13385076.html" target="_blank" rel="noopener">VSCode - Jupyter快捷键</a></li><li><a href="https://blog.csdn.net/sinat_21835983/article/details/93896664" target="_blank" rel="noopener">在Visual Studio Code中使用Jupyter Notebook</a></li><li><a href="https://blog.csdn.net/m0_37174192/article/details/99226127?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf" target="_blank" rel="noopener">VSCode+python中代码（函数）不提示的解决办法之一</a></li></ol><blockquote id="fn_1"><sup>1</sup>. <a href="https://code.visualstudio.com/docs/datascience/jupyter-notebooks" target="_blank" rel="noopener">https://code.visualstudio.com/docs/datascience/jupyter-notebooks</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://pip.pypa.io/en/stable/user_guide/" target="_blank" rel="noopener">https://pip.pypa.io/en/stable/user_guide/</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> simulink </tag>
            
            <tag> clion </tag>
            
            <tag> world </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS记录</title>
      <link href="2019/10/07/ROS%E8%AE%B0%E5%BD%95/"/>
      <url>2019/10/07/ROS%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>ros需要等待初始化完成，否则直接在话题上发布可能导致接受不到</strong></p><ol><li><p>urdf<br>通过SolidWorks插件导出的URDF文件，它默认使用的碰撞检测模型和可视化模型是一样的。为了提高运动规划的执行速度，你可以使用MeshLab来简化模型（.stl或.dae零件）的点和面。</p><pre><code> check_urdf test.urdf //检查模型 urdf_to_graphiz test.urdf //创建pdf文件,说明关节信息,方便查看 roslaunch urdf_tutorial display.launch model:=&lt;RELATIVE_PATH_TO_URDF&gt; // rviz中查看urdf模型</code></pre></li><li><p>查看tf</p><pre><code> rosrun tf view_frames evince frames.pdf rosrun tf tf_echo [reference_frame] [target_frame] rosrun rviz rviz -d `rospack find turtle_tf`/rviz/turtle_rviz.rviz</code></pre></li><li><p>环境变量</p><pre><code> env |grep ROS</code></pre></li><li><p>参数服务器<br>指定参数类型</p><pre><code> std::string s; n.param&lt;std::string&gt;(&quot;my_param&quot;, s, &quot;default_value&quot;);  //有时编译器需要字符串类型的提示</code></pre></li><li>solidworks导出urdf<br>通过SolidWorks插件导出的URDF文件，它默认使用的碰撞检测模型和可视化模型是一样的。为了提高运动规划的执行速度，你可以使用MeshLab来简化模型（.stl或.dae零件）的点和面。</li></ol><h2 id="私有名称"><a href="#私有名称" class="headerlink" title="私有名称"></a>私有名称</h2><p>NodeHandle创建时有自己的命名空间,访问私有名称</p><pre><code>ros::init(argc, argv, &quot;my_node_name&quot;);ros::NodeHandle nh1(&quot;~&quot;);               //    命名空间/my_node_nameros::NodeHandle nh2(&quot;~foo&quot;);            //    命名空间/my_node_name/foo// 可以把这两行换成下面的ros::NodeHandle nh;nh.getParam(&quot;~name&quot;, ... );ros::NodeHandle nh(&quot;~&quot;);nh.getParam(&quot;name&quot;, ... );     //  /my_node_name/name</code></pre><p>常用参数设置</p><pre><code>getParam()   param()setParam()deleteParam() hasParam()searchParam()// 有时需要提示类型n.param&lt;std::string&gt;(&quot;my_param&quot;, s, &quot;default_value&quot;);</code></pre><p>如果参数服务器存在/a/b的参数，你的NodeHandle在/a/c工作空间，searchParam()搜索b会得到/a/b.<br>如果/a/c/b参数增加，搜索就会得到/a/c/b参数。</p><h2 id="设置消息级别"><a href="#设置消息级别" class="headerlink" title="设置消息级别"></a>设置消息级别</h2><ol><li><p>源代码加入</p><pre><code> #define ROSCONSOLE_MIN_SEVERITY ROSSONSOLE_SEVERITY_ERROR   //error等级</code></pre></li><li><p>CmakeLists.txt</p><pre><code> add_definition(-ROSCONSOLE_MIN_SEVERITY = ROSSONSOLE_SEVERITY_ERROR)</code></pre></li><li><p>配置文件内容 比较灵活　不需要重新编译</p><pre><code> log4j.logger.ros.package_name=ERROR &lt;env name=&quot;ROSCONSOLE_CONFIG_FILE&quot; value = &quot;$(find package_name)/config/xxx.config&quot; /&gt;                                </code></pre></li><li><p>命名的消息可以单独设置日志级别　名字可以是一个模块或者其他</p><pre><code> ROS_INFO_STREAM_NAMED(&quot;named_msg&quot;, &quot;my message&quot;); log4j.logger.ros.package_name.named_msg=ERROR</code></pre></li><li><p>按条件显示消息和过滤</p><pre><code> ROS_INFO_STREAM_COND(val&lt;0, &quot;my message&quot;); ROS_INFO_STREAM_FILTER()    #暂时用不到　待补充</code></pre></li><li><p>显示消息的方式　单次　可调(频率)　组合</p><pre><code> ROS_INFO_STREAM_ONCE(&quot;my message&quot;); ROS_INFO_STREAM_THROTTLE(2, &quot;my message&quot;);  //每隔两秒输出</code></pre></li><li><p>rqt_console  rqt_logger_level　运行时修改级别</p></li><li><p>检测功能包所有原件潜在问题，出现异常情况 roswtf</p><pre><code> roscd package_name roswtf    </code></pre></li><li><p>消息记录</p><pre><code> rosbag record -a   #记录所有 &lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic_name&quot; /&gt;  #消息记录包默认在~/.ros路劲下　除非使用-o(前缀) -O(文件命名) rosbag play xxx.bag</code></pre></li></ol><h2 id="节点生命周期"><a href="#节点生命周期" class="headerlink" title="节点生命周期"></a>节点生命周期</h2><ul><li>当第一个ros::NodeHandle创建时候，会调用ros::start()</li><li>最后一个ros::NodeHandle销毁时，会调用 ros::shutdown() (这将关闭所有打开的订阅、发布、服务调用和服务服务器)</li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="remap-重映射"><a href="#remap-重映射" class="headerlink" title="remap 重映射"></a>remap 重映射</h2><p>这个坑了我好久</p><p><strong>作用范围</strong>：范围内随后的所有声明(<launch> <node> <group>)</group></node></launch></p><ol><li><p>重命名已经存在的话题</p><pre><code> &lt;!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states--&gt; &lt;launch&gt;     &lt;node pkg=&quot;catch_control&quot; type=&quot;joint_state_maintain_node&quot; name=&quot;joined_joint_state_publisher&quot; respawn=&quot;true&quot; output=&quot;screen&quot;&gt;             &lt;remap from=&quot;moveit_group/joint_states&quot; to=&quot;joint_states&quot;/&gt;     &lt;/node&gt; &lt;/launch&gt;</code></pre></li><li><p>将别的话题映射到自己的订阅的主题上<br>特别要注意这种方式的使用　<strong>作用范围很大</strong></p><pre><code> &lt;!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states--&gt; &lt;launch&gt;     &lt;remap from=&quot;joint_states&quot; to=&quot;moveit_group/joint_states&quot;/&gt;     &lt;include file=&quot;$(find UR5e_robotiq_moveit_config)/launch/move_group.launch&quot; /&gt; &lt;/launch&gt;</code></pre><p>这种方式还是出现了下面问题　但是用第一种结合异步更新没有出现</p><p> Failed to fetch current robot state</p><p> Didn’t received robot state (joint angles) with recent timestamp within 1 seconds.<br> Check clock synchronization if your are running ROS across multiple machines!       </p></li></ol><p>简单理解：<strong>remap就是把作用范围内的名称直接替换掉 用替换掉的名称对外开放 实现两个话题通信</strong> </p><p>所有ROS节点内的资源名称都可以在节点启动时进行重映射。<br>命名重映射采用语法：<code>name:=new_name</code></p><p>例如将chatter重映射为/wg/chatter，在节点启动时可以使用如下方式重映射命名：</p><pre><code>    rosrun rospy_tutorials talker chatter:=/wg/chatter</code></pre><p>ROS的命名解析是在命名重映射之前发生的。所以当我们需要“foo：=bar”时，会将节点内的所有foo命名映射为bar，而如果我们重映射“/foo：=bar”时，ROS只会将全局解析为/foo的名称重映射为bar。<br>可以通过下表总结命名重映射与命名解析之间的关系。<br><img src="/2019/10/07/ROS记录/name_remap.png" alt="命名重映射"></p><h2 id="Failed-to-fetch-current-robot-state"><a href="#Failed-to-fetch-current-robot-state" class="headerlink" title="Failed to fetch current robot state"></a>Failed to fetch current robot state</h2><pre><code>ros::AsyncSpinner async_spinner(6);async_spinner.start();async_spinner.stop();   #需要关闭的时候用</code></pre><p>节点初始化时加上这句　异步处理更新回调函数　感觉可能是moveit内部节点回调函数处理  </p><h2 id="clion编译经常卡死"><a href="#clion编译经常卡死" class="headerlink" title="clion编译经常卡死"></a>clion编译经常卡死</h2><p>查看内存和cpu使用率都有盈余，后来发现是因为launch了很多节点，发布了很多数据，关闭就好了  </p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://blog.csdn.net/xingdou520/article/details/85686752" target="_blank" rel="noopener">ROS中Remap标签详解,举例说明其两种用法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeHandle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++记录</title>
      <link href="2019/10/06/c++%E8%AE%B0%E5%BD%95/"/>
      <url>2019/10/06/c++%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#g编译">g++编译</a><ul><li><a href="#常用选项">常用选项</a></li></ul></li><li><a href="#enum-枚举类型">enum 枚举类型</a></li><li><a href="#左值-右值">左值 右值</a></li><li><a href="#变量初始化">变量初始化</a></li><li><a href="#限定符">限定符</a></li><li><a href="#存储类">存储类</a></li><li><a href="#运算符优先级">运算符优先级</a></li><li><a href="#lambda-函数与表达式">lambda 函数与表达式</a><ul><li><a href="#qt中的lambda表达式">qt中的lambda表达式</a></li></ul></li><li><a href="#指向指针的指针">指向指针的指针</a></li><li><a href="#虚继承">虚继承</a></li><li><a href="#运算符重载">运算符重载</a></li><li><a href="#虚函数">虚函数</a></li><li><a href="#c-stl">c++ STL</a></li><li><a href="#文件和流">文件和流</a><ul><li><a href="#文件输入输出流">文件输入输出流</a></li><li><a href="#字符串输入输出流">字符串输入输出流</a></li></ul></li><li><a href="#异常处理">异常处理</a><ul><li><a href="#异常的使用">异常的使用</a></li><li><a href="#exit函数">exit函数</a></li></ul></li><li><a href="#类型转换">类型转换</a></li><li><a href="#继承和组合">继承和组合</a></li><li><a href="#随机数发生器">随机数发生器</a></li><li><a href="#待续"><strong>待续…</strong></a></li><li><a href="#动态内存">动态内存</a></li><li><a href="#命名空间">命名空间</a></li><li><a href="#模板">模板</a></li><li><a href="#预处理器">预处理器</a></li><li><a href="#信号处理">信号处理</a></li><li><a href="#多线程">多线程</a></li><li><a href="#常见bug">常见bug</a></li></ul><!-- /code_chunk_output --><h2 id="g-编译"><a href="#g-编译" class="headerlink" title="g++编译"></a>g++编译</h2><pre><code>g++ -g -Wall -std=c++11 main.cpp</code></pre><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><pre><code>-ansi    只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。-c    只编译并生成目标文件。-DMACRO    以字符串&quot;1&quot;定义 MACRO 宏。-DMACRO=DEFN    以字符串&quot;DEFN&quot;定义 MACRO 宏。-E    只运行 C 预编译器。-g    生成调试信息。GNU 调试器可利用该信息。-IDIRECTORY    指定额外的头文件搜索路径DIRECTORY。-LDIRECTORY    指定额外的函数库搜索路径DIRECTORY。-lLIBRARY    连接时搜索指定的函数库LIBRARY。-m486    针对 486 进行代码优化。-o    FILE 生成指定的输出文件。用在生成可执行文件时。-O0    不进行优化处理。-O    或 -O1 优化生成代码。-O2    进一步优化。-O3    比 -O2 更进一步优化，包括 inline 函数。-shared    生成共享目标文件。通常用在建立共享库时。-static    禁止使用共享连接。-UMACRO    取消对 MACRO 宏的定义。-w    不生成任何警告信息。-Wall    生成所有警告信息。  </code></pre><h2 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h2><p>可以和switch语句很好结合      </p><ol><li><p>声明 enumType 为新的数据类型，称为<strong>枚举</strong>(enumeration) 可用来声明这种类型的变量,就像int a;<br>Monday等为符号常量，<strong>枚举量</strong>，默认0-6<br>也可以定义的类型的时候定义变量(还可以顺带初始化)      </p><pre><code> enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}; enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday = Monday;</code></pre></li><li><p>枚举量赋值给非枚举量，因为枚举量是符号常量，赋值编译器自动把枚举量转换为int</p><pre><code> int a = Monday; int a = Monday + 1;</code></pre></li><li><p>非枚举量强制类型转换 赋值给枚举量</p><pre><code> Weekday = enumType(2);  #但要注意**不要超出枚举取值范围**，超出了不会报错，但是得不到想要的结果</code></pre></li><li><p>自定义枚举常量的值， 这里Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5</p><pre><code> enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};</code></pre><p>注意：指定的值是<strong>整数</strong>,<strong>未被初始化的枚举值的值默认将比其前面的枚举值大1</strong>,<strong>枚举量的值可以相同</strong>        </p></li><li><p>强类型枚举<br>传统c++问题：暴露在外层作用域，如果有相同枚举常量不行</p><pre><code> enum Side{Right,Left}; enum Thing{Wrong,Right}; #强枚举类型 只能使用 Enumeration::VAL1，单独的VAL1没有意义 enum class Enumeration{  VAL1,  VAL2, };</code></pre></li></ol><h2 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值 右值"></a>左值 右值</h2><ul><li><strong>左值(lvalue)</strong>：指向内存位置的表达式被称为左值表达式。可以出现在赋值号的左边和右边。 如变量</li><li><strong>右值(rvalue)</strong>：存储在内存中某些地址的数值。不能对其进行赋值表达式，只能出现在赋值号右边。如数值型字面值 10</li></ul><h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><ol><li>局部变量：定义时系统不会对其初始化，需要自行初始化</li><li>全局变量：系统自动初始化为下列值</li></ol><ul><li>int        0</li><li>char        ‘\0’</li><li>float        0</li><li>double    0</li><li>pointer    NULL</li></ul><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符    含义</p><ul><li>const    类型的对象在程序执行期间不能被修改改变。</li><li><strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。<br>对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率，<br>比如编译器发现两次从i读取数据代码之间没有对i操作，优化结果就是直接用上次读到的值，(变量是寄存器变量或者端口数据时容易出错)<br>用了volatile生成的汇编代码就会重新从i的地址读取数据</li></ul><pre><code>    volatile int i=10;      int a = i;      ...      // 其他代码，并未明确告诉编译器，对 i 进行过操作      int b = i;  </code></pre><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><ol><li><strong>auto</strong> 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。使用少c++11已删除</li><li><strong>register</strong> 变量<strong>可能</strong>在寄存器中，取决于硬件和实现的限制。如果在寄存器中，则不能进行<strong>一元&amp;</strong>运算，因为没有内存位置。用于需要快速访问的量</li><li><p><strong>static</strong> 修饰全局变量：作用域限制在声明它的文件内。 局部变量：保持局部变量的值，只初始化一次</p><ol><li>static数据成员存储在程序静态存储区，独立于该类的任意对象，类对象和类都可以调用</li><li>static数据成员必须在<strong>类外初始化</strong>，不能在类中</li><li>static const int 可以在类定义内部初始化 其他string double 不可以</li></ol></li><li><strong>extern</strong> 提供一个全局变量引用，使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。通常用于多个文件夹共享全局变量</li><li><strong>mutable</strong> 使用类对象，mutable成员可以通过const成员函数修改</li><li><strong>thread_local</strong> 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</li></ol><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>~ : 二进制补码运算<br><img src="/2019/10/06/c++记录/运算符优先级.png" alt="运算符优先级"></p><h2 id="lambda-函数与表达式"><a href="#lambda-函数与表达式" class="headerlink" title="lambda 函数与表达式"></a>lambda 函数与表达式</h2><p>匿名函数</p><pre><code>[capture](parameters)-&gt;return-type{body}</code></pre><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。可以通过前面的[]来指定：</p><pre><code>    []      // 沒有定义任何变量。使用未定义变量会引发错误。    [x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。    [&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。 一旦传值 就是常量    [&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。    [=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。    //常值传递 copy一份 之后不变    int a=10;    auto func2 = [&amp;]{return a + 1;};    cout &lt;&lt; func1() &lt;&lt; endl;    a++;    cout &lt;&lt; func1() &lt;&lt; endl;    //mutable更改变量值    int a=10;    cout &lt;&lt; [=]()mutable{return ++a;}() &lt;&lt; endl;  //总是一个const函数，不能在函数体内修改非静态成员变量,这里是修改拷贝的参数,参数本身没有改变</code></pre><ol><li>捕捉器，按值传递，相当于在表达式定义那一刻，表达式内就copy了一份变量，而且<strong>值永远不变</strong>，即使外部变量变了，这也不变</li><li>想在表达式内部修改变量的值，添加<strong>mutable</strong> </li></ol><h3 id="qt中的lambda表达式"><a href="#qt中的lambda表达式" class="headerlink" title="qt中的lambda表达式"></a>qt中的lambda表达式</h3><pre><code>QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),                [=](const QString &amp;name)                 { /* Your code here. */ }                );</code></pre><p>这里实际函数调用的参数是从信号过来的所以不需要再赋值,下面就是调用匿名函数,a赋值为4</p><pre><code>[](int a){cout &lt;&lt; a}(4)                    </code></pre><h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><pre><code>//函数如果要改变值就传入指针或这引用,要改变指针就得传入指针的指针,因为在函数参数传递是调用拷贝构造函数进行复制int **var;   **var</code></pre><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>菱形继承 子类多重拷贝：浪费空间，二义性<br>class B C 都继承自class A， 而class D继承自 B和C</p><pre><code>class A {virtual ~A()}    // 有的析构函数不是虚函数class B : virtual public A;class C : virtual public A;class D : public B, public A;</code></pre><p>B C继承了A的数据成员和指向A的指针<br>D继承了B C的数据成员和分别指向B C的指针</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><pre><code>classname operator++();   //前缀自增classname operator++(int);  //后缀自增 加了int形参区分，形参是0，但在函数体内用不到</code></pre><p>-&gt;类成员访问运算符重载 返回类型必须是指针或者类对象 </p><pre><code>class Ptr{   //...   X * operator-&gt;();};void f(Ptr p ){   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10}</code></pre><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>= 0 告诉编译器，函数没有主体，下面的虚函数是纯虚函数。</p><pre><code>virtual int area() = 0;  </code></pre><h2 id="c-STL"><a href="#c-STL" class="headerlink" title="c++ STL"></a>c++ STL</h2><ul><li>Containers(容器)    deque list vector map</li><li>Algorithms(算法)</li><li>iterators(迭代器)    vector<int>::iterator v = vec.begin(); v++; 返回指向向量开头的迭代器   </int></li></ul><h2 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h2><p>如果一个数字太大,无法使用 setprecision 指定的有效数位数来打印,则许多系统会以科学表示法的方式打印.<br>比如setprecision(5), 145678.99 输出 1.4568e+005</p><p>为了让浮点输出以固定点或小数点表示法显示,使用流操作符fixed,结合setprecision(2)表示小数点后显示的位数</p><pre><code>log_file &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; force_sensor_val(0) &lt;&lt; std::endl;</code></pre><h3 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h3><ol><li><p>fstream ofstream ifstream</p><pre><code> void open(const char *filename, ios::openmode mode);   //文件流对象的成员函数</code></pre><p> 打开模式</p><ul><li>ios::app    追加模式。所有写入都追加到文件末尾。</li><li>ios::ate    文件打开后定位到文件末尾。</li><li>ios::in    打开文件用于读取。</li><li>ios::out    打开文件用于写入。</li><li>ios::trunc    如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为0。</li><li><p>ios::binary   二进制方式打开，默认打开为文本方式</p><p>常用函数</p><p>  getline(cin, string);   //当然也可以是 fileOgject从文件 ，cin是从键盘  好用 但是可能读取不到最后一行，如果最后一行没有回车<br>  fileObject.getline(buf, size);</p></li></ul></li><li><p>文件位置 istream成员函数seekg  ostream成员函数seekp</p><pre><code> fileObject.seekg(n);    //定位到第n个字节     fileObject.seekg(n, ios::cur);    //当前位置后移n字节 fileObject.seekg(n, ios::end);    //末尾向前n字节 fileObject.seekg(0, ios::end);    //末尾</code></pre></li><li><p>cin.ignore(),默认参数cin.ignore(1,EOF),完整版本是 cin.ignore(int n, char a)<br>从输入流 (cin) 中提取字符，提取的字符被忽略 (ignore)，不被使用。<br>每抛弃一个字符，它都要计数和比较字符：如果计数值达到 n 或者被抛弃的字符是 a，<br>则 cin.ignore()函数执行终止；否则，它继续等待。<br>它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，<br>消除上一次输入对下一次输入的影响。比如可以这么用：cin.ignore(1024,’\n’)，<br>通常把第一个参数设置得足够大，这样实际上总是只有第二个参数 \n 起作用，<br>所以这一句就是把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。</p><pre><code> int a,b; cout&lt;&lt;&quot;input a:&quot;; cin&gt;&gt;a; cin.ignore(1024, &#39;\n&#39;); cout&lt;&lt;&quot;input b:&quot;; cin&gt;&gt;b;</code></pre></li></ol><h3 id="字符串输入输出流"><a href="#字符串输入输出流" class="headerlink" title="字符串输入输出流"></a>字符串输入输出流</h3><p><sstream>直接对内存而不是对文件和标准输出(设备)进行操作</sstream></p><p>stringstream istringstream   ostringstream<br>同样可以使用seekp()移动写指针 seekg()重定位读指针</p><pre><code>//整数转字符串#include &lt;sstream&gt;std::ostringstream oss;int name_suffix = 1;oss &lt;&lt; name_suffix;oss.str();       //返回一个新的string对象，替换内置的stringbuf// 设置输出精度,cout默认是6位有效数字cout.precision(12); //设置为12位有效数字printf(&quot;%.12f&quot;,val);  //小数点后12位有效数字</code></pre><p>另一种数字转字符串可参考<a href="https://blog.csdn.net/chavo0/article/details/51038397" target="_blank" rel="noopener">【C++】int转换为string的两种方法（to_string、字符串流）</a><br>这是c++11新增的内容</p><pre><code>std::to_string(int val)   </code></pre><p>字符串转数字</p><pre><code>std::stoi(std::string str);  // c++ 11 标准           </code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li><p>抛出异常<br> 关键字throw将创建程序抛出对象的拷贝,然后包含throw的函数返回了这个对象(即使函数返回值没有这个对象),<br> 异常导致程序返回的地方和正常return返回的地方不一样.异常发生之前创建的局部对象也将析构(栈反解)</p><pre><code> throw &quot;Division by zero condition!&quot;;   //类型为const char* 的异常 catch(const char* msg) try{throw x;}catch(T&amp; e){}   //可以抛出任意,包括内置类型 int,double...,后面用相应的类型来捕获.通常抛出异常创建的类    </code></pre></li><li><p>捕获异常:<br> <strong>异常处理器catch必须紧跟try之后,catch只会匹配第一个</strong>,然后系统认为此异常已经处理了,不会继续查找下去,如果还想在抛,就必须throw</p><p> 如果没有任何一个层次的异常处理器匹配到异常,terminate()函数调用,在<exception>内,</exception></p><pre><code> try {    // 保护代码 }catch( ExceptionName e )    //捕获任何异常  (...) {   // 处理 ExceptionName 异常的代码   throw;  //可以选择继续上抛,但是要保证这个throw仍然在try语句中(可以是上一层函数的try) 异常对象的所有信息被保留 }</code></pre><p> <img src="/2019/10/06/c++记录/异常图.png" alt="异常层次图"><br> <img src="/2019/10/06/c++记录/异常表.png" alt="异常说明"></p></li><li>异常安全<br> stack的pop()函数没有返回值,很重要的原因就是stack必须保证异常安全,如果为了得到返回值而调用复制构造函数,函数确抛出异常<br> 导致没有获得栈顶元素,而且栈定指针下移了一个,这是不安全的,所以分成两步.        </li><li>assert() 断言语句 用于开发阶段调试 #define NDEBUG 使其在最终发行软件中失效</li><li><p>定义自己的异常 最好从runtime_error或者logic_error继承(exception两个最主要的派生类)<br>不要直接从exception继承(没有提供一个参数类型为std::string的构造函数)</p><pre><code> class MyError : public runtime_error{ public:     MyError(const string&amp; msg = &quot;&quot;) : runtime_error(msg){} }; int main(){     try{         throw MyError(&quot;my message&quot;);     } catch (MyError &amp; x){         cout&lt;&lt; x.what()&lt;&lt;endl;     } } </code></pre><h3 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h3></li><li>尽量使用引用来捕获异常<ul><li>避免不必要的对象拷贝</li><li>派生类对象被当做基类对象捕获时,避免对象切割,损失信息</li></ul></li><li>构造函数抛出异常时,必须注意对象内部的指针和它的清理方式</li><li>不要在析构函数中抛出异常<ul><li>析构函数会在抛出其他异常的过程中别调用,避免析构函数抛出异常或者使用可能触发异常的语句(栈反解),导致程序调用teminate()</li><li>如果析构函数可能抛出异常,在析构函数内部编写try,catch,必须自己处理异常,不能抛出</li></ul></li><li>避免悬挂指针(野指针)<br> 构造函数抛出异常,而内部又有指针,因为指针没有析构函数,造成资源无法释放,可以使用智能指针,shared_ptr来处理指向堆内存的指针</li><li>处理简单错误尽量不用异常处理,只需要显示消息然后退出程序就可以了,然后把清理工作交给操作系统<br> cout&lt;&lt;”error message”&lt;&lt;endl;exit(1);             </li></ol><h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><pre><code>void exit(int value);  // 位于&lt;cstdlib&gt;中exit(0);  //表示正常退出 退出整个进程.main函数要求返回值为int,在main中的exit相当于return</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>转换很有用，但是在某些情况下，它强制编译器把一个数据看成比他实际更大的类型，占用更多空间，可能会破坏其他数据</li><li>转换就是告诉编译器”忘记类型检查　把它看成其他类型”　编译器不会执行类型检查　引入了漏洞，程序出了问题，首先想到类型转换</li></ul><p>查看变量类型</p><pre><code>#include &lt;typeinfo&gt;std::cout&lt;&lt;typeid(var).name()&lt;&lt;std::endl;</code></pre><ol><li><p>C风格</p><pre><code> int a = 200; long b = (long)a; long c = long(a);  //类似于函数调用</code></pre></li><li><p>c++显式转换<br>比较容易发现转换的位置，定位bug</p><p> static_cast</p><pre><code> int a = 200; long b = static_cast&lt;long&gt;(a);  // static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged);  //qt 函数指针</code></pre><p> const_cast   const 到非const volatile 到非volatile</p><pre><code> const int i=0; int* j = const_cast&lt;int*&gt;(&amp;i);   // 不用转换是不能将赋值给非const指针 volatile int k=0; int* u = const_cast&lt;int*&gt;(&amp;k);     </code></pre></li></ol><h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><ol><li><p>构造函数初始化列表<br>针对问题：新类的构造函数没有权利访问子对象的私有数据成员，所以不能直接对他们初始化</p><pre><code> //Bar是基类，m是MyType的一个成员对象 MyType::MyType(int i): Bar(i),m(i+1){//...}</code></pre></li></ol><ul><li>自动析构函数调用：虽然常常需要在初始化列表中显式构造函数调用，但是不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且不屈任何参数</li><li>构造函数调用次序是由成员对象在类中声明的次序决定。如果由　初始化列表的次序确定，则会有两个不同构造函数有两种不同调用构造函数顺序，那么析构函数不知道如何逆序调用。</li></ul><h2 id="随机数发生器"><a href="#随机数发生器" class="headerlink" title="随机数发生器"></a>随机数发生器</h2><pre><code>#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;ctime&gt;// time(0) 返回一个和时间相关的的数作为随机数种子,如果不设置或者设置一样的数那么运行产生的随机数都一样srand(time(0));   rand();           // 获取随机数 线性同余法 不是真的随机数 N(j+1) = (A*N(j)+B)(mod M)</code></pre><p><a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">线性同余法</a> </p><h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a><strong>待续…</strong></h2><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="常见bug"><a href="#常见bug" class="headerlink" title="常见bug"></a>常见bug</h2><ol><li>有返回值的函数一定记得最后有个<code>return</code>返回需要的值,<strong>建议有返回值函数先写return语句占位置</strong></li></ol><h1 id="const-constexpr"><a href="#const-constexpr" class="headerlink" title="const constexpr"></a>const constexpr</h1><ul><li>const：大致意思是说我承诺不改变这个值，主要用于说明接口，这样变量传递给函数就不担心变量会在函数内被修改了,编译器负责确认并执行const的承诺。</li><li>constexpr：大致意思是在编译时求值，主要用于说明常量，作用是允许数据置于只读内存以及提升性能。</li></ul><p>constexpr的好处：</p><ul><li>是一种很强的约束，更好地保证程序的正确语义不被破坏。</li><li>编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li><li>相比宏来说，没有额外的开销，但更安全可靠。</li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ol><li><p>不同vector 的iterator不能混用</p><p> 迭代器(Iterator)是一个对象，它的工作是遍历并选择序列中的对象，<br> 它提供了一种访问一个容器(container)对象中的各个元素，<br> 而又不必暴露该对象内部细节的方法。通过迭代器，<br> 开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。</p><p> 指针用来遍历<strong>连续存储结构</strong>,迭代器针对容器(不管底层数据结构是否连续),提供堆容器遍历的方法</p><p> 下面这种方式出错,不能简单得把iterator当成一个索引      </p><pre><code> vector&lt;int&gt;::iterator index_vec_1 = find(vec_1.begin(), vec_1.end(), val); //出错 vector&lt;int&gt;::iterator vec_2_new(vec_2.begin(), index_vec_1);   // 正确 vector&lt;int&gt;::iterator vec_1_new(vec_1.begin(), index_vec_1); vector&lt;int&gt;::iterator vec_2_new(vec_2.begin(), vec_1_new.size());</code></pre></li><li><p>/usr/lib64/libstdc++.so.6: error adding symbols: DSO missing from command line<br> 在链接程序的时候链接-lstdc++(在target_link_libraries中增加 stdc++)         </p></li><li><p>对象初始化使用{}<br> 参考<a href="https://stackoverflow.com/questions/3413050/initializing-stdtuple-from-initializer-list" target="_blank" rel="noopener">问题Initializing std::tuple from initializer list</a></p><p> 主要涉及到</p><ul><li><p><strong>initializer_list<t></t></strong> is a homogeneous collection (all members must be of the same type, so not relevant for std::tuple)</p></li><li><p><strong>Uniform initialization</strong> is where curly brackets are used in order to construct all kinds of objects; arrays, PODs and classes with constructors. Which also has the benefit of solving the most vexing parse)</p><pre><code>  struct A {   explicit A(int) {}  };  A a0 = 3;  // Error: conversion from &#39;int&#39; to non-scalar type &#39;A&#39; requested  A a1 = {3};   // Error: converting to &#39;const A&#39; from initializer list would use   // explicit constructor &#39;A::A(int)&#39;  A a2(3); // OK C++98 style  A a3{3}; // OK C++0x Uniform initialization</code></pre></li></ul></li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://blog.csdn.net/Bruce_0712/article/details/54984371" target="_blank" rel="noopener">C++之enum枚举量声明、定义、使用与枚举类详解</a></li><li><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">C++ 教程</a></li><li><a href="https://blog.csdn.net/zyx_0604/article/details/80689673" target="_blank" rel="noopener">C++中volatile关键字的使用详解</a></li><li><a href="https://www.cnblogs.com/yyxt/p/4802688.html" target="_blank" rel="noopener">c++中static数据成员，static成员函数</a></li><li><a href="https://blog.csdn.net/iloveyousunna/article/details/78532398" target="_blank" rel="noopener">c++中lambda表达式的用法</a></li><li><a href="https://blog.csdn.net/bxw1992/article/details/77726390" target="_blank" rel="noopener">C++中虚继承的作用及底层实现原理</a></li><li><a href="https://blog.csdn.net/qq_22274565/article/details/78719951" target="_blank" rel="noopener">关于constexpr与const</a></li><li><a href="https://www.cnblogs.com/wodehao0808/p/3623590.html" target="_blank" rel="noopener">C++中的const和constexpr</a></li><li><a href="https://blog.csdn.net/Dove_Knowledge/article/details/71023512?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">迭代器(Iterator)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客和gitbook配置</title>
      <link href="2019/10/06/hexo%E5%8D%9A%E5%AE%A2%E5%92%8Cgitbook%E9%85%8D%E7%BD%AE/"/>
      <url>2019/10/06/hexo%E5%8D%9A%E5%AE%A2%E5%92%8Cgitbook%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>环境：ubuntu16.04</p><!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#gitbook简介">gitbook简介</a><ul><li><a href="#环境配置">环境配置</a></li><li><a href="#常用命令">常用命令</a></li><li><a href="#定义目录结构">定义目录结构</a></li></ul></li><li><a href="#hexo博客搭建">hexo博客搭建</a></li><li><a href="#hexo博客使用">hexo博客使用</a><ul><li><a href="#博客撰写工具">博客撰写工具</a></li><li><a href="#引用自己的文章">引用自己的文章</a></li><li><a href="#hexo-本地图片避免图床">hexo 本地图片，避免图床</a></li><li><a href="#hexo-配置pdf显示">hexo 配置pdf显示</a></li><li><a href="#添加目录">添加目录</a></li><li><a href="#踩过的坑">踩过的坑</a></li></ul></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="gitbook简介"><a href="#gitbook简介" class="headerlink" title="gitbook简介"></a>gitbook简介</h2><p>创作和管理电子书，是目前最流行的开源书籍写作方案<br>gitbook基于Node.js 开发，需要通过 Node.js 包管理工具 NPM 安装</p><p>简单来说Node.js就是运行在服务端的JavaScript<br>npm 常用命令</p><pre><code>npm update &lt;name&gt;   # 更新指定包npm install npm -g  # 全局更新自己 npm view &lt;package&gt; version  #查看包版本号</code></pre><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>nodejs</li><li><p>gitbook</p><pre><code>  sudo apt-get install nodejs   # 可能还需要安装nodejs-legacy 这是因为需要node 但是最好直接使用node升级 文章末尾  sudo apt-get install npm  sudo npm install gitbook-cli -g   #全局安装  # 可能需要安装 ebook-convert    Binary install或者Source install  sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin</code></pre></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code>gitbook init    #初始化 生成 README.md SUMMARY.mdgitbook serve   #启动服务 浏览器打开 http://localhost:4000/</code></pre><h3 id="定义目录结构"><a href="#定义目录结构" class="headerlink" title="定义目录结构"></a>定义目录结构</h3><ol><li>先定义好结构，然后通过gitbook init自动生成目录结构对应的文件夹和Markdown文件</li><li><p>先创建好文件夹和Markdown文件再来编辑目录结构</p><pre><code> # Summary * [项目简介](README.md) * [快速开始](docs/快速开始.md)  * [环境搭建](docs/环境搭建.md)  * [简单使用](docs/简单使用.md) * [学入学习](docs/深入学习) </code></pre></li></ol><hr><h2 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a>hexo博客搭建</h2><p>常用命令参考<a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">hexo官网</a></p><ul><li><p>ubuntu 搭建<br><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">搭建参考</a></p><pre><code>  sudo apt install nodejs  sudo apt install npm  sudo npm install n -g  sudo n stable  sudo npm install hexo-cli</code></pre></li><li><p>windows 搭建<br>  参考<a href="https://blog.csdn.net/qq_31880107/article/details/86688467" target="_blank" rel="noopener">windows下Hexo博客搭建过程</a></p><p>  由于之前已经在ubuntu配置过github page，所以这里只需要下载安装<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">NodeJs</a></p><pre><code>  // 使用windows powershell可以安装  npm install -g hexo  // 使用git的终端进行操作  hexo init blog  # 初始化, 如果已经有则不需要  hexo clean  hexo g  hexo s  hexo d</code></pre></li></ul><h2 id="hexo博客使用"><a href="#hexo博客使用" class="headerlink" title="hexo博客使用"></a>hexo博客使用</h2><h3 id="博客撰写工具"><a href="#博客撰写工具" class="headerlink" title="博客撰写工具"></a>博客撰写工具</h3><p>可以使用<code>markdown</code>语言进行快速编写,参考<a href="/2019/07/14/Markdown语法/" title="Markdown">Markdown</a><br>软件可以使用visual studio code结合插件<code>Markdown Preview Enhanced</code>.可以预览公式,可参考<a href="https://zhuanlan.zhihu.com/p/56699805" target="_blank" rel="noopener">知乎文章 在 VSCode 下用 Markdown Preview Enhanced 愉快地写文档</a></p><h3 id="引用自己的文章"><a href="#引用自己的文章" class="headerlink" title="引用自己的文章"></a>引用自己的文章</h3><pre><code>{% post_link 文章文件名(不要后缀) 文章标题(可选) %}    </code></pre><h3 id="hexo-本地图片，避免图床"><a href="#hexo-本地图片，避免图床" class="headerlink" title="hexo 本地图片，避免图床"></a>hexo 本地图片，避免图床</h3><p>官网有相关说明，<a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">hexo图片上传说明</a></p><pre><code>1. 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true2. 执行 npm install hexo-asset-image –save 装插件(或者npm install https://github.com/CodeFalling/hexo-asset-image --save)3. 执行hexo new [xxxx],生成xxxx.md和xxxx文件夹4. 把要引用的图片拷贝到xxxx文件夹中5. 使用\![]\(xxxx/example.jpg)来引用本地图片</code></pre><h3 id="hexo-配置pdf显示"><a href="#hexo-配置pdf显示" class="headerlink" title="hexo 配置pdf显示"></a>hexo 配置pdf显示</h3><ol><li><p>安装hexo-pdf插件</p><pre><code> npm install -save hexo-pdf</code></pre></li><li>拷贝pdf到资源文件夹<br> 与文章同名的资源文件夹在配置图片时已经配置过,这里直接用</li><li><p>文章中引用, 注意写法, 只需要把<code>pdf文件名</code>改好就行,前面的<code>pdf</code>不能修改</p><pre><code> {% pdf pdf文件名 %}</code></pre><p> 外部链接使用外部链接：</p><pre><code> {% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %}</code></pre></li></ol><h3 id="添加目录"><a href="#添加目录" class="headerlink" title="添加目录"></a>添加目录</h3><p>这是在visual studio code中使用的<br>可以在想要添加目录的地方加入下面这句话,就能自动为文章增加目录,Awesome!<br>还可以设置需要显示的目录级别,在文章开头可以通过 <code>ctrl+鼠标左键</code> 的方式跳转到对应内容</p><pre><code>&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;</code></pre><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><ol><li><p>hexo用着用着报错，提示node版本太低</p><p> 升级node：</p><pre><code> node -v     #查看当前版本 sudo npm cache clean -f #清楚node缓存 有时候不用也可以 sudo npm install n -g   #安装node版本管理工具n sudo n stable           #安装最新版node sudo n 8.9.4            #安装指定版本 node -v</code></pre></li><li>报错：The “mode“ argument must be integer. Received an instance of Object<br> 主要原因是node版本过高，下载之前版本<a href="https://nodejs.org/en/download/releases" target="_blank" rel="noopener">node</a></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/wirelessqa/article/details/72616471" target="_blank" rel="noopener">GitBook 使用入门</a></li><li><a href="https://blog.csdn.net/tlbaba/article/details/79412433" target="_blank" rel="noopener">node升级的正确方法</a></li><li><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">Node.js教程</a></li><li><a href="https://alreadyright.github.io/2019/06/16/aboutHexo/" target="_blank" rel="noopener">hexo建站过程中踩的坑总结</a></li><li><a href="https://jankin987.github.io/2018/09/19/02.Hexo/03.hexo%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%92%8Cpdf/" target="_blank" rel="noopener">hexo配置本地图片和pdf</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS中CMakeLists.txt</title>
      <link href="2019/10/05/ROS%E4%B8%ADCMakeLists-txt/"/>
      <url>2019/10/05/ROS%E4%B8%ADCMakeLists-txt/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>CMake构建系统通过ROS包中的CMakeList.txt来构建软件包。<br>在catkin 项目中，CMakeList.txt 符合标准的vanilla CMakeList.txt 格式，但稍微有点不同。</p><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><ol><li>所需CMake版本(cmake_minimum_required)</li><li>软件包名称(project())</li><li>查找构建所需的其他CMake / Catkin软件包(find_package())</li><li>启用Python模块支持(catkin_python_setup())</li><li>消息/服务/动作生成器(add_message_files()，add_service_files()，add_action_files())</li><li>生成消息/服务/动作等自定义消息(generate_messages())</li><li>指定包的构建信息输出(catkin_package())</li><li>要建立的库/可执行文件(add_library()/ add_executable()/ target_link_libraries())</li><li>测试(catkin_add_gtest())</li><li>安装规则(install())</li></ol><h1 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h1><pre><code>cmake_minimum_required(VERSION 2.8.3)</code></pre><h1 id="软件包名称"><a href="#软件包名称" class="headerlink" title="软件包名称"></a>软件包名称</h1><p>可通过变量${PROJECT_NAME}来引用项目名称</p><pre><code>project(robot_brain) </code></pre><h1 id="查找相关CMake包"><a href="#查找相关CMake包" class="headerlink" title="查找相关CMake包"></a>查找相关CMake包</h1><p>指明构建package需要的包，使用catkin_make，所以catkin是必备依赖,在此基础上可能需要其他的包</p><pre><code>find_package(catkin REQUIRED)   find_package(catkin REQUIRED COMPONENTS nodelet)  #第一种方式 合并写find_package(catkin REQUIRED)   # 第二种方式 分开写find_package(nodelet REQUIRED)</code></pre><h2 id="find-package作用"><a href="#find-package作用" class="headerlink" title="find-package作用"></a>find-package作用</h2><p> 如果CMake通过find_package找到一个包，则会自动生成有关包所在路径的CMake环境变量，<br> 环境变量描述了包中头文件的位置，源文件的位置，包所依赖的库文件位置。<br> 这些变量名称以&lt; PACKAGE NAME &gt;_&lt; PROPERTY &gt;的形式出现：</p><ul><li>&lt; NAME &gt;_FOUND - 如果找到库，则设置为true，否则为false</li><li>&lt; NAME &gt; _INCLUDE_DIRS或 _INCLUDES - 这个包输出的头文件目录</li><li>&lt; NAME &gt; _LIBRARIES或 _LIBS - 由包导出的库</li><li>&lt; NAME &gt; _DEFINITIONS - ?</li><li>…</li></ul><h3 id="cmake-中的find-package"><a href="#cmake-中的find-package" class="headerlink" title="cmake 中的find_package"></a>cmake 中的find_package</h3><ul><li><p>模块模式.属于精简格式,搜索所有名为Find<package>.cmake的文件，这些文件的路径由变量由安装CMake时指定的CMAKE_MODULE_PATH变量指定.如果查找到了该文件，它会被CMake读取并被处理.如果没有，然后再查看它自己的模块目录/usr/share/cmake-3.5/Modules/(具体值通过在CMakeLists.txt中写message(${CMAKE_ROOT})输出).这称为模块模式.<br>查看包</package></p><pre><code>  cmake --help-module-list # 双击Tab会有提示     cmake --help-module FindBZip2     #查看Bzip2的帮助  # 输出如下,可知道对应头文件和源文件变量名  FindBZip2  ---------  Try to find BZip2  Once done this will define  ::   BZIP2_FOUND - system has BZip2   BZIP2_INCLUDE_DIR - the BZip2 include directory   BZIP2_LIBRARIES - Link these to use BZip2   BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_   BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)</code></pre></li><li><p>配置模式.没有找到任何模块就会进入配置模式.试图查找一个由待查找的包提供的配置文件的位置。查找<package>Config.cmake或者<package全小写>-config.cmake<br>搜索路径包括,比如ros内部定义了CMAKE_PREFIX_PATH=/opt/ros/kinetic/share</package全小写></package></p><pre><code> &lt;package&gt;_DIR CMAKE_PREFIX_PATH CMAKE_FRAMEWORK_PATH CMAKE_APPBUNDLE_PATH</code></pre></li></ul><p>编译第三方库如软件时需要知道头文件路径(gcc的-I参数),库文件路径(gcc的-L参数),库文件名字(gcc的-l参数)</p><p>比如在CMakeList.txt中</p><pre><code>include_directiories(/usr/include/curl)target_link_libraries(myprogram path/curl.so)</code></pre><p>借助cmake提供的finder,使用cmake的Modules目录下的FindCURL.cmake，相应的CMakeList.txt 文件：</p><pre><code>find_package(CURL REQUIRED)include_directories(${CURL_INCLUDE_DIR})target_link_libraries(curltest ${CURL_LIBRARY})</code></pre><h2 id="为什么Catkin包是组件形式"><a href="#为什么Catkin包是组件形式" class="headerlink" title="为什么Catkin包是组件形式"></a>为什么Catkin包是组件形式</h2><p>Catkin的包并不是catkin的真正组成部分。而catkin采用CMake的组件功能，主要是为了节省打字时间。</p><pre><code>#这种方式 会把组件中的包对应的include路径、库导出到catkin前缀的变量中，#例如catkin_INCLUDE_DIRS包含多个包的路径find_package（catkin REQUIRED COMPONENTS nodelet）find_package(nodelet REQUIRED)  # 而这种方式 路径和库不会导入catkin变量，而是nodelet_INCLUDE_DIRS之类的</code></pre><h2 id="Boost库"><a href="#Boost库" class="headerlink" title="　Boost库"></a>　Boost库</h2><p>如果使用C ++和Boost，则需要用find_package()来找Boost库，并指定Boost中的组件。如果想使用Boost线程，就可以写成：</p><pre><code>find_package（Boost REQUIRED COMPONENTS thread）</code></pre><h1 id="catkin-package"><a href="#catkin-package" class="headerlink" title="　catkin_package()"></a>　catkin_package()</h1><p>将catkin特定的信息输出到构建系统上，用于生成pkg配置文件以及CMake文件        </p><ul><li>INCLUDE_DIRS - 导出包的include路径</li><li>LIBRARIES - 导出项目中的库</li><li>CATKIN_DEPENDS - 该项目依赖的其他catkin项目</li><li>DEPENDS - 该项目所依赖的非catkin CMake项目。</li><li><p>CFG_EXTRAS - 其他配置选项</p><pre><code>  catkin_package(     INCLUDE_DIRS include     LIBRARIES ${PROJECT_NAME}　　　     CATKIN_DEPENDS roscpp nodelet     DEPENDS eigen opencv)</code></pre><p>这表示包文件夹中的文件夹“include”是导出头文件的地方。<br>${PROJECT_NAME}根据project中的内容生成，此处是robot_brain<br>“roscpp”+“nodelet”是用来构建/运行此程序包的catkin包，<br>而“eigen”+“opencv”是用于构建/运行此程序包的非catkin包。 </p></li></ul><h1 id="指定构建目标"><a href="#指定构建目标" class="headerlink" title="指定构建目标"></a>指定构建目标</h1><h2 id="包含路径和库"><a href="#包含路径和库" class="headerlink" title="包含路径和库"></a>包含路径和库</h2><ol><li>include_directories()</li></ol><p>参数应该是调用find_package调用时生成的* _INCLUDE_DIRS变量。<br>如果使用catkin和Boost，那么include_directories()调用应该如下所示：</p><pre><code>include_directories(include ${Boost_INCLUDE_DIRS} ${catkin_INCLUDE_DIRS})</code></pre><p>第一个参数“include”表示包中的include /目录也是路径的一部分。</p><ol><li>link_directories()</li></ol><p>用于添加额外的库路径，但通常不推荐这样做，因为 所有catkin和CMake软件包在find_packaged时都会自动添加链接信息。<br>只需写target_link_libraries()中就可以了。但真要写，就按照下面那样来写：</p><pre><code>link_directories(~/my_libs)</code></pre><h2 id="可执行目标"><a href="#可执行目标" class="headerlink" title="可执行目标"></a>可执行目标</h2><p>生成可执行程序对应的源文件</p><pre><code>add_executable(myProgram src/main.cpp src/some_file.cpp)</code></pre><h2 id="库目标"><a href="#库目标" class="headerlink" title="库目标"></a>库目标</h2><p>默认的catkin编译产生的共享库</p><pre><code>add_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})　　#指定要构建的库</code></pre><h2 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries"></a>target_link_libraries</h2><p>指定可执行目标链接的库。 通常在add_executable()调用之后完成。<br>如果找不到ros，则添加$ {catkin_LIBRARIES}。</p><pre><code>target_link_libraries(&lt;executableTargetName&gt;, &lt;lib1&gt;, &lt;lib2&gt;, ... &lt;libN&gt;)</code></pre><p>大多数情况中不需要使用link_directories()，因为find_package()自动拉入。  </p><h1 id="消息、服务和响应"><a href="#消息、服务和响应" class="headerlink" title="消息、服务和响应"></a>消息、服务和响应</h1><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><pre><code># CMakeLists.txtfind_package(catkin REQUIRED COMPONENTS message_generation ...)add_message_files(...)add_service_files(...)add_action_files(...)generate_messages(...)catkin_package( ... CATKIN_DEPENDS message_runtime ... ...)# package.xml文件中加上 &lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;</code></pre><ol><li><p>如果构建的对象依赖于其他包提供的消息/服务/动作的头文件,<br>则需要向目标catkin_EXPORTED_TARGETS添加明确的依赖关系,以便它们以正确的顺序构建。     </p><pre><code> add_dependencies(some_target ${catkin_EXPORTED_TARGETS})  # 通常是find_package中找到的包导出的对象</code></pre></li><li><p>如果构建的对象依赖自己包定义的消息或服务</p><pre><code> add_dependencies(some_target ${${PROJECT_NAME}_EXPORTED_TARGETS})</code></pre><p> 具体的变量包含的内容可以通过<code>message ${${PROJECT_NAME}_EXPORTED_TARGETS}</code>查看             </p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现在有两个依赖于std_msgs和sensor_msgs的消息MyMessage1.msg和MyMessage2.msg，<br>还有一个自定义服务MyService.srv, message_program是使用这些消息和服务的指令，<br>以及生成不使用自定义消息、服务的程序 do_not_use_local_messages_program 不使用，<br>那么CMakeLists.txt应该写成：</p><pre><code># 构建时依赖项find_package(catkin REQUIRED COMPONENTS                       message_generation              std_msgs # 声明要构建哪些消息add_message_files(FILES                  MyMessage1.msg                  MyMessage2.msg)# 声明构建哪些服务add_service_files(FILES                  MyService.srv)# 声明生成上述消息、服务需要依赖的消息以及服务generate_messages(DEPENDENCIES                     std_msgs                     sensor_msgs)# 声明运行时依赖项catkin_package(CATKIN_DEPENDS                 message_runtime                 std_msgs sensor_msgs)# 声明构建生成的可执行文件名称以及依赖项add_executable(message_program src/main.cpp)add_dependencies(message_program ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})# 声明构建不需要使用自定义消息、服务的可执行文件add_executable(does_not_use_local_messages_program src/main.cpp)add_dependencies(does_not_use_local_messages_program ${catkin_EXPORTED_TARGETS})</code></pre><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>之前用矩阵运算c++库:Armadillo 直接作为catkin组件时找不到库</li></ol><p>解决方案：find_package() 把Armadillo单独拿出来 后面需要的地方链接到库 </p><pre><code>find_package(Armadillo 5.4 REQUIRED)target_link_libraries(tp_gmr_node ${catkin_LIBRARIES} ${ARMADILLO_LIBRARIES})</code></pre><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>下面主要讲CMake对应CMakelists.txt中对应内容,和ROS无光</p><h2 id="安装与测试"><a href="#安装与测试" class="headerlink" title="安装与测试"></a>安装与测试</h2><p>安装MathFuncitons到${CMAKE_INSTALL_PREFIX}/bin,安装MathFunctions.h到${CMAKE_INSTALL_PREFIX}/include.其实就是拷贝文件<br>${CMAKE_INSTALL_PREFIX}在ubuntu系统上默认是/usr/local</p><pre><code>install (TARGETS MathFunctions DESTINATION bin)install (FILES MathFunctions.h DESTINATION include)</code></pre><p>下面部分ROS和cmake规则是一样的,只是安装到的位置不一样,比如cmake指定相对于${CMAKE_INSTALL_PREFIX}下的bin,只需要替换变量即可</p><ol><li><p>安装工程中的目标(targets,即库和可执行文件).对于动态库不是DLL的平台对应的含义如下代码.DLL平台(给予Windows的系统),动态库的DLL部分被当做一个RUNTIME目标而对应的导出库被当做是一个ARCHIVE目标.</p><pre><code> install(TARGETS your_library your_other_library         ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # Static libraries and DLL (Windows) .lib stubs         LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # Non-DLL shared libraries and modules         RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})   # Executable targets and DLL (Windows) style shared libraries</code></pre></li><li><p>安装库使用的头文件(函数调用接口)</p><pre><code> install(DIRECTORY include/${PROJECT_NAME}/         DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})</code></pre></li><li><p>如果文件夹内有不需要安装的如这里是svn仓库,可以排除.svn</p><pre><code> install(DIRECTORY include/${PROJECT_NAME}/         DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}         PATTERN &quot;.svn&quot; EXCLUDE)</code></pre></li><li><p>安装后文件权限.使用源文件权限确保python脚本的可执行权限</p><pre><code> install(     DIRECTORY scripts/     DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}     USE_SOURCE_PERMISSIONS  # 使用源文件权限 )                </code></pre></li></ol><p>终端运行<code>make install</code> 安装文件,如果没有权限则需要切换为管理员</p><p>测试可以在CMakeLists.txt中编写</p><pre><code>include(CTest)# does the application run # 第一个参数是测试的提示 第二个参数的可执行程序 第三个参数是程序带的参数 add_test (TutorialRuns Tutorial 25)# does it sqrt of 25add_test (TutorialComp25 Tutorial 25)set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION &quot;25 is 5&quot;)# does it handle negative numbersadd_test (TutorialNegative Tutorial -25)set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION &quot;-25 is 0&quot;)# does it handle small numbersadd_test (TutorialSmall Tutorial 0.0001)set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION &quot;0.0001 is 0.01&quot;)# does the usage message work?add_test (TutorialUsage Tutorial)set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;)</code></pre><p>然后终端运行<code>make test</code>即可测试程序</p><h2 id="为顶层目标增加一个依赖"><a href="#为顶层目标增加一个依赖" class="headerlink" title="为顶层目标增加一个依赖"></a>为顶层目标增加一个依赖</h2><p>让一个顶层目标依赖于其他的顶层目标。一个顶层目标是由命令ADD_EXECUTABLE，ADD_LIBRARY，或者ADD_CUSTOM_TARGET产生的目标。<br>为这些命令的输出引入依赖性可以保证某个目标在其他的目标之前被构建。</p><p>如下是在构建目标时使用了ROS中自定义的消息和服务的文件,增加依赖可以确保构建目标之前先生成对应的头文件</p><pre><code>add_dependencies(your_program ${catkin_EXPORTED_TARGETS})add_dependencies(your_library ${catkin_EXPORTED_TARGETS})</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><pre><code>add_compile_options(-Wall -Wextra)  # -Wall 打开编译输出警告 -Wextra打印一些额外的警告 是gcc的编译参数</code></pre><h2 id="生成自己的package供别人调用"><a href="#生成自己的package供别人调用" class="headerlink" title="生成自己的package供别人调用"></a>生成自己的package供别人调用</h2><p>待补充</p><h2 id="安装升级cmake"><a href="#安装升级cmake" class="headerlink" title="安装升级cmake"></a>安装升级cmake</h2><pre><code>pip install cmake --upgrade</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="http://wiki.ros.org/catkin/CMakeLists.txt#Finding_Dependent_CMake_Packages" target="_blank" rel="noopener">catkin CMakeLists.txt</a></li><li><a href="https://gearyyoung.gitbooks.io/cmake-api/content/" target="_blank" rel="noopener">cmake-api</a></li><li><a href="https://github.com/chaneyzorn/CMake-tutorial" target="_blank" rel="noopener">CMake-tutorial</a></li><li><a href="https://blog.csdn.net/u013243710/article/details/35795841" target="_blank" rel="noopener">ROS中的CMakeLists.txt</a></li><li><a href="https://blog.csdn.net/turboian/article/details/74604052" target="_blank" rel="noopener">ROS下的CMakeList.txt编写</a></li><li><a href="https://blog.csdn.net/haluoluo211/article/details/80559341?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">cmake教程4(find_package使用)</a></li><li><a href="https://blog.csdn.net/cui918/article/details/53187643" target="_blank" rel="noopener">GCC 警告选项 -Werror</a></li><li><a href="https://docs.ros.org/en/api/catkin/html/howto/format2/index.html" target="_blank" rel="noopener">Package format 2</a></li><li><a href="https://stackoverflow.com/questions/49859457/how-to-reinstall-the-latest-cmake-version" target="_blank" rel="noopener">How to reinstall the latest cmake version?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试</title>
      <link href="2019/10/03/gdb%E8%B0%83%E8%AF%95/"/>
      <url>2019/10/03/gdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>gcc(GNU Compiler Collection)</p><pre><code>-c  激活预处理、编译和汇编，生成.o文件-S  激活预处理和编译，生成.s的汇编代码wenjain-E  激活预处理，结果输出到标准输出(屏幕)，可结合重定向输出到文件 &gt; pre_test-g  为调试程序生成相关信息默认生成a.out文件，可以使用-o 指定输出文件</code></pre><p>编译c++：g++  gcc可以编译c++源文件，但是不会自动和c++程序使用的库连接，所以通常使用g++,会自动调用gcc</p><h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><p>很多命令可以缩写为一个字母   </p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code>gcc -g summary.cgdb a.out    #二进制文件作为gdb参数就可以了,可以是最后生成的可执行文件</code></pre><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><pre><code>l       #listsearch  #reverse-search回车      #重复上一指令</code></pre><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><pre><code>b 10  #第10行设置断点info break   #查看断点信息clear       #清除当前行断点</code></pre><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><pre><code>rn   #单步执行程序continue    #运行到下一个断点s   #step  遇到函数调用会进入函数内部 next不会</code></pre><h2 id="监视变量"><a href="#监视变量" class="headerlink" title="监视变量"></a>监视变量</h2><pre><code>print variable  #缩写p  watch varialbe    #监视</code></pre><h2 id="临时改变变量"><a href="#临时改变变量" class="headerlink" title="临时改变变量"></a>临时改变变量</h2><pre><code>set var i=1 #临时设置i=1</code></pre><h2 id="查看堆栈"><a href="#查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h2><pre><code>bt  #程序调用函数，函数的地址、参数、函数内局部变量都会压入</code></pre><h2 id="gdb-调试python程序"><a href="#gdb-调试python程序" class="headerlink" title="gdb 调试python程序"></a>gdb 调试python程序</h2><pre><code>gdb pythonrun xxx.py    </code></pre><h1 id="ROS中使用"><a href="#ROS中使用" class="headerlink" title="ROS中使用"></a>ROS中使用</h1><p>launch文件</p><pre><code>launch-prefix=&quot;xterm -e gdb --args&quot;     //in a separate xterm windowlaunch-prefix=&quot;gdb -ex run --args&quot;　　　 //in the same xterm</code></pre><p>使用memcheck启动valgrind来检测程序内存泄露　使用callgrind执行性能分析</p><pre><code>launch-prefix=&quot;valgrind&quot;    //valgrind</code></pre><p>设置ROS节点core文件转储　　coredump　进程突然崩溃的那一刻的内存快照</p><pre><code>ulimit -c unlimitedecho 1 &gt; /proc/sys/kernel/core_uses_pid     #将core文件名设置成默认使用进程的pidgdb  program_name  core_name  #查看core文件　program为编译好的　　/var/core_log</code></pre><h1 id="rosrun启动gdb"><a href="#rosrun启动gdb" class="headerlink" title="rosrun启动gdb"></a>rosrun启动gdb</h1><pre><code>rosrun --prefix &#39;gdb -ex run --args&#39; [package_name] [node_name]     </code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB" target="_blank" rel="noopener">ros Tutorial Roslaunch Nodes in Valgrind or GDB</a>                  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理</title>
      <link href="2019/10/02/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2019/10/02/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#linux进程">Linux进程</a><ul><li><a href="#进程管理常用命令">进程管理常用命令</a></li><li><a href="#遇到的问题">遇到的问题</a></li></ul></li><li><a href="#临时和周期任务安排">临时和周期任务安排</a></li></ul><!-- /code_chunk_output --><h2 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h2><p>Linux是一个多用户多任务的操作系统。init进程是所有进程的发起者和控制者，每个进程<br>都有一个编号，PID(Process ID)，是在当前系统中的运行顺序，init进程在系统运行期间不会消亡或停止</p><h3 id="进程管理常用命令"><a href="#进程管理常用命令" class="headerlink" title="进程管理常用命令"></a>进程管理常用命令</h3><ol><li><p>查看进程状态</p><p> ps aux      #静态查看系统中所有进程信息<br> top         #动态查看  P M T 分别按照CPU Memory Time排序</p></li><li><p>设置优先级 nice [-n][command][arguments]   #优先级-20 - 19 默认为0 -20最高</p><p> nice  —12 processname   #-12<br> renice          #修改优先级</p></li><li><p>终止进程</p><p> kill[-signal] PID   #不带参数默认15 即终止进程<br> kill -l             #查看可选signal<br> kill -CONT  4385    #重新开始进程<br> kill -9 4385        #强制终止<br> kill -STOP 4385     #停止但不退出</p><p> killall [-signal] [processname]  #终止所有名为processname的进程</p></li><li><p>查看后台进程<br> 查看后台进程</p><pre><code> gnome-system-monitor    </code></pre><p> 自启动</p><pre><code> gnome-session-properties</code></pre></li></ol><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li><p>win10可以联网,ubuntu不能</p><p> 关闭网络唤醒,在win10里面的电源计划,勾选快速启动</p></li></ol><h2 id="临时和周期任务安排"><a href="#临时和周期任务安排" class="headerlink" title="临时和周期任务安排"></a>临时和周期任务安排</h2><p>待补充    </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SAMBA服务简单搭建</title>
      <link href="2019/10/01/SAMBA%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/"/>
      <url>2019/10/01/SAMBA%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="SAMBA简介"><a href="#SAMBA简介" class="headerlink" title="SAMBA简介"></a>SAMBA简介</h1><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。<br>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，<br>它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。</p><p>可以实现Windows和Linux主机之间共享资源互访功能</p><p>实验室小范围使用 直接采用匿名共享资源 简单快捷</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>server 服务器</p><pre><code>sudo apt install samba    # samba-common 会自动安装sudo vi /etc/samba/smb.conf[share]             #共享目录comment=Linux share     #共享目录描述，给自己看的path=/home/share    #共享目录路径public=yeswriteable=yes   #可写browseable=yes  #共享在Windows中网上邻居可见 结合publicguest ok=yes    #允许匿名访问sudo /etc/init.d/samba start  # 开启服务器</code></pre><p>client ubuntu</p><pre><code>sudo apt install smbclientsmbclient -L 192.168.10.100   #查看共享目录smbclient //192.168.10.100/share  # IP地址后接共享目录  访问sudo apt-get install cifs-utils   #下载相应组件sudo mount -t cifs //192.168.10.100/share  /home/yang/share  # 使用这句或者下面一句sudo mount -t cifs -o passward=123,dir_mode=0777,file_mode=0777 //192.168.10.100/share  /home/yang/share  #有写权限 passward 为对应服务器的密码# vi /etc/fstab 开机自动挂载 具有写权限 注意逗号 之前就是用的空格导致不行# cifs 文件系统  备份 0:不需要 1:每天 2:每两天  fsck 0:不需要 1:需要# blkid 查询UUID//192.168.10.100/share    /home/yang/share cifs passward=123,dir_mode=0777,file_mode=0777 0 0  </code></pre><p>client Windows</p><pre><code>&quot;运行&quot;对话框输入\\192.168.10.100 回车选中共享文件夹 右键映射网络驱动器 即可像本地磁盘使用</code></pre><h1 id="服务器开机自启动"><a href="#服务器开机自启动" class="headerlink" title="服务器开机自启动"></a>服务器开机自启动</h1><pre><code>sudo vi /etc/rc.loca/etc/init.d/ssh start # 末尾添加 exit 0 之前/etc/init.d/smbd start    </code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://blog.csdn.net/qq_43682605/article/details/86562212" target="_blank" rel="noopener">Ubuntu终端访问samba服务器</a>    </li><li><a href="https://www.cnblogs.com/torres-9/p/5880188.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">如何配置使Ubuntu启动后samba服务与ssh服务开机自动启动</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件共享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github SSH Key避免Hexo部署输入密码</title>
      <link href="2019/10/01/Github-SSH-Key%E9%81%BF%E5%85%8DHexo%E9%83%A8%E7%BD%B2%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/"/>
      <url>2019/10/01/Github-SSH-Key%E9%81%BF%E5%85%8DHexo%E9%83%A8%E7%BD%B2%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>前提: 已经生成ssh公钥放在github</p><p>修改_config.yaml,将部署方式从https改为ssh</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repository: https://github.com/yangbenbo/yangbenbo.github.io.git  branch: master</code></pre><p>改为</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repository: git@github.com:yangbenbo/yangbenbo.github.io.git  branch: master   </code></pre><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>ubuntu换内核(kernel)启动 需要重新上传ssh-key              </li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/yaoel/p/5381826.html" target="_blank" rel="noopener">使用Github SSH Key来避免Hexo部署时输入账户密码</a>      </li></ol>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> ssh </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户权限管理</title>
      <link href="2019/09/30/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>2019/09/30/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><pre><code>adduser     # 交互形式   useraddfinger -l yang     # 显示用户相关信息chfn        # 修改用户个人信息passwd      # 更改密码id          # 显示用户UID GIDusemod      # 修改用户登录信息 用户组gsudo usermod -aG sudo yang      #普通用户添加sudodeluser --remove-all-files yang  # 交互deluser  yang  sudo     # 从sudo组删除用户yanguserdelsu yang     #切换用户cat /etc/passwd #查看所有用户 与管道结合更方便grep</code></pre><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><pre><code>addgroup    #系统用户组groupaddgroups      #显示用户对应的组groupmod    #更改用户组名称 IDdelgroupgroupdel   cat /etc/group  #查看所用用户组 </code></pre><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><pre><code>chmodchown   #修改文件、目录归属用户或组chgrp   #修改文件或目录的归属组   </code></pre><h1 id="文件预设权限-umask"><a href="#文件预设权限-umask" class="headerlink" title="文件预设权限 umask"></a>文件预设权限 umask</h1><p>文件: -rw-rw-rw-  666</p><p>目录: drwxrwxrwx  777<br>默认权限-umask权限就是创建文件的默认权限</p><pre><code>   umask   umask -S #查看文件预设权限   umask 022    #设定umask权限 这里是所用者没有权限 所属组和其他人没有写权限</code></pre><h2 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h2><p>chattr 指令只能在Ext2/Ext3/Ext4 的 Linux 传统文件系统上面完整生效<br>其他的文件系统可能就无法完整的支持这个<br>指令了,例如 xfs 仅支持部份参数而已  </p><pre><code>chattr +i filename  #文件不可更改chattr +a filename  #只能增加内容 不能删除和修改lsattr  filename    #查看文件隐藏属性</code></pre><h2 id="特殊权限-SUID-SGID-SBIT"><a href="#特殊权限-SUID-SGID-SBIT" class="headerlink" title="特殊权限 SUID, SGID, SBIT"></a>特殊权限 SUID, SGID, SBIT</h2><p>SUID不是用在目录上,而 SBIT 不是用在文件上</p><ol><li><p>Set UID</p><p> s在user位置</p><p> /usr/bin/passwd 的-rwsr-xr-x 中的s</p><ol><li>SUID 权限仅对二进制程序(binary program)有效;</li><li>执行者对于该程序需要具有 x 的可执行权限;</li><li>本权限仅在执行该程序的过程中有效 (run-time);</li><li><p><strong>执行者将具有该程序拥有者 (owner) 的权限</strong>。如果拥有者都没有执行权限 则执行者这个权限为S 空的意思</p><p>例如普通用户更改密码 调用passwd时就会暂时具有root权限,而使用cat查看密码不属于执行,所以不具有执行权限</p><p>文件具有 SUID 的特殊权限时,代表当用户执行此一 binary 程序时,在执行过程中用户会暂时具有程序拥有<br>者的权限</p></li></ol></li><li><p>Set GID       </p><p> s在group的位置</p><ol><li>SGID 对二进制程序有用;</li><li>程序执行者对于该程序来说,需具备 x 的权限;</li><li><p>执行者在执行的过程中将会获得该程序群组的支持!</p><p>目录具有 SGID 的特殊权限时,代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。    </p></li></ol></li><li><p>Sticky Bit</p><p> 只针对目录有效</p><ol><li>当用户对于此目录具有 w, x 权限,亦即具有写入的权限时;</li><li><p>当用户在该目录下建立文件或目录时,仅有自己与 root 才有权力删除该文件</p><p>例如/tmp 的权限是 drwxrwxrwt</p><p>目录具有 SBIT 的特殊权限时,代表在该目录下用户建立的文件只有自己与 root 能够删除!</p></li></ol></li></ol><h3 id="特殊权限的修改"><a href="#特殊权限的修改" class="headerlink" title="特殊权限的修改"></a>特殊权限的修改</h3><ul><li>4 为 SUID</li><li>2 为 SGID</li><li><p>1 为 SBIT  </p><pre><code>chmod 4755 filename   # 增加SUID         </code></pre></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP配置和使用</title>
      <link href="2019/09/30/FTP%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>2019/09/30/FTP%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="FTP简介"><a href="#FTP简介" class="headerlink" title="FTP简介"></a>FTP简介</h1><p>文件传输协议(File Transfer Protocol)：传统网络传输协议，主要实现服务器和客户端之间的文件传输</p><h1 id="FTP配置"><a href="#FTP配置" class="headerlink" title="FTP配置"></a>FTP配置</h1><p>匿名用户无法使用ls dir等命令查看文件</p><hr><pre><code>sudo apt-get install vsftpd   #服务器端sudo vim /etc/vsftpd.conf     #可以默认 anonymous_enable=YES 可用anonymous作为用户名和密码登录sudo /etc/init.d/vsftpd restart  #重启服务ftp 10.1.1.20   #连接服务器</code></pre><p>配置文件:vsftpd.conf   # 测试了一下 感觉默认设置就可以本地用户登录<br>可能需要改/etc/ftpusers  并重启  </p><pre><code>local_root=/home/ftp  # 锁定共享目录 手动添加  可以不用local_enable=YES    #本机可以访问write_enable=YES    #允许写操作#chroot_local_user=YESchroot_list_enable=YES    # 限制实体用户在自己的主目录设定文件# (default follows)chroot_list_file=/etc/vsftpd.chroot_listsudo vim /etc/vsftpd.chroot_list     # 添加用户名sudo vim /etc/ftpusers  #这里面是不能访问ftp的用户  删除对应的</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="FTP命令"><a href="#FTP命令" class="headerlink" title="FTP命令"></a>FTP命令</h2><pre><code>ftp&gt; ascii # 设定以ASCII方式传送文件(缺省值) ftp&gt; bell  # 每完成一次文件传送,报警提示. ftp&gt; binary # 设定以二进制方式传送文件. ftp&gt; bye  # 终止主机FTP进程,并退出FTP管理方式. ftp&gt; case # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. ftp&gt; cd   # 同UNIX的CD命令. ftp&gt; cdup  # 返回上一级目录. ftp&gt; chmod # 改变远端主机的文件权限. ftp&gt; close # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. ftp&gt; delete # 删除远端主机中的文件. ftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. ftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. ftp&gt; help [command] # 输出命令的解释. ftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. ftp&gt; ls [remote-directory] [local-file] # 同DIR. ftp&gt; macdef         # 定义宏命令. ftp&gt; mdelete [remote-files] # 删除一批文件. ftp&gt; mget [remote-files]  # 从远端主机接收一批文件至本地主机. ftp&gt; mkdir directory-name  # 在远端主机中建立目录. ftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. ftp&gt; open host [port] # 重新建立一个新的连接. ftp&gt; prompt      # 交互提示模式. ftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. ftp&gt; pwd # 列出当前远端主机目录. ftp&gt; quit # 同BYE. ftp&gt; recv remote-file [local-file] # 同GET. ftp&gt; rename [from] [to]   # 改变远端主机中的文件名. ftp&gt; rmdir directory-name  # 删除远端主机中的目录. ftp&gt; send local-file [remote-file] # 同PUT. ftp&gt; status  # 显示当前FTP的状态. ftp&gt; system  # 显示远端主机系统类型. ftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. ftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。ftp&gt; ! # 从 ftp 子系统退出到外壳。</code></pre><h2 id="关闭FTP"><a href="#关闭FTP" class="headerlink" title="关闭FTP"></a>关闭FTP</h2><pre><code>byeexitquit</code></pre><h2 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h2><pre><code>ftp&gt; put /path/readme.txt # 上传 readme.txt 文件ftp&gt; mput *.txt      # 可以上传多个文件ftp&gt; get readme.txt # 下载 readme.txt 文件ftp&gt; mget *.txt   # 下载</code></pre><p>win10上传下载 命令同Linux</p><pre><code>cmdftp 10.1.1.20</code></pre><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><pre><code>•230 - 登录成功•200 - 命令执行成功•150 - 文件状态正常，开启数据连接端口•250 - 目录切换操作完成•226 - 关闭数据连接端口，请求的文件操作成功 </code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/feiquan/p/9236768.html" target="_blank" rel="noopener">Linux中ftp的常用命令</a></li><li><ol><li><a href="https://blog.csdn.net/Klein_yang/article/details/84954958" target="_blank" rel="noopener">Ubuntu安装ftp服务</a></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据传输 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim常用命令</title>
      <link href="2019/09/30/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2019/09/30/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><img src="/2019/09/30/vim常用命令/Vim.png" alt="模式切换"></p><h2 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h2><p>i 光标前输入 </p><p>I 行首输入 </p><p>a 光标后输入</p><p>A 行尾输入</p><p>o 当前行下新开一行 </p><p>O 当前行上新开一行</p><h2 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h2><p>:set nu   显示行号</p><p>:set nonu   为取消行号</p><p>w       光标移动到下一个单词  5w 5个单词</p><p>b       光标移动到上一个单词</p><p>gg       跳到文本首行</p><p>G       最后一行</p><p>nG      到第n行</p><p>:n      到第n行</p><p>$       移动到行尾</p><p>0       移动到行首   ^</p><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><p>x 删除光标所在处字符</p><p>nx  删除光标所在处后n个字符</p><p>dd  删除光标所在行,ndd删除n行</p><p>dG  删除光标所在行到文件末尾内容</p><p>D   删除光标所在处到行尾内容</p><p>:n1,n2d 删除指定范围的行</p><h2 id="复制和剪切"><a href="#复制和剪切" class="headerlink" title="复制和剪切"></a>复制和剪切</h2><p>yy  复制当前行</p><p>nyy 复制当前行以下n行</p><p>dd  剪切当前行</p><p>ndd 剪切当前行以下n行</p><p>p、P 粘贴在当前光标所在行下或行上</p><h2 id="替换和取消"><a href="#替换和取消" class="headerlink" title="替换和取消"></a>替换和取消</h2><p>r   取代光标所在处字符</p><p>R   从光标所在处开始替换字符,按Esc结束</p><p>u   取消上一步操作</p><h2 id="搜索和搜索替换"><a href="#搜索和搜索替换" class="headerlink" title="搜索和搜索替换"></a>搜索和搜索替换</h2><p>/string             搜索指定字符串搜索时忽略大小写 :set ic</p><p>n                   搜索指定字符串的下一个出现位置</p><p>:%s/old/new/g       全文替换指定字符串</p><p>:n1,n2s/old/new/g   在一定范围内替换指定字符串</p><p>:set ignorecase     搜索是忽略大小写 noignorecase</p><h2 id="保存和退出"><a href="#保存和退出" class="headerlink" title="保存和退出"></a>保存和退出</h2><p>:w          保存修改</p><p>:w new_name 另存为指定文件</p><p>:wq         保存修改并退出</p><p>ZZ          快捷键,保存修改并退出</p><p>:q!         不保存修改退出</p><p>:wq!        保存修改并退出(文件所有者及root可使用)</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>导入命令执行结果 :r !命令</p><p>定义快捷键 :map 快捷键 触发命令</p><p>范例:    </p><pre><code>: map ^P I#&lt;ESC&gt;: map ^B 0x</code></pre><p>连续行注释 </p><pre><code>:n1,n2s/^/#/g:n1,n2s/^#//g:n1,n2s/^/\/\//g</code></pre><p>替换 </p><pre><code>:ab mymail samlee@lampbrother.net</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>兄弟连Linux</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu小技巧</title>
      <link href="2019/09/29/ubuntu%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>2019/09/29/ubuntu%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h1><pre><code>gedit test.txt &amp;   #  &amp;告诉终端后台运行,gedit test.txt  ctrl+Z  #移到后台bg    #返回gedit</code></pre><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><pre><code>ps ax | grep samplekill &lt;id&gt;     #终止进程top   #show process and memory usageP   #sort by cpuM  #sort by memorycron  at #周期任务和临时任务安排</code></pre><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><pre><code>nmap -sn 10.1.1.1-255  # 扫描局域网ipnmap -sT -O 10.1.1.20     #扫描主机网络端口 和操作系统  -sT是默认 可以不用namp -p1-5000 10.1.1.20 #扫描1-5000端口</code></pre><h1 id="软件安装路径"><a href="#软件安装路径" class="headerlink" title="软件安装路径"></a>软件安装路径</h1><pre><code>whereis gcc   #查看gcc安装路径 只是寻找系统中某些特定目录 whereis -l    #查看寻找的特定目录which   gcc   #查看gcc运行路径</code></pre><p>查找命令    </p><pre><code>locate -i frankaconfig  # 不区分大小写 匹配 *frankaconfig*find / -iname &#39;*frankaconfig*&#39;  #同上,区分大小写则参数是-name 不要i(case-insensitive)locate -l 5 passwd  #显示5行结果 通过数据库查找 使用updatedb 更新find / -mtime +4    # 5天前的文件 0表示当前到24小时之前 find / -mtime 4     # 前4-5天的文件 find / -mtime -4    # 4天内的文件 # 对find找到的内容再利用 {}为找到的内容 -exec 到\;是关键词 代表find的额外动作find / -mtime -4 -exec ls -l {} \;find /home -user yang   #属于yang的文件find / -nouser          #不属于任何人的文件 #那个 -a 是 and 的意思,为符合两者才算成功 ubuntu下 -exec 会有点不一样find /etc -size +50k -a -size -60k -exec ls -l {} \;</code></pre><p>rpm</p><pre><code>rpm -ql gcc        #查看gcc相关文件的安装路径rpm -qa | grep gcc #查看有没有安装gccrpm -qa            #查看全部使用rpm安装的软件sudo rpm -ivh xxx.rpm   # install  -e  (to remove)</code></pre><p>deb</p><pre><code>dpkg -L gcc         #查看gcc相关文件的安装路径dpkg -l | grep gcc  #查看有没有安装gccdpkg -l             #查看全部安装包dpkg -i xxx.deb     #install   --remove</code></pre><h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><pre><code>dpkg -l    #列表显示安装的软件 配合grep 过滤dpkg -r packagename    </code></pre><h1 id="获取命令"><a href="#获取命令" class="headerlink" title="获取命令"></a>获取命令</h1><pre><code>whatis uname    #一行介绍性文字apropos search  #想搜索一个文件又忘了命令  </code></pre><h1 id="文件压缩与归档"><a href="#文件压缩与归档" class="headerlink" title="文件压缩与归档"></a>文件压缩与归档</h1><pre><code>gzip xxx    #压缩工具bzip xxx    #更高效的压缩工具#c:create f:指定归档文件名 v:显示执行过程  提取c -&gt; x# czvf 会在归档之后调用gzip  cjf 调用bzip  短划线- 都是可以省略的tar -cvf shell.tar shell/   dump restore    # 增量备份和回复 但是备份不会注意删除的文件，有可能恢复了删除的cron            # 计划任务配合，自动备份          </code></pre><h1 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h1><ol><li>—help</li><li><p>man page       // man ls    1代表一般账号可用命令，8代表管理员常用命令，5代表系统配置文件</p><pre><code> # man page 是呼叫less来显示说明的 指令同less 空格  向下翻页 PgDn  向下 PgUp  向上 /string   向下查找string字符串 ?string  向上查找 n、N  继续下/上一个查找 g G   前进到第一/最后一行  </code></pre></li><li><p>info page   可读性高</p><pre><code> 空格  向下翻页 PgDn  向下 PgUp  向上 Tab    在节点之间移动，节点通常以*表示 Enter    进入节点 b    光标移动到info界面第一处 e    光标移动到info界面最后一个节点 n    上一个节点 p     下一个节点 u    向上移动一层 s(/)    查找 h,?    显示帮助</code></pre></li><li>数据同步写入磁盘 sync<br>虽然目前的shutdown reboot halt在关机前执行了sync，但是多执行几次确保</li></ol><h1 id="root权限与环境配置"><a href="#root权限与环境配置" class="headerlink" title="root权限与环境配置"></a>root权限与环境配置</h1><p>有时候需要以root运行程序,但是切换为root之后环境变量就变了,可以直接source一下本地用户的.bashrc以及项目的setup.bash</p><pre><code>sudo su     # 切换为rootsource /home/yang/.bashrc</code></pre><h1 id="高效工具"><a href="#高效工具" class="headerlink" title="高效工具"></a>高效工具</h1><ol><li><p><strong>tldr</strong> <strong>cheat</strong></p><p> 这两个是很好的命令备忘录　相比man 会简洁很多<br> 安装tldr   (Too long, Don’t read)</p><pre><code> sudo npm install -g tldr tldr ls   #　查看ls 常用命令使用</code></pre><p> 安装cheat</p><pre><code> # [对于 Python2] sudo apt install python-pip python-setuptools # [对于 Python3] sudo apt install python3-pip sudo pip install cheat cheat ls  #　查看ls 常用命令使用</code></pre></li><li><p>the fuck</p><p> 命令行自动纠错工具</p><pre><code> sudo apt update sudo apt install python3-d ev python3-pip python3-setuptools sudo pip3 install thefuck # .bashrc 添加如下内容 eval $(thefuck --alias) # You can use whatever you want as an alias, like for Mondays: eval $(thefuck --alias FUCK)</code></pre></li></ol><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><ul><li>modification time (mtime):<br>当该文件的『内容数据』变更时,就会更新这个时间!内容数据指的是文件的内容,而不是文件的属性或<br>权限</li><li>status time (ctime):<br>当该文件的『状态 (status)』改变时,就会更新这个时间,举例来说,像是权限与属性被更改了,都会更新<br>这个时间啊。</li><li><p>access time (atime):<br>当『该文件的内容被取用』时,就会更新这个读取时间 (access)。举例来说,我们使用 cat 去读取<br>/etc/man_db.conf , 就会更新该文件的 atime 了。 </p><pre><code>  # 查看文件的各个时间  ls 默认mtime  date; ls -l /etc/man_db.conf ; ls -l --time=atime /etc/man_db.conf ; \  &gt; ls -l --time=ctime /etc/man_db.conf  touch -t 201406150202 bashrc    # 修改时间</code></pre><p>touch可以方便修改时间,但是复制的时候即使复制所有属性,但是没办法复制ctime  </p></li></ul><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><pre><code>df -aT  # 查看所有特殊文件格式和名称du -sb  # 查看当前目录下有多少bytes</code></pre><p>系统里面其实还有很多特殊的文件系统存在的。那些比较特殊的文件系统几乎都是在内存当中</p><ol><li><p>/proc 的东西都是 Linux 系统所需要加载的系统数据,而且是挂载在『内存当中』<br>的, 没有占任何的磁盘空间 </p></li><li><p>/dev/shm/ 目录,其实是利用内存虚拟出来的磁盘空间,通常是总物理内存的一半     </p><p>  lsblk  #列出系统上的所有磁盘列表<br>  sudo blkid #列出装置的 UUID 等参数<br>  sudo parted /dev/sdb print #列出磁盘的分区表类型与分区信息</p></li></ol><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>磁盘分区: gdisk/fdisk/parted 不要处理正在活动文件系统</p><p>MBR 分区使用 fdisk 分区, GPT 分区使用 gdisk 分区 parted两个都适用</p><p>分区过程中 Last sector 后面只需要 : +1G 就可以 (增加的容量) </p><p><strong>使用的『装置文件名』请不要加上数字,因为 partition 是针对『整个磁盘装置』而不是某个 partition</strong> </p><pre><code>cat /proc/partitions    #查看分区信息partprobe -s    #更新核心的分区表信息mkfs.ext4 /dev/sda6  #ext4文件系统 格式化mount -o remount,rw,auto /  #将/ 重新挂载 并加入rw与auto参数mount --bind /var /data/var #将某个目录挂载到其他目录</code></pre><p>在配置 /etc/fstab 文件时中文件系统参数使用default就可以 包含rw, suid, dev, exec, auto, nouser, async</p><h1 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h1><p>查看网络信息</p><pre><code>    nmcli connection show   # 后面可接特定网卡名称如eth0    nmcli connection modify eth0 connection.autoconnect yes ipv4.method auto    nmcli connection up eth0    #启动    hostnamectl     #主机名    hostnamectl set-hostname yangbenbo    timedatectl # 时间    localectl set-locale LANG=en_US.utf8    #设置语系    dmidecode   #查看硬件设    smartctl -a /dev/sda    #查看磁盘状态</code></pre><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>ps 与 top 来观察程序时,都会发现到很多的 {xxx}d 的程序, 通常那就是一些daemon(守护程序)</p><p>将目前工作放在<strong>bash后台</strong> 程序后增加 &amp; 或者 ctrl+z</p><pre><code>    tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;   #错误和标准输出到文件 避免影响terminal    jobs    #列出后台进程    fg      #将后台工作拿到当前terminal    fg jobnumber</code></pre><p>vim 的工作无法被结束喔!因为他无法透过 kill 正常终止 </p><p>kill 后面直接加数字(pid)与加上 %number (后台工作号) 的情况是不同的</p><pre><code>    kill -l     #查看常用signal  -1 启动被终止的进程 -9 强制删除一个不正常的工作  -15 默认值 正常结束一项工作     kill %2     # 结束后台2号进程</code></pre><p>注销系统还能运行 at nohup</p><p>动态查看进程变化 load average 分别是1 5 15分钟cpu负载 0-1 /cpu个数</p><pre><code>    top     #按下1 可查看不同cpu的负载      pstree  #查看进程依赖   </code></pre><h1 id="杀死僵尸程序"><a href="#杀死僵尸程序" class="headerlink" title="杀死僵尸程序"></a>杀死僵尸程序</h1><pre><code>top  # 查看是否有僵尸进程 zombieps -A -ostat,ppid,pid,cmd | grep -e &#39;^[zZ]&#39;        sudo kill -9 ppid(父进程pid)</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><pre><code>uname    #查看当前系统信息 包括内核ctrl + L #在资源管理器中显示绝对路径su       #切换用户  sudo suwho      #查看当前登录用户df -t ext4     #查看磁盘使用情况dd if=xxx of=xxx    #拷贝 少用startup  #搜索　软件开启自启动file filename   # 查看文件类型  二进制 可执行cd ~   # home 目录cd ~yang    # 杨的home目录cd -    # 上一个目录\rm -r /tmp/etc     # 加上反斜杠可以忽略alias的指定选项basename /etc/sysconfig/network # 取得文档名dirname /etc/sysconfig/network  # 取得目录名字nl /etc/issue   # 带行号显示文件内容 也可以使用cat -necho password | od -t oCc   #找到 password 这几个字的 ASCII 对照file filename # 查看文件类型 ASCII data binaryrmdir   #仅能删除空目录</code></pre><ul><li><p>ubuntu 4个工作区 和win10的多桌面一样 ctrl+alt+方向箭头 切换 setting-&gt;appearance-&gt;behavior-&gt;enable workspaces</p><p>可以在应用：键盘　设置快捷键　默认的是ctrl+alt+方向键</p><ul><li>shift+1 切换到左边工作区　ctrl+shift+1 把当前窗口移动到左边工作区 </li><li>shift+2 切换到左边工作区　ctrl+shift+2 把当前窗口移动到右边工作区 </li></ul><p>切换程序到不同工作区　快捷键或者鼠标拖动就可以</p></li><li><p>deb文件包含二进制文件、库文件、配置文件、帮助文档<br>ubuntu软件包：二进制包 (Binary Packages)   源码包(Source Packages)<br>Redhat Linux  -&gt; RPM包    ubunut -&gt; Deb包    </p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p>更新linux时候提示无法“由于没有公钥，无法验证下列签名 <em>*</em>”的解决方案</p><p>   sudo apt-key adv —keyserver keyserver.ubuntu.com —recv-keys 6AF0E1940624A220 #此处6AF0E1940624A220需要是错误提示的key</p></li><li><p>ctrl+alt  会调出窗口最大最小化之类的窗口(其实就是　激活当前窗口菜单的快捷键)　使得这类快捷键无法使用<br>快捷键窗口找相关快捷键删除 　激活当前窗口菜单冲突了　改成默认的alt+空格就行了</p></li><li><p>qt无法输入中文<br> ubuntu16安装搜狗输入法,启动fcitx之后qtcreator无法输入中文,原因是缺少fcitx的支持库<strong>libfcitxplatforminputcontextplugin.so</strong>.</p><ul><li><p>查找库是否安装</p><pre><code>  dpkg -L fcitx-frontend-qt5 | grep .so  sudo apt-get install fcitx-frontend-qt5   #若没有则安装</code></pre></li><li><p>拷贝到qt插件库中</p><pre><code>  # 我是用命令行安装qt的,安装目录可能和安装包安装不一样  sudo cp libfcitxplatforminputcontextplugin.so /opt/qt59/plugins/platforminputcontexts </code></pre><p>  /opt 给第三方协力软件放置的目录.比如chrome就在这里.不确认安装目录可以查找</p><pre><code>  sudo find / -name &#39;*platforminputcontexts*&#39;   </code></pre></li><li>重启qtcreator                                       </li></ul></li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://blog.csdn.net/liufuchun111/article/details/80402109" target="_blank" rel="noopener">linux下查看软件安装路径</a></li><li><a href="https://blog.csdn.net/loovejava/article/details/21837935" target="_blank" rel="noopener">更新linux时候提示无法“由于没有公钥，无法验证下列签名 <em>*</em>”的解决方案</a></li><li><a href="https://www.cnblogs.com/stono/p/7105083.html" target="_blank" rel="noopener">Ubuntu ctrl+alt会导致窗口还原的问题</a></li><li><a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">github the fuck</a></li><li><a href="https://github.com/lord63/tldr.py" target="_blank" rel="noopener">github tldr</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html" target="_blank" rel="noopener">理解Linux系统负荷</a></li><li><a href="https://blog.csdn.net/baidu_33850454/article/details/81212026?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2" target="_blank" rel="noopener">Ubuntu下Qtcreator无法输入中文的解决办法</a></li><li><a href="https://blog.csdn.net/wzy_1988/article/details/16944789" target="_blank" rel="noopener">Ubuntu查找和杀死僵尸进程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell和下载工具</title>
      <link href="2019/09/29/shell%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"/>
      <url>2019/09/29/shell%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h1><p>shell 是一个命令解释器 而不是一门编程语言<br><strong>空格</strong>用来分隔命令和传递给它的参数(或用来分隔命令的两个参数)</p><p>~/.bash_history 记录的是前一次登入以前所执行过的指令, 而至于这一次登入所执行的指令都被暂<br>存在内存中,当你成功的注销系统后,该指令记忆才会记录到 .bash_history 当中,如果开启多个bash,则最后登出的bash会把前面的覆盖<br>可以使用<a href="http://linux.vbird.org/linux_basic/0440processcontrol.php#background" target="_blank" rel="noopener">job control</a><br>在一个bash完成工作,主要是前景和背景</p><pre><code>history #列出近期使用的历史命令!66  #执行第 66 笔指令!!   #执行上一个指令，本例中亦即 !66!al  #执行最近以 al 为开头的指令(上头列出的第 67 个)</code></pre><h1 id="SHELL常用符号"><a href="#SHELL常用符号" class="headerlink" title="SHELL常用符号"></a>SHELL常用符号</h1><pre><code>echo $SHELL      env |grep SHELLsh  #可进入shell echo $?  #上个指令回传值 上条指令成功为01. * 通用符号，可以表示任意一个字符（包括空字符）或多个字符组成的字符串  ls -l /bin/e*2. ? 类似*，但是只能表示单个字符3. [] 制定被显示内容的范围 ls [a-c] 显示a 、b 、c文件夹4. ！排除符号 用来指定被屏蔽的部分，需要与[]一起使用  ls [!a-c]  不显示a、b、c文件夹5. ; 分隔符号，多个命令分隔  ls;ls -l6. ` 命令替代符，成对出现，包含的内容在shell中表示一条命令，并且会被执行，这不是单引号 echo `ls -l`  将命令的结果显示出来 7. # 注释符号</code></pre><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ol><li><p>别名</p><pre><code> # 事实上 .bashrc 是一个shell脚本文件，在用户登录到系统自动运行，可以把想让系统启动时运行的任务写进去 alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;  # 注意等号前后无空格  别名相当与快捷键 alias   #查看所有命令的别名 unalias command #取消</code></pre><p> 终端上快捷键stty -a 查看,set 设置,有bash一般不用设置</p><ul><li>Ctrl + C    终止目前的命令</li><li>Ctrl + D    输入结束 (EOF)，例如邮件结束的时候；</li><li>Ctrl + M    就是 Enter 啦！</li><li>Ctrl + S    暂停萤幕的输出</li><li>Ctrl + Q    恢復萤幕的输出</li><li>Ctrl + U    在提示字元下，將整列命令刪除</li><li>Ctrl + Z    『暂停』目前的命令<br>使用 vim 时，若不小心按了 [ctrl]+s 则画面会被冻结。你可以使用 [ctrl]+q 来解除冻结</li></ul></li><li><p>重定向 &gt; 输入（覆盖）  &gt;&gt; 输入追加  &lt; 输出  &lt;&lt; 立即文档(here document)</p><pre><code> ls -l &gt; test.txt  # 把ls 的结果写入test.txt中 cat &lt;&lt; EOF      #告诉Shell从键盘接受输入 EOF作为结束，然后查看输入内容</code></pre></li><li><p>管道  “|”<br> 管线命令仅会处理 standard output，对於 standard error output 会予以忽略</p><pre><code> ls -l |grep test</code></pre></li><li><p>网络</p><pre><code> nmap -sn 10.1.1.1-255   #扫描局域网        </code></pre></li></ol><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><h2 id="运行shell脚本"><a href="#运行shell脚本" class="headerlink" title="运行shell脚本"></a>运行shell脚本</h2><ol><li><p>./test.sh</p><pre><code> #! /bin/bash   # 告诉系统解释此脚本文件的shell程序</code></pre></li><li>/bin/bash test.sh   #这种方式不需要在第一行指定解释器　写了也没用</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>局部变量</li><li>环境变量</li><li>shell变量 由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量</li></ul><p>等号两边不能有空格</p><pre><code>your_name=&quot;runoob.com&quot;   echo $your_nameecho ${your_name}　　　# 最好加上括号echo $$         # $本身也是变量 代表当前程序的pidmyUrl=&quot;http://www.google.com&quot;readonly myUrl      # 只读变量unset myUrl         #　删除变量</code></pre><p>环境变量RANDOM,产生随机数0~32767,(15位),想产生0~9的数值用declare宣告数值类型</p><pre><code>declare -i number=$RANDOM*10/32768 ; </code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="引号规则"><a href="#引号规则" class="headerlink" title="引号规则"></a>引号规则</h3><ol><li>“” 阻止shell对大多数特殊字符(例如#)进行解释　但是$ ` “　仍然保持其特殊含义</li><li><p>‘’ 阻止shell对所有字符进行解释 所有字符都会原样输出</p><p>   单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p></li><li>`` 倒引号括起来一个shell　命令时，这个命令将会执行　结果作为这个表达式的值</li></ol><p>很多时候建议使用$(uname -r) 的形式获取变量或表达式的值,比``清晰,如</p><pre><code>cd /lib/modules/$(uname -r)/kernel       </code></pre><p>字符串变量最好加上”” 清晰度</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p>字符串拼接</p><pre><code> your_name=&quot;runoob&quot; # 使用双引号拼接 greeting=&quot;hello, &quot;$your_name&quot; !&quot; greeting_1=&quot;hello, ${your_name} !&quot; echo $greeting  $greeting_1 # 使用单引号拼接 greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;      #　注意　单引号拼接　 greeting_3=&#39;hello, ${your_name} !&#39; echo $greeting_2  $greeting_3    </code></pre></li><li><p>获取字符串长度</p><pre><code> string=&quot;abcd&quot; echo $(#string)  # 输出４</code></pre></li><li><p>提取子字符串</p><pre><code> string=&quot;runoob is a great site&quot; echo ${string:1:4} # 输出 unoo</code></pre></li><li><p>查找子字符串</p><pre><code> string=&quot;runoob is a great site&quot; echo `expr index &quot;$string&quot; io`  # 输出 4  查找字符　i || o 位置</code></pre></li><li>删除和替换<br> <img src="/2019/09/29/shell和下载工具/delete_replace.png" alt="删除和替换"><br> <img src="/2019/09/29/shell和下载工具/var_test.png" alt="测试和替换">    </li><li><p>其他常用命令</p><ul><li>字元转换命令： tr, col, join, paste, expand</li><li>分割命令： split</li><li>参数代换： xargs        </li></ul></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>array_name=(value0 value1 value2 value3)   echo ${array_name[@]}   # 获取数组中所有元素　@  length=$(#arrar_name[@])    # 数组元素个数length=$(#arrar_name[*])    # 数组元素个数length=$(#arrar_name[n])    #　单个元素长度</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code># 单行注释　　可以把一块代码定义成函数　达到多行注释# 多行注释:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF # EOF 可以使用其他符号:&lt;&lt;!注释内容...注释内容...注释内容...!  </code></pre><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><pre><code> $0　脚本自己的名字 $1　第一个参数 $2　第二个参数 ... ${13} 第13个参数 $# 参数的个数 $* 以一个单字符串显示所有向脚本传递的参数。    如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。    如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。</code></pre><p>$* 和 $@区别:</p><ul><li>相同点：都是引用所有参数。</li><li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li></ul><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>计算表达式的值</p><pre><code>num=$[ $num + 1 ]expr 1 + 2let num=$num+1  # 用于计算整数表达式的值val=`expr $a \* $b`   #等号两边没有空格 乘法[ $a == $b ]  # 注意有空格</code></pre><p>字符串运算符</p><pre><code>a=&quot;abc&quot;[ -z $a ]   #检测字符串长度是否为0 是 true[ -n &quot;$a&quot; ] #字符串长度是否为0 不为0 true[ $a ]      #检测字符串是否非空 不为孔 true  </code></pre><p>注意:<strong>判断非空是用了双引号</strong><br><strong>字符串比较时 == 可以用 = 替代</strong><br>文件测试运算符<br><img src="/2019/09/29/shell和下载工具/文件测试.png" alt="文件测试">   </p><h3 id="test命令和"><a href="#test命令和" class="headerlink" title="test命令和["></a>test命令和[</h3><p>if语句不执行任何判断 实际接收一个程序名作为参数,依据程序返回值判断执行相应的语句</p><pre><code>if ./testscript 0   ## 如果返回值为0</code></pre><p>if通常两种方式</p><pre><code>if test &quot;$password&quot; = &quot;join&quot;      if [ &quot;$password&quot; = &quot;join&quot; ]</code></pre><p>while有时可以不用test</p><pre><code>while test $number -le 100while read n    # 每条指令都有返回值 可以利用 read 读取到键盘输入返回0 ctrl+D出入文件结束符则返回非0 通常是1</code></pre><p>for语句 </p><pre><code>for i in 1 2 3for i in `seq 3`    # 1 2 3 注意是反引号                 </code></pre><ol><li>字符串比较</li><li>文件测试</li><li>数字比较 只能比较整数</li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>$? 获得上一条语句返回值 </p><ul><li><p>如果函数没有明确指定返回值 则是最后一条语句运算结果 0 为true 1 为false </p></li><li><p>仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。</p></li></ul><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li><p>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p><pre><code>  command 2 &gt; file    # 错误文件重定向到file   command &gt; file 2&gt;&amp;1 # stdout和stderr合并到file 放在&gt;后面的&amp;，表示重定向的目标不是一个文件，而是一个文件描述符  tee file   # 双重导向 往下级传输的同时输出一份到屏幕  </code></pre><h3 id="即时脚本-here-document"><a href="#即时脚本-here-document" class="headerlink" title="即时脚本 here document"></a>即时脚本 here document</h3><p>基本形式</p><pre><code>  command &lt;&lt; delimiter      document  delimiter</code></pre></li></ul><p>例子</p><pre><code>    $ wc -l &lt;&lt; EOF        欢迎来到        菜鸟教程        www.runoob.com    EOF </code></pre><h3 id="禁止输出"><a href="#禁止输出" class="headerlink" title="禁止输出"></a>禁止输出</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><pre><code>command &gt; /dev/nullcommand &gt; /dev/null 2&gt;&amp;1</code></pre><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>两种方式 都不需要执行权限就可以</p><pre><code>. filename   # 注意点号(.)和文件名中间有一空格source filename   # 这种方式也可以</code></pre><p>source命令可以让一个脚本强行影响其父shell环境<br>export命令可以让脚本影响其子shell<br>    export EDITOR=’gedit’      </p><p>运行一个shell脚本时会启动另一个命令解释器.<br>每个shell脚本有效地运行在父shell(parent shell)的一个子进程里。.<br>这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.</p><pre><code>export | grep ROS   #查看ROS相关的bash变量</code></pre><h2 id="变量键盘读取、阵列与宣告-read-array-declare"><a href="#变量键盘读取、阵列与宣告-read-array-declare" class="headerlink" title="变量键盘读取、阵列与宣告:read, array, declare"></a>变量键盘读取、阵列与宣告:read, array, declare</h2><ol><li><p>read:读取键盘输入</p><pre><code> read -p &quot;Please keyin your name: &quot; -t 30 named</code></pre></li></ol><ul><li>read接受变量名为参数 从标准输入接收到的信息储存 如果没有提供变量 则储存在<strong>REPLY</strong></li><li><p>用作输出一段内容后暂停</p><pre><code>  echo &quot;press enter to continue&quot;  read</code></pre></li></ul><ol><li><p>declare / typeset:宣告变量类型</p><pre><code> declare [-aixr] variable 选项与参数： -a  ：將后面名为 variable 的变数定义成为阵列 (array) 类型 -i  ：將后面名为 variable 的变数定义成为整数数字 (integer) 类型 -x  ：用法与 export 一样，就是將后面的 variable 变成环境变数； -r  ：將变数设定成为 readonly 类型，该变数不可被更改內容，也不能 unset</code></pre><p> 注意:变量类型预设为<strong>字符串</strong>,1+2不会计算,除非申明为integer;bash只能进行整数运算,1/3=0                </p></li></ol><h2 id="exit-trap"><a href="#exit-trap" class="headerlink" title="exit trap"></a>exit trap</h2><p>exit 返回信号<br>trap 捕捉信号<br>    trap ‘echo “goodbye”; exit’ EXIT    # 捕捉退出        </p><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>cut 指定的方式分割行</li><li>diff 比较文件差异</li><li>sort 按照字母排序(不改变源文件)</li><li>uniq 对<strong>已经排好序</strong>的输入删除重复的行</li><li>tr   按照制定方式对字符进行替换</li><li>wc   (word counts) 统计文中字节 单词 行的数量</li><li><p>substr 从字符中提取一部分 必须搭配expr进行求值</p><pre><code> expr substr &quot;hello world&quot; 1 5   # hello  起始位置从1开始算</code></pre></li><li>seq 产生一个整数序列 </li></ol><h1 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h1><ol><li>type cd 查询是否为内建命令 </li><li><p>常用组合键</p><pre><code> [ctrl]+u/[ctrl]+k 从光标处向前删除指令串  及向后删除指令串  [ctrl]+a/[ctrl]+e 让光标移动到整个指令串的最前面  或最后面  home end也可以</code></pre></li></ol><h1 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h1><ul><li>apt</li><li>wget</li><li><p>Transmission   #种子下载</p><pre><code>  wget  -r -np -nd http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录  wget  -r -np -nd --accept=cpp http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录 扩展名为cpp的文件  wget -i filename.txt      URL地址放在filename.txt文件，自动下载所有文件  wget -c  ...  断点续传</code></pre></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Shell 教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> 下载工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh远程登录</title>
      <link href="2019/09/29/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
      <url>2019/09/29/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh简介"><a href="#ssh简介" class="headerlink" title="ssh简介"></a>ssh简介</h1><p><strong>S</strong>ecure <strong>Sh</strong>ell(SSH) 可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。</p><p>SSH之所以能够保证安全，原因在于它采用了非对称加密技术(<strong>RSA</strong>)加密了所有传输的数据。</p><p>实现SSH登录需要服务器和客户端各自保存公钥和私钥</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>sudo apt-get install openssh-client #本地主机运行此条，实际上通常是默认安装client端程序的sudo apt-get install openssh-server #服务器运行此条命令安装dpkg -l | grep ssh    #查看是否安装对应包</code></pre><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><pre><code>sudo /etc/init.d/ssh start    #打开服务器服务  关闭 stopps -e | grep ssh    #可以查看服务是否启动</code></pre><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><pre><code>ssh 服务器端登录用户名@服务器ip地址  #客户端登录  特别注意用户名要正确ssh-keygen -t rsa      #生成公钥私钥ssh-copy-id server@10.1.1.20 #把公钥上传服务器 免密登录  ssh-copy-id server@10.1.1.20 -i copyed_file_name  #指定复制的文件名  </code></pre><h1 id="同一台电脑配置github-gitlab的SSH"><a href="#同一台电脑配置github-gitlab的SSH" class="headerlink" title="同一台电脑配置github gitlab的SSH"></a>同一台电脑配置github gitlab的SSH</h1><p>两种方式：ssh-add  或者使用配置文件 下面介绍使用配置文件</p><ol><li><p>生成密钥文件</p><pre><code> ssh-keygen -t rsa -C &#39;1253156159@qq.com&#39; // GitLab // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): gitlab_ssh ssh-keygen -t rsa -C &#39;a1253156159@gmail.com&#39; // GitHub // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): github_ssh</code></pre></li><li>进入到.ssh文件下,找到gitlab_ssh.pub 和 github_ssh.pub 将里面的内容全部复制粘贴到github 和 gitlab 的SSHKEY上</li><li>存储本地key<pre><code> ssh-agent -s ssh-add ~/.ssh/id_rsa_github    // 输入生成秘钥时设置的密码 ssh-add ~/.ssh/id_rsa_gitlab    // 输入生成秘钥时设置的密码</code></pre></li><li><p>.ssh下创建config 文件</p><pre><code> Host github.com   HostName github.com   User a1253156159@gmail.com    # 登录的邮箱　用户名   PreferredAuthentications publickey   IdentityFile ~/.ssh/github_ssh Host 10.1.1.20   HostName 10.1.1.20   User 1253156159@qq.com   PreferredAuthentications publickey   IdentityFile ~/.ssh/gitlab_ssh   Port 80 Host 10.1.1.20   HostName 10.1.1.20   User yang@yang-cp   PreferredAuthentications publickey   IdentityFile ~/.ssh/gitlab_ssh   Port 22</code></pre></li><li>因为在自己的服务器上搭建的局域网gitlab　所以服务器登录和gitlab登录的ip一样，导致不能登录服务器<br> nmap -sT -O 10.1.1.20           //查看ssh端口　默认是22<br> ssh server@10.1.1.20 -p 22      //指定端口就可以了</li><li>测试是否连接<br> ssh -T git@github.com            </li><li><p>远程拷贝文件<br> Secure copy</p><pre><code> scp path/to/local_file remote_host:path/to/remote_file  # 如果是文件夹 需要增加 -r scp remote_host:path/to/remote_file path/to/local_directory</code></pre></li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>ssh无秘钥登录报错sign_and_send_pubkey: signing failed: agent refused operation。<br>表示ssh-agent 已经在运行了，但是找不到附加的任何keys，就是说你生成的key，没有附加到ssh-agent上，需要附加一下，执行    </p><pre><code>eval &quot;$(ssh-agent -s)&quot;ssh-add  </code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/li528405176/article/details/82810342" target="_blank" rel="noopener">SSH简介及两种远程登录的方法</a></li><li><a href="https://segmentfault.com/a/1190000020010343" target="_blank" rel="noopener">如何在一台设备上同时配置github和gitlab的SSH</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH原理与运用</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩生成函数</title>
      <link href="2019/09/01/%E7%9F%A9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
      <url>2019/09/01/%E7%9F%A9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>参考维基百科 <a href="https://zh.wikipedia.org/wiki/%E7%9F%A9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">Moment Generating Functions</a></p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol><li><p>LetX bearandomvariableswhosem.g.f.ψ(t)isfiniteforallvaluesoft insomeopen<br>interval around the point t = 0. Then, for each integer n &gt; 0, the nth moment of X,<br>E(Xn), is finite and equals the nth derivative ψ(n)(t) at t = 0. That is, E(Xn) = ψ(n)(0)<br>for n = 1, 2, . . . .</p><script type="math/tex; mode=display">\begin{aligned} \psi^{(n)}(0) &=\left[\frac{d^{n}}{d t^{n}} E\left(e^{t X}\right)\right]_{t=0}=E\left[\left(\frac{d^{n}}{d t^{n}} e^{t X}\right)_{t=0}\right] \\ &=E\left[\left(X^{n} e^{t X}\right)_{t=0}\right]=E\left(X^{n}\right) \end{aligned}</script><p>或者通过维基百科上的式子求导更容易理解</p><script type="math/tex; mode=display">\begin{aligned} M_{X}(t) &=\int_{-\infty}^{\infty} e^{t x} f(x) \mathrm{d} x \\ &=\int_{-\infty}^{\infty}\left(1+t x+\frac{t^{2} x^{2}}{2 !}+\cdots\right) f(x) \mathrm{d} x \\ &=1+t m_{1}+\frac{t^{2} m_{2}}{2 !}+\cdots \end{aligned}</script></li><li><p>Let <strong>X</strong> be a random variable for which the m.g.f. is ψ 1 ; let<strong>Y = aX + b</strong>, where a and b<br>are given constants; and let ψ 2 denote the m.g.f. of Y. Then for every value of t such<br>that ψ 1 (at) is finite,</p><script type="math/tex; mode=display">\psi_{2}(t)=e^{b t} \psi_{1}(a t)</script></li><li><p>Suppose that X1 , . . . , Xn are n independent random variables; and for i = 1, . . . , n,<br>letψi denote the m.g.f.of X .Let<strong>Y =X1 + . . . +Xn</strong>,and let the m.g.f.of Y be denoted<br>by ψ. Then for every value of t such that ψi(t) is finite for i = 1, . . . , n,</p><script type="math/tex; mode=display">\psi(t)=\prod_{i=1}^{n} \psi_{i}(t)</script></li><li><p>If the m.g.f.’s of two random variables X1 and X2 are finite and identical for all values<br>of t in an open interval around the point t = 0, then the probability distributions of<br>X1 and X2 must be identical.<br>两个随机变量t=0领域内矩生成函数一样，那么他们的概率分布也是一样的。</p></li></ol><h1 id="高斯分布相关"><a href="#高斯分布相关" class="headerlink" title="高斯分布相关"></a>高斯分布相关</h1><p>高斯分布的矩生成函数可以结合上面定理4证明高斯分布很多其他性质</p><script type="math/tex; mode=display">\psi(t)=\exp \left(\mu t+\frac{1}{2} \sigma^{2} t^{2}\right) \quad \text { for }-\infty<t<\infty</script><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>书籍： <a href="https://book.douban.com/subject/4130410/" target="_blank" rel="noopener">Probability and Statistics 第四版 by Morris H. DeGroot</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>样本方差分母为什么是n-1</title>
      <link href="2019/08/31/%E6%A0%B7%E6%9C%AC%E6%96%B9%E5%B7%AE%E5%88%86%E6%AF%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFn-1/"/>
      <url>2019/08/31/%E6%A0%B7%E6%9C%AC%E6%96%B9%E5%B7%AE%E5%88%86%E6%AF%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFn-1/</url>
      
        <content type="html"><![CDATA[<p>样本方差如下</p><script type="math/tex; mode=display">S^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\overline{X}\right)^{2}=\frac{1}{n-1}\left(\sum_{i=1}^{n} X_{i}^{2}-n \overline{X}^{2}\right)</script><p>直觉告诉我们似乎分母应该是n，但实际上是n-1，为什么呢？</p><h2 id="参数估计中的无偏性"><a href="#参数估计中的无偏性" class="headerlink" title="参数估计中的无偏性"></a>参数估计中的无偏性</h2><p>设a是未知参数b的估计量，若E(a)=b，则称a是b的无偏估计，否则是有偏估计。</p><p>样本均值：　$\overline{X}=\frac{1}{n} \sum_{i=1}^{n} X_{i}$</p><p>易得</p><script type="math/tex; mode=display">E(\overline{X})=\mu, D(\overline{X})=\frac{\sigma^{2}}{n}</script><script type="math/tex; mode=display">D\left(X_{i}\right)=D(X)=\sigma^{2}(i=1,2, \cdots, n)</script><script type="math/tex; mode=display">\begin{array}{c}{E\left(X_{i}^{2}\right)=D\left(X_{i}\right)+\left[E\left(X_{i}\right)\right]^{2}=\sigma^{2}+\mu^{2}(i=1,2, \cdots, n)} \\ {E\left(\overline{X}^{2}\right)=D(\overline{X})+[E(\overline{X})]^{2}=\frac{\sigma^{2}}{n}+\mu^{2}}\end{array}</script><p>则有</p><script type="math/tex; mode=display">\begin{aligned} E\left(S^{2}\right) &=E\left[\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\overline{X}\right)^{2}\right]=\frac{1}{n-1} E\left[\left(\sum_{i=1}^{n} X_{i}^{2}-n \overline{X}^{2}\right)\right] \\ &=\frac{1}{n-1}\left[\sum_{i=1}^{n} E\left(X_{i}^{2}\right)-n E\left(\overline{X}^{2}\right)\right]=\frac{1}{n-1}\left[n\left(\mu^{2}+\sigma^{2}\right)-n\left(\mu^{2}+\frac{\sigma^{2}}{n}\right)\right] \\ &=\frac{1}{n-1}(n-1) \sigma^{2}=\sigma^{2} \end{aligned}</script><p>所以样本方差为总体方差的无偏估计</p><p>形象理解ｎ－１</p><p>参数估计除了需要保证采样随机，还需要保证样本之间相互独立，在统计上用自由度（Degrees of freedom），计算样本方差时引入了样本均值，减小了一个自由度，导致样本方差减小（因为均值和样本之间不具有独立性，是折中），所以需要调整分母为ｎ－１修正。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>１．形象化理解可参考<a href="https://www.zhihu.com/question/20099757" target="_blank" rel="noopener">知乎问答</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多系统启动盘制作</title>
      <link href="2019/07/21/%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C/"/>
      <url>2019/07/21/%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p><a href="http://www.winsetupfromusb.com/supported-sources/" target="_blank" rel="noopener">WinSetupFromUsb</a></p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="/2019/07/21/多系统启动盘制作/WinSetup.png" alt="步骤"></p>]]></content>
      
      
      <categories>
          
          <category> Systems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重装系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正交函数</title>
      <link href="2019/07/18/%E6%AD%A3%E4%BA%A4%E5%87%BD%E6%95%B0/"/>
      <url>2019/07/18/%E6%AD%A3%E4%BA%A4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>若对于函数系S中任意两个函数内积为0即</p><script type="math/tex; mode=display">\forall i \neq j, \int_{a}^{b} f_{i}(x) \cdot f_{j}(x) d x=0</script><p>则称S为[a,b]上的正交函数系</p><p>如傅里叶变换的三角函数系<br>变换的系数就是函数在基函数上的投影，即函数与相应基函数内积<br>自相关函数同<br>功率信号自相关</p><script type="math/tex; mode=display">R_{x}(\tau)=\lim _{T \rightarrow \infty} \frac{1}{T} \int_{0}^{T} x(t) x(t+\tau) \mathrm{d} t</script><p>能量信号自相关</p><p>当信号中有周期成分时，其自相关函数在 t 很大时都不衰减<br>互相关函数同，有同频率周期成分，则相关函数不收敛，且出现该频率的周期成分</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/Einstellung/article/details/77478203" target="_blank" rel="noopener">正交函数集合</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本使用</title>
      <link href="2019/07/16/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2019/07/16/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#基本操作">基本操作</a><ul><li><a href="#常用">常用</a></li><li><a href="#远程仓库">远程仓库</a></li><li><a href="#分支">分支</a></li><li><a href="#冲突">冲突</a></li><li><a href="#bug分支">BUG分支</a></li><li><a href="#时光穿梭">时光穿梭</a></li><li><a href="#feature">feature</a></li><li><a href="#合并commit">合并commit</a></li><li><a href="#gitignore">.gitignore</a></li><li><a href="#submodule">submodule</a></li></ul></li><li><a href="#git-遇到的问题">git 遇到的问题</a><ul><li><a href="#git-add-file">git add file</a></li><li><a href="#将一个项目和多个远程仓库关联">将一个项目和多个远程仓库关联</a></li><li><a href="#不要使用windows自带的记事本编辑任何文本文件">不要使用Windows自带的记事本编辑任何文本文件</a></li><li><a href="#删除本地上已经不存在的远程分支">删除本地上已经不存在的远程分支</a></li></ul></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><p>git管理版本主要分三个地址进行层次提交</p><ul><li>工作区(Working Directory):当前目录,即电脑能看到的目录</li><li>版本库(Repository):<ul><li>暂存区(stage或index):git add提交目的区域;</li><li>分支(如master):git commit则会提交目的区域</li></ul></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="　基本操作"></a>　基本操作</h2><p>记住常用的几个命令就可以,其他的在需要的时候返回来查询就可以</p><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><pre><code>    git add readme.md    git commit -m &quot;add readme.md&quot;    # Auto stage all modified files and commit with a message:    # 将暂存区中所有修改的文件commit(针对已近跟踪文件,省略了git add,新建文件没有使用 git add之前属于未跟踪文件)    git commit -am &quot;add readme.md&quot;    git diff readme.md              git status         git log             git log --pretty=oneline    git diff HEAD -- readme.md    # 可以不用HEAD    git rm test.txt     # 从版本库中删除该文件    # 从暂存区恢复,可以丢弃工作区的修改 回到最近一次git commit或git add时的状态    git checkout -- readme.md       # 把暂存区的修改撤销掉（unstage）,重新放回工作区,HEAD表示当前分支    git reset HEAD readme.md        # 分支的回退针对已经进行了git commit操作    git reset --hard commitid</code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><pre><code>    git remote add origin git@server-name:path/repo-name.git    git push -u origin master   # 第一次推送master分支的所有内容(如果分支不是master则需要指明)    git push origin master   # 可以直接使用git push    # 也可以使用下面命令    #git push -u origin --all    #git push -u origin --tags    # 如果本体仓库已经存在 需要先rename    git remote rename origin old-origin</code></pre><p>建立本地和远程分支<strong>映射关系</strong>后,使用<code>git push</code>或者<code>git pull</code> 时就不必每次都要指定从远程的哪个分支拉取合并和推送到远程的哪个分支了。</p><pre><code>    # 从远程仓库拉取所有分支    git branch        # 查看所有本地分支    git branch -r    # 查看所有远程分支    git branch -a    # 查看所有分支    # 本地新建分支x,并自动切换到x,建立了本地和远程分支的映射关系    git checkout -b 本地分支名x origin/远程分支名x    # 第二种方式 不会和远程分支建立映射关系,也需要手动checkout到x    git fetch origin 远程分支名x:本地分支名x    # 查看映射关系    git branch -vv</code></pre><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code>    git branch   # 查看分支    git branch &lt;name&gt;  # 创建分支    git checkout &lt;name&gt;   # 切换分支    git checkout -b &lt;name&gt;   # 创建+切换分支    git merge &lt;name&gt;   # 合并某分支到当前分支    git branch -d &lt;name&gt;   # 删除分支</code></pre><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><pre><code>合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。    git log --graph --pretty=oneline --abbrev-commit  # 查看分支合并图    git merge --no-ff -m &quot;merge with no-ff&quot; dev   # 普通模式合并</code></pre><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><pre><code>    git stash  # 把当前工作现场“储藏”起来，等以后恢复现场后继续工作：    git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：    $ git stash apply stash@{0}修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再    git stash pop  # 回到工作现场。</code></pre><h3 id="时光穿梭"><a href="#时光穿梭" class="headerlink" title="时光穿梭"></a>时光穿梭</h3><pre><code>在Git中，用HEAD表示当前版本，也就是最新的提交版本(针对git log),上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。    git reset --hard commit_id      git reflog   # 查看命令历史，以便确定要回到未来的哪个版本    # 回到之前版本发现未追踪文件,这是因为还没add 或commit就切换版本    # 确认这些文件没用的话就可以直接clean,一般情况最好保留一个版本    git clean -df  </code></pre><h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><pre><code>    git branch -D &lt;name&gt;   # 丢弃一个没有被合并过的分支- master分支是主分支，因此要时刻与远程同步；- dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</code></pre><h3 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h3><pre><code>- git log 提交历史,显示提交过版本信息,不包括删除的commit和reset操作- git reflog 命令历史,显示所有操作记录,包括提交,回退,合并等,一般用来回退合并commit针对git log        git log     #查看commit记录        git rebase -i commitid  # 这里的id是不需要合并的commit对应id        # 进入vim模式,根据提示进行pick(执行commit)或者squash(合并commit)</code></pre><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>详细规则参考<a href="https://git-scm.com/docs/gitignore" target="_blank" rel="noopener">官方英文文档</a></p><pre><code>- 忽略操作系统自动生成的文件，比如缩略图等；- 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；- 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。        /build/  # 匹配根目录下build文件夹下所有文件, 特别注意/的使用        build/  # 匹配目录下build文件夹下所有文件,包括/child/build/        !lib.a  # 除开lib.a, 即需要跟踪        *.pyc   # 所有以.pyc结尾的文件         *.ipynb_checkpoints # JupyterNotebook创建的自动保存的文件,可以通过 “File &gt; Revert to Checkpoint“恢复git只会跟踪文件,不会跟踪空文件夹        pyc文件是由py文件经过编译后，生成的二进制文件，是一种byte code，py文件变成pyc文件后，加载的速度有所提高，而且pyc是一种跨平台的字节码，是由Python的虚拟机来执行的python执行文件流程    - 完成模块的加载和链接；    - 将源代码翻译为PyCodeObject对象（字节码），并将其写入内存当中（方便CPU读取，起到加速程序运行的作用）；    - 从上述内存空间中读取指令并执行；    - 程序结束后，根据命令行调用情况（即运行程序的方式）决定是否将PyCodeObject写回硬盘当中（也就是直接复制到.pyc或.pyo文件中）；    - 之后若再次执行该脚本，则先检查本地是否有上述字节码文件。有则执行，否则重复上述步骤。    检查.gitignore哪条规则匹配了App.class可用如下命令(感觉不是很好用)    git check-ignore -v App.class</code></pre><p>.gitignore规则不生效,只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:</p><pre><code>git rm -r --cached .git add .git commit -m &#39;update .gitignore&#39;</code></pre><h3 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h3><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。更详细的使用请看官方文档<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git 工具 - 子模块</a><br>增加子模块之后会生辰.gitmodules文件,里面是相关的配置</p><pre><code>git submodule add https://github.com/chaconinc/DbConnector</code></pre><p>clone带有子模块的项目</p><pre><code>git clone --recurse-submodules https://github.com/chaconinc/MainProject</code></pre><h2 id="git-遇到的问题"><a href="#git-遇到的问题" class="headerlink" title="git 遇到的问题"></a>git 遇到的问题</h2><h3 id="git-add-file"><a href="#git-add-file" class="headerlink" title="git add file"></a>git add file</h3><p>提示modified content, untracked content是因为在add的时候这个目录下面本来就有一个.git文件，自然就会add失败，先删除这个.git文件再add</p><p>还有问题可先删除缓存再来</p><pre><code>git rm --cached filenamegit add filenamegit commit -m &quot;remark&quot;git push origin master</code></pre><p>修改或生成.gitignore在<code>git add .</code>之后会导致已经被跟踪的文件无法去除跟踪状态</p><pre><code>git rm -r --cached .git add .</code></pre><h3 id="将一个项目和多个远程仓库关联"><a href="#将一个项目和多个远程仓库关联" class="headerlink" title="将一个项目和多个远程仓库关联"></a>将一个项目和多个远程仓库关联</h3><p>增加<code>remote</code>(远程仓库),并在<code>push</code>的时候加上相应的参数,配置文件可查看<code>.git/config</code></p><pre><code>git remote add gitlab git@server-Power:common_driver/Universal_Robots_ROS_Driver.git# 指定远程仓库和`upstream`即上传的分支git push gitlab -u master</code></pre><p>这种方式在<code>push</code>需要指定仓库并且需要多次操作,可以使用<code>set-url</code>来一次完成<br>    git remote set-uri —add origin git@server-Power:common_driver/Universal_Robots_ROS_Driver.git<br>可以通过<code>git remote -v</code>查看当前的远程仓库    </p><p>如果想覆盖<code>remote</code>,需要<code>rename</code></p><pre><code>cd existing_repogit remote rename origin old-origingit remote add origin git@server-Power:benbo/test.gitgit push -u origin --allgit push -u origin --tags</code></pre><h3 id="不要使用Windows自带的记事本编辑任何文本文件"><a href="#不要使用Windows自带的记事本编辑任何文本文件" class="headerlink" title="不要使用Windows自带的记事本编辑任何文本文件"></a>不要使用Windows自带的记事本编辑任何文本文件</h3><p>Microsoft开发记事本的团队保存UTF-8编码的文件:在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可</p><h3 id="删除本地上已经不存在的远程分支"><a href="#删除本地上已经不存在的远程分支" class="headerlink" title="删除本地上已经不存在的远程分支"></a>删除本地上已经不存在的远程分支</h3><p>可使用如下指令<br><code>git remote prune origin</code></p><p>删除本地已存在的一个远程分支名为<code>branch_name</code><br><code>git branch -d -r origin/branch_name</code></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>廖雪峰 <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li><li><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">A collection of .gitignore templates</a></li><li><a href="https://blog.csdn.net/zong596568821xp/article/details/87341933" target="_blank" rel="noopener">Python之pyc文件作用及生成方法</a></li><li><a href="https://www.cnblogs.com/smile-fanyin/p/10827438.html" target="_blank" rel="noopener">git commit -m与-am的区别</a></li><li><a href="https://www.cnblogs.com/endless-code/p/11173886.html" target="_blank" rel="noopener">Git使用小技巧之多个远程仓库</a></li><li><a href="https://blog.csdn.net/tterminator/article/details/78108550" target="_blank" rel="noopener">git拉取远程分支并创建本地分支</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu系统配置</title>
      <link href="2019/07/14/ubuntu%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
      <url>2019/07/14/ubuntu%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>最近在自己的笔记本安装了ubuntu16，记录一下环境配置,持续更新</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ul><li>chorme</li><li>RedShift(如果不行的话考虑 护眼软件flux安装：先安装crossover，然后安装的windos下的flux)</li><li>terminator</li><li>ssr</li><li>输入法 sogo for Linux</li><li>wine</li><li>GoldenDict</li><li>shutter</li><li>smplayer</li><li>draw.io</li><li>kazam (录屏软件)</li></ul><h2 id="RedShift"><a href="#RedShift" class="headerlink" title="RedShift"></a>RedShift</h2><p>首选挺好用的护眼工具 如果无法使用就用flux</p><pre><code>sudo apt-get install redshift  gedit .config/redshift.conf     # 对应修改相应配置文件redshift -t 5700:3600       # 设置白天和黑夜对应温度   默认5000-4100tldr redshift               # 忘记命令可以使用tldr 或者cheat</code></pre><h2 id="terminator"><a href="#terminator" class="headerlink" title="terminator"></a>terminator</h2><p>终端分屏工具</p><ol><li><p>安装</p><pre><code> sudo apt-get install terminator</code></pre></li><li><p>配置（没找到文件夹就创建一个）</p><pre><code> cd ~/.config/terminator/ &amp;&amp; sudo gedit config</code></pre></li><li><p>修改配置文件</p><pre><code> [global_config]   focus = system   suppress_multiple_term_dialog = True   title_transmit_bg_color = &quot;#d30102&quot; [keybindings]   close_term = &lt;Primary&gt;&lt;Alt&gt;w [layouts]   [[default]]     [[[child1]]]       parent = window0       profile = default       type = Terminal     [[[window0]]]       parent = &quot;&quot;       type = Window [plugins] [profiles]   [[default]]     background_color = &quot;#2d2d2d&quot;     background_darkness = 0.85     background_image = None     copy_on_selection = True     cursor_color = &quot;#EEE9E9&quot;     font = Ubuntu Mono 13     foreground_color = &quot;#eee9e9&quot;     palette = &quot;#2d2d2d:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#d3d0c8:#747369:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#f2f0ec&quot;     show_titlebar = False     use_system_font = False</code></pre></li></ol><h2 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h2><ol><li>使用：双击<a href="https://github.com/qingshuisiyuan/electron-ssr-backup" target="_blank" rel="noopener">electron-ssr</a></li><li>账号:<ol><li>免费账号：<a href="https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7" target="_blank" rel="noopener">github</a></li><li>免费账号+服务器订阅：<a href="https://github.com/the0demiurge/ShadowSocksShare" target="_blank" rel="noopener">github</a></li></ol></li></ol><p>感谢他们的付出</p><h2 id="wine"><a href="#wine" class="headerlink" title="wine"></a>wine</h2><p>可以安装windows程序,这里我用于安装mathtype,写博客用公式就不同切换会windows了</p><pre><code>sudo apt-get install wine</code></pre><p>wine安装软件3中方式</p><pre><code>wine xxx.exe./xxx.exe直接双击(可能需要选择wine打开)winecfg （wine的设置~）wine  taskmgr （任务管理器）wine  uninstaller （卸载软件）wine  regedit （注册表）wine  notepad （记事本）wineboot （ 重启wine）</code></pre><h2 id="GoldenDict"><a href="#GoldenDict" class="headerlink" title="GoldenDict"></a>GoldenDict</h2><p>一款强大的翻译软件</p><ol><li><p>安装</p><pre><code> sudo apt install goldendict</code></pre></li><li><p>配置</p><ul><li><p>网络词典 Edit -&gt; Dictionaries -&gt; Sources -&gt; Websites -&gt; Add</p><p>常用的有:必应、有道、百度,选择一个就可以了，这里选择bing,(youdao的网页不能播放发音)</p><p>  必应：<a href="https://cn.bing.com/dict/search?q=%GDWORD%" target="_blank" rel="noopener">https://cn.bing.com/dict/search?q=%GDWORD%</a><br>  有道：<a href="https://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8" target="_blank" rel="noopener">https://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</a><br>  百度：<a href="https://fanyi.baidu.com/#en/zh/%25GDWORD%25" target="_blank" rel="noopener">https://fanyi.baidu.com/#en/zh/%25GDWORD%25</a>      </p></li><li><p>本地词典 Edit -&gt; Dictionaries -&gt; Sources -&gt; Files -&gt; Add</p><p>《牛津英汉双解美化版》 下载网址<a href="http://download.huzheng.org/zh_CN/" target="_blank" rel="noopener">http://download.huzheng.org/zh_CN/</a></p></li><li>屏幕取词 Edit -&gt; Preferences -&gt; Scan Popup</li><li><p>词形匹配(如果主要使用网络词典，可以不用配置此项) Edit-&gt;Dictionaries-&gt;Morphology  </p><p>  下载英文构词法规则库,<a href="https://sourceforge.net/projects/goldendict/files/better%20morphologies/1.0/" target="_blank" rel="noopener">地址</a></p></li></ul></li><li>使用　<br> 选中单词 Ctrl+C+C　(可以设置)        </li></ol><h2 id="shutter"><a href="#shutter" class="headerlink" title="shutter"></a>shutter</h2><p>截图软件</p><pre><code>    sudo apt install shutter  </code></pre><h2 id="smplayer"><a href="#smplayer" class="headerlink" title="smplayer"></a>smplayer</h2><p>视频播放软件 可倍速</p><pre><code>sudo apt-get install smplayer  #可选安装smplayer-skins smplayer-themes# [ ] 分别减速加速    </code></pre><h2 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h2><ul><li>支持谷歌浏览器app(推荐)</li><li>支持在线绘图,类似visio</li><li><a href="https://github.com/jgraph/drawio-desktop/releases" target="_blank" rel="noopener">桌面版本</a></li></ul><p>导出jpg可设置更改缩放为1000%就可以有较好清晰度</p><p><a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>        </p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ol><li><a href="https://pan.baidu.com/s/1B4lO9MiZVEqehld8ffoeFg" target="_blank" rel="noopener">软件资源</a>,提取码：87q8</li></ol><h1 id="开机启动软件设置"><a href="#开机启动软件设置" class="headerlink" title="开机启动软件设置"></a>开机启动软件设置</h1><ol><li>启动软件</li><li>ps auxww |grep qq    # 找到软件对应的命令</li><li>在startup里面添加对应命令</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li>terminator<a href="https://blog.csdn.net/ipatient/article/details/51547658" target="_blank" rel="noopener">配置</a></li><li><a href="https://blog.csdn.net/davidhzq/article/details/102725116" target="_blank" rel="noopener">Ubuntu桌面启动后自动执行指定的命令或程序的三种方法</a></li><li><a href="https://www.cnblogs.com/creasing/p/11333728.html" target="_blank" rel="noopener">Ubuntu 18.04 LTS版本 GoldenDict安装与配置</a></li><li><a href="https://blog.csdn.net/www_helloworld_com/article/details/85019862" target="_blank" rel="noopener">Ubuntu,Linux下goldendict词典安装及配置</a></li><li><a href="https://forum.ubuntu.org.cn/viewtopic.php?f=95&amp;t=265588" target="_blank" rel="noopener">强烈推荐：Goldendict 及其词典详述(5 月 26 日更新)</a></li><li><a href="http://einverne.github.io/post/2018/08/goldendict.html" target="_blank" rel="noopener">Linux 下非常好用的字典 GoldenDict</a></li><li><a href="https://blog.csdn.net/qq_34638161/article/details/81271977" target="_blank" rel="noopener">wine 安装（ubuntu中安装windows下软件）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="2019/07/14/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>2019/07/14/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#区块元素">区块元素</a><ul><li><a href="#标题">标题</a></li><li><a href="#区块引用">区块引用</a></li><li><a href="#列表">列表</a></li><li><a href="#代码区块">代码区块</a></li><li><a href="#分割线">分割线</a></li></ul></li><li><a href="#区段元素">区段元素</a><ul><li><a href="#链接">链接</a></li><li><a href="#强调">强调</a></li><li><a href="#代码">代码</a></li><li><a href="#图片">图片</a></li><li><a href="#数学公式">数学公式</a></li></ul></li><li><a href="#其它">其它</a><ul><li><a href="#自动链接">自动链接</a></li><li><a href="#反斜杠">反斜杠</a></li></ul></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown常用语法 =（最高级标题），-（第二阶标题）</p><pre><code>最高级标题=二级标题-</code></pre><p>也可以使用#来表示标题</p><pre><code># 最高标题## 子标题</code></pre><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>先断好行，&lt; 放在句首  一般标识符和后面内容之间需要<strong>空格</strong></p><pre><code>&gt; tab 缩进&gt; &gt; &gt;支持嵌套</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表使用 * + -，有序列表 数字 + .</p><pre><code>* 无序列表1. 有序列表</code></pre><p>行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。</p><pre><code>&lt;1986\. What a great season.</code></pre><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>缩进4个空格或者1个制表符，显示成原来的样子</p><pre><code>这是一个普通段落：    这是一个代码区块。</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>三个以上的* 、 - 、底线 建立分割线，行内没有其它东西，中间可以有空格</p><pre><code>- - -***——————</code></pre><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.This is [an example] [1] reference-style link.</code></pre><p>然后在文件任意处</p><pre><code>[1]:http://example.com/  &quot;Optional Title Here&quot;</code></pre><p>隐式链接</p><pre><code>[Google][][Google]: http://google.com/</code></pre><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>使用 <em> 和 _    包围，<em>*如果强调两边都有空格，就会被当成普通的符号</em></em></p><pre><code>**强调文字**_strong_</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>标记一小段，用  `</p><pre><code>Use the `printf()` function.</code></pre><p>代码中间有反引号，可用多个反引开启或者结束代码区域</p><pre><code>``There is a literal backtick ` here.``</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre><hr><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>基于Mathjax编写LaTex数学公式,MathJax是一个跨浏览器的JavaScript库，它使用MathML、LATEX和ASCIIMathML标记在Web浏览器中显示数学符号。</p><ol><li><p>标记公式<br> 公式使用美元符号$标记<br> 行内公式:公式紧接着文字</p><pre><code> $公式$</code></pre><p> 块级公式:公式单独成行</p><pre><code> $$公式$$</code></pre></li><li>上下标<br> <code>^</code>标示上标, <code>_</code>标示下标,上下标多余一个字符则用<code>{}</code>括起来作为整体.<strong>上下标可以嵌套</strong><br> 如果需要在左右两边都有上下标,用<code>\sideset</code>命令<br> 例如 $\sideset{^1_2}{^3_4}\bigotimes$</li><li><p>分数<br> 两种方式</p><pre><code> \frac{分子}{分母}     分子 \over 分母</code></pre><p> 第一种方式中如果分子分母都是单数,则<code>{}</code>可以忽略,例如<script type="math/tex">\frac12</script>表示$\frac12$</p></li><li>括号<br> <code>()</code> <code>[]</code> <code>|</code>可以直接表示自己,而<code>{}</code>可以用来分组<code>\{\}</code>表示自己,也可以使用<code>\lbrace</code> 和<code>\rbrace</code>来表示</li><li><p>根号<br> 根号<code>\sqrt</code>标记</p><pre><code> \sqrt[开方次数，默认为2]{开方因子}</code></pre><p> 非常复杂的表达式用    <script type="math/tex">\sqrt{...}^{1/n}</script>表示$\sqrt{…}^{1/n}$</p></li><li>省略号<br> <code>\ldots</code>表示与文本底线对齐的省略号，<code>\cdots</code>表示与文本中线对齐的省略号。</li><li><p>矢量<br> <code>\vec</code>表示矢量</p><pre><code> \vec{矢量值}    </code></pre></li><li>空格<br> 通常MathJax通过内部策略自己管理公式内部的空间,因此加入空格需要转义,如果需要更大空格,使用<code>\quad</code> 与 <code>\qquad</code><br> <script type="math/tex">a\ b</script> 表示$a\ b$</li><li><p>运算符<br> 关系运算</p><pre><code> ± ：\pm ×：\times ÷：\div ∣：\mid ∤：\nmid ⋅⋅：\cdot ∘：\circ ∗：\ast ⨀：\bigodot ⨂：\bigotimes ⨁：\bigoplus ≤：\leq ≥：\geq ≠：\neq ≈：\approx ≡：\equiv ∑：\sum ∏：\prod ∐：\coprod    </code></pre><p> 三角函数</p><pre><code> ⊥：\bot ∠：\angle 30∘：30^\circ sin：\sin cos：\cos tan：\tan cot：\cot sec：\sec csc：\csc</code></pre><p> 对数</p><pre><code> log：\log lg：\lg ln：\ln</code></pre></li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><pre><code>&lt;http://example.com/&gt;</code></pre><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>输出含有其他意义符号原本符号</p><pre><code>\*literal asterisks\*</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="http://wow.kuapp.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a>，以及<a href="https://github.com/riku/Markdown-Syntax-CN/" target="_blank" rel="noopener">github 地址</a></li><li><a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">Markdown中文文档</a></li><li><a href="https://blog.csdn.net/lanxuezaipiao/article/details/44341645" target="_blank" rel="noopener">CSDN-markdown语法之如何使用LaTeX语法编写数学公式</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> program </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
