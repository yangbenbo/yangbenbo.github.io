<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangbenbo&#39;s blog</title>
  
  <subtitle>人生在勤，不索何获</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangbenbo.github.io/"/>
  <updated>2023-10-13T12:42:56.018Z</updated>
  <id>http://yangbenbo.github.io/</id>
  
  <author>
    <name>杨本泊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>特殊矩阵</title>
    <link href="http://yangbenbo.github.io/2023/10/11/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5/"/>
    <id>http://yangbenbo.github.io/2023/10/11/特殊矩阵/</id>
    <published>2023-10-11T03:08:58.000Z</published>
    <updated>2023-10-13T12:42:56.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卡式分解"><a href="#卡式分解" class="headerlink" title="卡式分解"></a>卡式分解</h2><p>特殊矩阵可以分解成一般矩阵以便更好理解矩阵的含义, 卡氏分解 （Cartesian decomposition）可以把任何一个$n\times n$矩阵$A$分解成对称矩阵和反对称矩阵之和.<br>$A=B+C=\frac{1}{2}(A+A^T)+\frac{1}{2}(A-A^T)$<br>直接应用在与计算方阵的二次型, $x^TCx=x^TC^Tx=-x^TCx$, 即$x^TCx=0$, 所以二次型只针对卡式分解的对称部分计算即可$x^TAx=x^T\frac{A+A^T}{2}x$</p><p>正定矩阵</p><ul><li>$x^TAx&gt;0$对于任意非零向量$x$满足则是正定矩阵, $x^TAx\ge 0$则是半正定矩阵, 上面分析我们可以直接研究对称矩阵的正定性即可.实际含义就是$x$与经过线性变换后的$Ax$夹角小于等于90°</li><li>$x^TAx=1$,正定矩阵对应椭圆(高维椭球),等价于$y^Ty=(\Lambda ^{\frac{1}{2}}Q^Tx)^T(\Lambda ^{\frac{1}{2}}Q^Tx)=1$, 即$x=Q\Lambda ^{-\frac{1}{2}}y$,在另外一个空间正圆经过缩放和旋转得到椭圆, 比如原本正$x$方向点$(1, 0)$缩放后作为特征向量的系数,成为椭圆的长轴或者短轴,<br>或者$y=Q^Tx$, 得到$y^T\Lambda y=1$, 即$\lambda_1y_1^2+\lambda_2y_2^2=1$, 对应椭圆, 可以分析特征值为负数对应双曲线</li></ul><h3 id="实对称矩阵1"><a href="#实对称矩阵1" class="headerlink" title="实对称矩阵1"></a>实对称矩阵<sup><a href="#fn_1" id="reffn_1">1</a></sup></h3><ol><li>实对称矩阵的特征值皆是实数, 且对应特征向量是实向量<br>首先有$Ax=\lambda x,A\bar{x}=\bar{\lambda} \bar{x}$, 第二个方程左边转置并右乘特征向量$x$得到$\bar{x}^TA^Tx=\bar{x}^TAx=\lambda \bar{x}^Tx$, 等式右边$\bar{\lambda} \bar{x}^Tx$,<br>所以$(\lambda - \bar{\lambda}) \bar{x}^Tx=0$, 同时特征向量$x$非零, 所以特征值$\lambda$为实数, 特征向量为方程$(A-\lambda I)x=0$的解, 通过高斯消去法可以得到解, 同时系数矩阵为实数,所以解即特征向量也是实向量</li><li>实对称矩阵对应相异特征值的特征向量互为正交<br>设$\lambda_1\ne 0$, $\lambda_1x_1^Tx_2=(Ax_1)^Tx_2=x_1A^Tx_2=x_1Ax_2=\lambda_2x_1x_2$, 即$(\lambda_1-\lambda_2)x_1^Tx_2=0$, 由于$\lambda_1\ne \lambda_2$, 所以$x_1^Tx_2=0$,即相互垂直</li><li><p>任一$n\times n$阶实对称矩阵都有n个单范正交特征向量<br>预备知识</p><ul><li><p>对于$n \times n$矩阵$A$, 如果$\mathcal{X} \subseteq  \mathbb{C} ^n$是$A$的一个不变子空间且$\mathcal{X} \ne \{0\}$, 则存在非零特征向量$x \in \mathcal{X}$, 使得$Ax=\lambda x$</p><p>证明: 假定$dim\mathcal{X}=r, 0&lt;r&lt;n$, $x\in \mathcal{X}$非零, 向量集合$\begin{Bmatrix}x  &amp; Ax&amp;\cdots &amp;A^rx\end{Bmatrix}$线性相关, 即有$c_0x+c_1Ax+\cdots+c_rA^rx=0=c_s(A-u_1I)\cdots(A-u_sI)x$, 其中$c_s\ne 0, c_s&lt;r,$为最高次不为0的系数项, 所以必有$(A-u_jI)v=0$, 即对应特征值和特征向量</p></li><li><p>令$x$为实对称矩阵$A$特征向量, 如果$y\bot x$, 则$Ay \bot x$. $\mathcal{X}$为实对称矩阵$A$的不变子空间,则正交补于$\mathcal{X}^\bot$也是$A$的不变子空间</p><p>证明: $x\in \mathcal{X}$, 则$Ax\in \mathcal{X}$, 如果$y\in \mathcal{X}^\bot$, 则$Ax\bot y$.$(Ay)^Tx=0$, 即$y^TA^Tx=y^TAx=0$, 即$Ay\in \mathcal{X}^\bot$</p><p>最终证明: 反证法, 假设$A$有最多$k$个单范正交特征向量$q_1,\cdots,q_k$, 分别对应特征向量$\lambda_1, \cdots, \lambda_k$,令$\mathcal{X}=span\{q_1,\cdots,q_k\}$,则$\mathcal{X}, \mathcal{X}^\bot \ne \{0\}$为$A$的不变子空间, 则有$y\in \mathcal{X}^bot$使得$Ay=\lambda y$, 因此特征向量集还需要增加基,与前提矛盾,所以$\mathcal{X}^\bot=\{0\}$, 得证</p></li></ul></li></ol><h3 id="反对称矩阵2"><a href="#反对称矩阵2" class="headerlink" title="反对称矩阵2"></a>反对称矩阵<sup><a href="#fn_2" id="reffn_2">2</a></sup></h3><ul><li>特征值为0或者纯虚数<br>$Ax=\lambda x$, 则有$A\bar{x} =\bar{\lambda}  \bar{x} $, 两边转置并乘$x$得到$\bar{x}^TA^Tx=-\bar{x}^TAx=-\lambda\bar{x}^T x=\bar{\lambda}\bar{x}^Tx$, 所以$(\bar{\lambda}+\lambda)\bar{x}^Tx=0$, 所以特征值为纯虚数或者0(特征向量为0向量)</li><li>矩阵指数为旋转矩阵<br>旋量里面表示旋转矩阵可以用转轴求反对称矩阵后求指数得到旋转矩阵<br>可以证明$(e^{A})^{T}=e^{-A}$, $e^{A}e^{-A}=I$,后面式子可以通过展开之后推导, 所以最后得到$(e^{A})^{T}e^{A}=I$, 即反对称矩阵的矩阵指数是正交矩阵.</li></ul><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/2011/02/09/%e5%af%a6%e5%b0%8d%e7%a8%b1%e7%9f%a9%e9%99%a3%e5%8f%af%e6%ad%a3%e4%ba%a4%e5%b0%8d%e8%a7%92%e5%8c%96%e7%9a%84%e8%ad%89%e6%98%8e/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/02/09/%e5%af%a6%e5%b0%8d%e7%a8%b1%e7%9f%a9%e9%99%a3%e5%8f%af%e6%ad%a3%e4%ba%a4%e5%b0%8d%e8%a7%92%e5%8c%96%e7%9a%84%e8%ad%89%e6%98%8e/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://ccjou.wordpress.com/2010/08/27/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%99%A313%EF%BC%9A%E5%8F%8D%E5%B0%8D%E7%A8%B1%E7%9F%A9%E9%99%A3/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/08/27/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%99%A313%EF%BC%9A%E5%8F%8D%E5%B0%8D%E7%A8%B1%E7%9F%A9%E9%99%A3/</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;卡式分解&quot;&gt;&lt;a href=&quot;#卡式分解&quot; class=&quot;headerlink&quot; title=&quot;卡式分解&quot;&gt;&lt;/a&gt;卡式分解&lt;/h2&gt;&lt;p&gt;特殊矩阵可以分解成一般矩阵以便更好理解矩阵的含义, 卡氏分解 （Cartesian decomposition）可以把任何一
      
    
    </summary>
    
      <category term="线性代数" scheme="http://yangbenbo.github.io/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="线性代数" scheme="http://yangbenbo.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>矩阵微积分</title>
    <link href="http://yangbenbo.github.io/2023/10/08/%E7%9F%A9%E9%98%B5%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    <id>http://yangbenbo.github.io/2023/10/08/矩阵微积分/</id>
    <published>2023-10-08T12:33:58.000Z</published>
    <updated>2023-10-13T12:42:56.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵复特征值含义1"><a href="#矩阵复特征值含义1" class="headerlink" title="矩阵复特征值含义1"></a>矩阵复特征值含义<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><p>考虑微分方程$\frac{d\mathbf{u}}{dt}=A\mathbf{u}$, 如果2x2矩阵$A$的特征值为复数$\lambda$, 可推得特征向量$\mathbf{x}$也是复数(通过$Ax=\lambda x$),特解$\mathbf{u}=e^{\lambda t}\mathbf{x}$, 同理可以推导得到$\bar{\mathbf{u}}$也是特解,所以通解为</p><script type="math/tex; mode=display">y=c_1\mathbf{u}+c_2\bar{\mathbf{u}}</script><p>这里可以通过假设两个特解线性相关, 推导得到特征向量必须为实数,这与实际相悖,所系线性无关</p><p>由于实际解$y$为实数, 可以根据已经得到的解进行组合得到另外的形式, 比如取实部和虚部<br>$Re(\mathbf{u})=\frac{1}{2}(\mathbf{u}+\bar{\mathbf{u}})$<br>$Im(\mathbf{u})=\frac{1}{2i}(\mathbf{u}-\bar{\mathbf{u}})$<br>同理也可以证明线性无关, 所以最后通解$y=c_1Re(\mathbf{u})+c_2Im(\mathbf{u})$, 其中系数由初始条件决定</p><p>线性无关也可以通过可逆矩阵进行证明,即</p><script type="math/tex; mode=display">\begin{bmatrix}Re(\mathbf{u})  & Im(\mathbf{u})\end{bmatrix}=\begin{bmatrix}\mathbf{u}  & \bar{\mathbf{u}}\end{bmatrix}\begin{bmatrix}\frac{1}{2}  & \frac{1}{2i} \\ \frac{1}{2}  & -\frac{1}{2i}\end{bmatrix}</script><p>可以得到如下表示, 即两组基可以相互表示,充满解空间, 本生向量空间乘可逆矩阵不会改变空间维度,右乘可逆矩阵不改变向量的列空间$C(A)$, 左乘可逆矩阵不改变向量的行空间$C(A^T)$<br>$<br>\begin{bmatrix}<br>Re(\mathbf{u})  &amp; Im(\mathbf{u})<br>\end{bmatrix}=\begin{bmatrix}<br>\mathbf{u}  &amp; \bar{\mathbf{u}}<br>\end{bmatrix}B<br>$<br>$<br>\begin{bmatrix}<br>Re(\mathbf{u})  &amp; Im(\mathbf{u})<br>\end{bmatrix}B^{-1}=\begin{bmatrix}<br>\mathbf{u}  &amp; \bar{\mathbf{u}}<br>\end{bmatrix}<br>$</p><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/2010/06/07/%e8%a7%a3%e8%ae%80%e8%a4%87%e6%95%b8%e7%89%b9%e5%be%b5%e5%80%bc/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/06/07/%e8%a7%a3%e8%ae%80%e8%a4%87%e6%95%b8%e7%89%b9%e5%be%b5%e5%80%bc/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矩阵复特征值含义1&quot;&gt;&lt;a href=&quot;#矩阵复特征值含义1&quot; class=&quot;headerlink&quot; title=&quot;矩阵复特征值含义1&quot;&gt;&lt;/a&gt;矩阵复特征值含义&lt;sup&gt;&lt;a href=&quot;#fn_1&quot; id=&quot;reffn_1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="微积分" scheme="http://yangbenbo.github.io/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
      <category term="微积分" scheme="http://yangbenbo.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>基本矩阵</title>
    <link href="http://yangbenbo.github.io/2023/09/09/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5/"/>
    <id>http://yangbenbo.github.io/2023/09/09/基本矩阵/</id>
    <published>2023-09-09T01:13:58.000Z</published>
    <updated>2023-09-10T01:35:55.889Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#基本矩阵定义1">基本矩阵定义</a><ul><li><a href="#初等行变换对应基本矩阵">初等行变换对应基本矩阵</a></li></ul></li><li><a href="#基本矩阵的几何意义2">基本矩阵的几何意义</a><ul><li><a href="#基本矩阵的特征值">基本矩阵的特征值</a></li><li><a href="#几何意义">几何意义</a></li></ul></li><li><a href="#矩阵和的行列式3">矩阵和的行列式</a></li></ul><!-- /code_chunk_output --><h2 id="基本矩阵定义1"><a href="#基本矩阵定义1" class="headerlink" title="基本矩阵定义1"></a>基本矩阵定义<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><p>理解复杂系统关键是找到里面的基本元素, 对应一般矩阵则是找到基本矩阵,研究基本矩阵则可以知道一般矩阵的含义</p><p>令$u,v$为$n$维实(复)列向量,若$v^Tu \ne -1$, 则$I+uv^T$为基本矩阵, 其中$uv^T \in \mathbb{R}^{n\times n}$(外积), 如果$u,v$其中有1个为零向量,则基本矩阵退化为单位矩阵</p><p>基本矩阵转置也是基本矩阵$(I+uv^T)^T=I+vu^T$, 其中$v^Tu=u^Tv\ne 1$</p><p>猜测基本矩阵的逆也是基本矩阵$(I+uv^T)^{-1}=I+kuv^T$, 则有</p><script type="math/tex; mode=display">(I+uv^T)(I+kuv^T)=I+(1+k+kv^Tu)uv^T</script><p>上式子右边等于$I$, 得到$k=-\frac{1}{(1+v^Tu)}$, 这也是需要$v^Tu\ne -1$的原因</p><p>计算基本矩阵行列式$|I=uv^T|=|I|+v^T(adjI)u=1+v^Tu$, 其中$I=\frac{adjI}{|I|}=adjI$, 其中$adjI$表示$I$的伴随矩阵</p><h3 id="初等行变换对应基本矩阵"><a href="#初等行变换对应基本矩阵" class="headerlink" title="初等行变换对应基本矩阵"></a>初等行变换对应基本矩阵</h3><p>在高斯消去法中, 每个基本的行变换都对应1个基本矩阵,</p><ol><li>交换, 行$i$于行$j$互换位置</li><li>伸缩, 行$i$乘非零常数$c$</li><li>取代, 行$i$乘非零常数$c$的结果加进行$j$, $i\ne j$<br>对单位矩阵进行初等行变换即为基本矩阵</li></ol><p>例如3维基本矩阵可以归纳处基本矩阵的形态$I+uv^T$</p><script type="math/tex; mode=display">\begin{array}{l}E_{1}=\left[\begin{array}{lll}0 & 1 & 0 \\1 & 0 & 0 \\0 & 0 & 1\end{array}\right]=I+\left[\begin{array}{rrr}-1 & 1 & 0 \\1 & -1 & 0 \\0 & 0 & 0\end{array}\right]=I+\left[\begin{array}{r}1 \\-1 \\0\end{array}\right]\left[\begin{array}{lll}-1 & 1 & 0\end{array}\right]=I+\left(\mathbf{e}_{1}-\mathbf{e}_{2}\right)\left(\mathbf{e}_{2}-\mathbf{e}_{1}\right)^{T}, \\E_{2}=\left[\begin{array}{lll}1 & 0 & 0 \\0 & c & 0 \\0 & 0 & 1\end{array}\right]=I+\left[\begin{array}{ccc}0 & 0 & 0 \\0 & c-1 & 0 \\0 & 0 & 0\end{array}\right]=I+(c-1)\left[\begin{array}{l}0 \\1 \\0\end{array}\right]\left[\begin{array}{lll}0 & 1 & 0\end{array}\right]=I+(c-1) \mathbf{e}_{2} \mathbf{e}_{2}^{T}, \\E_{3}=\left[\begin{array}{lll}1 & 0 & 0 \\c & 1 & 0 \\0 & 0 & 1\end{array}\right]=I+\left[\begin{array}{lll}0 & 0 & 0 \\c & 0 & 0 \\0 & 0 & 0\end{array}\right]=I+c\left[\begin{array}{l}0 \\1 \\0\end{array}\right]\left[\begin{array}{lll}1 & 0 & 0\end{array}\right]=I+c \mathbf{e}_{2} \mathbf{e}_{1}^{T},\end{array}</script><p>其中, $e_i$是第$i$个标准单位向量(第$i$元=1,其余为0), 推广到$n$维矩阵如下, 并使用基本矩阵逆矩阵计算公式推导逆矩阵</p><ol><li>交换, 行$i$于行$j$互换位置: $E_1=I_n-(e_i-e_j)(e_j-e_i)^T$, 计算逆矩阵得$E_1^{-1}=E_1$, 连续两次交换就是单位矩阵并没有做什么</li><li>伸缩, 行$i$乘非零常数$c$: $E_2(c)=I_n+(c-1)e_ie_i^{T}$, $E_2(c)^{-1}=E_c(\frac{1}{c})$</li><li>取代, 行$i$乘非零常数$c$的结果加进行$j$, $i\ne j$: $E_3(c)=I_n+ce_ie_j^T$, $E_3(c)^{-1}=E_3(-c)$</li></ol><p><strong>定理: 方阵$A$非奇异的充要条件是$A$为基本矩阵乘积</strong></p><ul><li>如果$A$非奇异,使用高斯-约当法把矩阵化简直至单位矩阵, 则$E_k\cdots E_2E_1A=I$, 得到$A=E_1^{-1}E_2^{-1}\cdots E_k^{-1}$</li><li>如果$A=E_1E_2\cdots E_n$, 基本矩阵非奇异, 乘积也非奇异, 因为$|A|=|E_1E_2\cdots E_n|=|E_1||E_2|\cdots |E_n|=\ne 0$</li></ul><h2 id="基本矩阵的几何意义2"><a href="#基本矩阵的几何意义2" class="headerlink" title="基本矩阵的几何意义2"></a>基本矩阵的几何意义<sup><a href="#fn_2" id="reffn_2">2</a></sup></h2><h3 id="基本矩阵的特征值"><a href="#基本矩阵的特征值" class="headerlink" title="基本矩阵的特征值"></a>基本矩阵的特征值</h3><p>$(I+uv^T)u=(1 + v^Tu)u$, 所以$1+v^Tu$和$u$分别是特征值和特征向量.<br>另外考虑垂直于$v$的$n-1$子空间$\mathcal{V}$线性独立向量$x_1, x_2,\cdots, x_{n-1}$, 则有$(I+uv^T)x_i=x_i$, $1,x_i$分别为特征值和特征向量, 又有$u\notin \mathcal{V}$, 所以</p><script type="math/tex; mode=display">I+uv^T=S\begin{bmatrix}1+v^Tu  &  & &\\  &  1& &\\  &  & \ddots & \\  &  & &1\end{bmatrix}S^{-1}</script><p>其中$S=\begin{bmatrix}  u&amp;  x_1&amp;  \cdots &amp; x_{n-1}\end{bmatrix}$, 所以$|I+uv^T|=1+v^Tu$</p><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>$(I+uv^T)x=x+(v^Tx)u$, 所以基本矩阵就是对输入矢量$x$进行平移$(v^Tx)u$</p><ol><li>基本镜射矩阵, 令$||u||=1$, $v=-2u$, 对应$H=I-2uu^T$<br><img src="/2023/09/09/基本矩阵/镜射矩阵.jpg" alt="镜射矩阵"></li><li>基本投影矩阵, 令$||u||=1$, $v=-u$, 得到$P=I-uu^T$<br><img src="/2023/09/09/基本矩阵/投影矩阵.jpg" alt="投影矩阵"></li><li>基本列运算矩阵, 参考上面3个初等行变换矩阵</li></ol><ul><li>交换: $E_1=I_n-(e_i-e_j)(e_j-e_i)^T = E_1-2uu^T$, 其中$u=\frac{1}{\sqrt{2}}\frac{e_i-e_j}{||e_i-e_j||}$, 所以交换矩阵就是按照$e_i-e_j$为超镜射平面法向量的基本镜射矩阵</li><li>伸缩: $E_2x=x+(c-1)e_ie_i^{T}x$, 说明只是把$x_i$伸缩了$c$倍</li><li>取代, 行$E_3x=x+ce_ie_j^Tx$, 把向量$x$沿着$e_i$方向平移了$cx_j$单位</li></ul><h2 id="矩阵和的行列式3"><a href="#矩阵和的行列式3" class="headerlink" title="矩阵和的行列式3"></a>矩阵和的行列式<sup><a href="#fn_3" id="reffn_3">3</a></sup></h2><p>矩阵乘积行列式比较简单$|AB|=|A||B|$, 矩阵和的行列式相对比较麻烦</p><ol><li>首先证明$|A+UV^T|=|I_m+V^TA^{-1}U||A|$, 其中$A$为可逆矩阵, $B=UV^T$, 其中$U,V\in \mathcal{R}^{n\times n}$<br>设计分块矩阵<script type="math/tex; mode=display">\left[\begin{array}{cc}A^{-1} & 0 \\V^{T} A^{-1} & I_{m}\end{array}\right]\left[\begin{array}{cc}A & U \\-V^{T} & I_{m}\end{array}\right]=\left[\begin{array}{cc}I_{n} & A^{-1} U \\0 & I_{m}+V^{T} A^{-1} U\end{array}\right]</script>对应求行列式得到<script type="math/tex; mode=display">\begin{vmatrix}A & U \\-V^{T} & I_{m}\end{vmatrix}=\begin{vmatrix}I_{n} & A^{-1} U \\0 & I_{m}+V^{T} A^{-1} U\end{vmatrix}\begin{vmatrix}A^{-1} & 0 \\V^{T} A^{-1} & I_{m}\end{vmatrix}^{-1}=|I_{m}+V^{T} A^{-1} U||A|</script>同时设计分块矩阵<script type="math/tex; mode=display">\left[\begin{array}{cc}A & U \\-V^{T} & I_{m}\end{array}\right]\left[\begin{array}{cc}I_n & 0 \\V^T & I_{m}\end{array}\right]=\left[\begin{array}{cc}A+UV^T & A^{-1} U \\0 & I_{m}\end{array}\right]</script>求行列式证明原等式<script type="math/tex; mode=display">|A+UV^T|=\begin{vmatrix}A & U \\-V^{T} & I_{m}\end{vmatrix}=|I_{m}+V^{T} A^{-1} U||A|</script></li><li>对应特殊矩阵,当$m=1$时, $U=u, V=v$为$n$维列向量,则有<script type="math/tex; mode=display">|A+uv^T|=(1+v^TA^{-1}u)|A|=|A|+v^T(adjA)u</script>其中$adjA$为$A$的伴随矩阵</li></ol><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/2010/02/02/%e7%89%b9%e6%ae%8a%e7%9f%a9%e9%99%a3-%e5%8d%81%ef%bc%9a%e5%9f%ba%e6%9c%ac%e7%9f%a9%e9%99%a3/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/02/02/%e7%89%b9%e6%ae%8a%e7%9f%a9%e9%99%a3-%e5%8d%81%ef%bc%9a%e5%9f%ba%e6%9c%ac%e7%9f%a9%e9%99%a3/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><p><sup><a href="#fn_2" id="reffn_2">2</a></sup>:　<a href="https://ccjou.wordpress.com/2011/01/10/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%99%A3%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/01/10/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%99%A3%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/</a></p><blockquote id="fn_3"><sup>3</sup>. <a href="https://ccjou.wordpress.com/2009/12/04/%e7%9f%a9%e9%99%a3%e5%92%8c%e4%b9%8b%e8%a1%8c%e5%88%97%e5%bc%8f-%e4%b8%8a/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2009/12/04/%e7%9f%a9%e9%99%a3%e5%92%8c%e4%b9%8b%e8%a1%8c%e5%88%97%e5%bc%8f-%e4%b8%8a/</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;
&lt;!-- code_chunk_output --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本矩阵定义1&quot;&gt;基本矩阵定义&lt;/
      
    
    </summary>
    
      <category term="线性代数" scheme="http://yangbenbo.github.io/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="基本矩阵" scheme="http://yangbenbo.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>线性代数概览</title>
    <link href="http://yangbenbo.github.io/2023/07/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://yangbenbo.github.io/2023/07/30/线性代数/</id>
    <published>2023-07-30T08:35:08.000Z</published>
    <updated>2023-10-13T12:42:56.025Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#vector-spaces">Vector Spaces</a><ul><li><a href="#向量空间基本定义">向量空间基本定义</a></li><li><a href="#线性独立">线性独立</a></li><li><a href="#子空间并集与交集计算">子空间并集与交集计算</a></li><li><a href="#矩阵乘法">矩阵乘法</a></li></ul></li><li><a href="#4个基本子空间">4个基本子空间</a><ul><li><a href="#行阶梯形矩阵4个子空间">行阶梯形矩阵4个子空间</a></li><li><a href="#矩阵4个基本子空间">矩阵4个基本子空间</a></li><li><a href="#矩阵乘积子空间10">矩阵乘积子空间</a></li><li><a href="#列空间和零空间互换表达">列空间和零空间互换表达</a></li></ul></li><li><a href="#投影矩阵">投影矩阵</a></li><li><a href="#正交基和施密特正交化">正交基和施密特正交化</a><ul><li><a href="#正交基的优良特性">正交基的优良特性</a></li><li><a href="#施密特正交化">施密特正交化</a></li><li><a href="#qr分解">QR分解</a></li></ul></li><li><a href="#行列式">行列式</a><ul><li><a href="#cramers-rule">Cramer’s Rule</a></li><li><a href="#行列式常见含义">行列式常见含义</a></li></ul></li><li><a href="#特征值--特征向量">特征值 &amp; 特征向量</a></li><li><a href="#矩阵对角化">矩阵对角化</a><ul><li><a href="#矩阵幂计算">矩阵幂计算</a></li><li><a href="#相似矩阵">相似矩阵</a></li></ul></li><li><a href="#微分方程">微分方程</a><ul><li><a href="#对称矩阵">对称矩阵</a></li></ul></li><li><a href="#未同步补充项">未同步补充项</a><ul><li><a href="#小知识点">小知识点</a></li></ul></li></ul><!-- /code_chunk_output --><p>重点参考教程<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><h1 id="Vector-Spaces-and-Linear-Transformations"><a href="#Vector-Spaces-and-Linear-Transformations" class="headerlink" title="Vector Spaces and Linear Transformations"></a>Vector Spaces and Linear Transformations</h1><h2 id="Vector-Spaces"><a href="#Vector-Spaces" class="headerlink" title="Vector Spaces"></a>Vector Spaces</h2><h3 id="向量空间基本定义"><a href="#向量空间基本定义" class="headerlink" title="向量空间基本定义"></a>向量空间基本定义</h3><p>向量空间$\mathcal{V}$(矢量空间)中,向量的加法和乘法满足8个公理, 提供了支持演算需要的重组, 分解与化简得规则:</p><ol><li>加法交换律: $x+y=y+x$</li><li>加法结合率: $x+(y+z)=(x+y)+z$</li><li>矢量单位: 存在位移的$0\in \mathcal{V}$, 使得$x+0=x$</li><li>逆元: 存在唯一的$-x\in \mathcal{V}$, 使得$x+(-x)=0$</li><li>向量分配率: $(\alpha + \beta)x=\alpha x + \beta x$, $\alpha, \beta \in F$</li><li>纯量分配率: $\alpha (x + y)=\alpha x + \alpha y$</li><li>结合率:$\alpha(\beta x)=\alpha \beta x$</li><li>纯量单位元: 存在唯一$1\in F$使得$1x=x$</li></ol><p>其中, 纯量$\alpha, \beta \in F$属于1个体(field), 比如实数系或复数系$\mathbb{R}, \mathbb{C}$</p><p>向量空间=向量集合+向量加法与纯量乘法+8个公理, 对应子空间=子集合+向量加法与纯量乘法+8个公理<br>向量空间需要满足封闭性: ${\forall} x,y \in \mathcal{V}$, 则有$cx+dy \in \mathcal{V}$</p><p><strong>同构向量空间</strong>:实际使用中很多场景可以等效成向量空间, 比如多项式操作:加法和纯量乘法, 可以把多项式表示乘以对应变量的幂为基, 对应项为坐标, $f=a_0+a_1x+a_2x^2+\cdots a_nx^n$, 表示成$(a_0,a_1,\cdots,a_n)$<br>向量空间是线性代数处理的主要对象, 使向量空间有趣的就是线性变换:<br>$T(x+y)=T(x)+T(y)$, $T(cx)=cT(x)$<br>如果$S,T$为线性变换, 可以定义加法和纯量乘法$P=S+T,Q=cT$, 分别表示为$P(x)=S(x)+T(x), Q(x)=cT(x)$, 从这里看<strong>线性变换也是矢量空间</strong>, 微积分就满足线性变换</p><p><strong>同构</strong>: 如果$\mathcal{U}, \mathcal{V}$布于相同数系得矢量空间, 且$x\in \mathcal{U}, y\in \mathcal{V}$存在一一对应关系, 表示为线性变换$y=T(x)$, 则称$\mathcal{U}, \mathcal{V}$同构(isomorphic), $\mathcal{U} \cong  \mathcal{V}$, 即$T$是保留结构得同构映射, 只需要证明任意$n$维度矢量空间$\mathcal{V}$和某个特定$n$维向量空间同构,特定矢量空间选为即$\mathbb{R}^n, \mathbb{C}^n$, 那么任意$n$维矢量空间性质可由特定矢量空间性质得到</p><p>比如坐标变换, $\beta=\{x_1,\cdots,x_n\}$为向量空间$\mathcal{V}$一组基, 则对$x\in \mathcal{V}$, 有$x=c_1x_1+\cdots+c_nx_n$, 对应线性变换$L(x) \rightleftharpoons x_{\beta}=(c_1,\cdots,c_n)$, 和上面多项式同理也可得到$n$维坐标值, 所以两个空间从线性变换来看使同构</p><h4 id="线性变换用矩阵表示"><a href="#线性变换用矩阵表示" class="headerlink" title="线性变换用矩阵表示"></a>线性变换用矩阵表示</h4><p>向量空间中最重要的就是基底, 存在线性变换$T:\mathcal{V}\to \mathcal{W}$, 能够将线性变换用矩阵$A$表示<br>向量空间$\mathcal{W}$基底$\alpha=(w_1,w_2,\cdots,w_n)$, $\mathcal{V}$基底$\beta=(v_1,v_2,\cdots,v_n)$, 对于向量$x=\alpha a$, 其中$a=(a_1,a_2,\cdots,a_n)^T$, 向量$y=\beta b$, 其中$b=(b_1,b_2,\cdots,b_n)^T$<br>则有</p><script type="math/tex; mode=display">T\alpha=\beta \begin{bmatrix}c_{11}  & \cdots & c_{1n}\\\vdots  & \vdots & \vdots\\c_{n1}  & \cdots & c_{nn}\end{bmatrix}=\beta A</script><p>对应</p><script type="math/tex; mode=display">T(x)=T(\alpha a)=\begin{pmatrix}T(w_1)a_1  & \cdots &T(w_n)a_n\end{pmatrix}=\beta Aa</script><p>所以从坐标$a$,变换成坐标$Aa$, 本质上使用的是同构,复空间$\mathbb{C}^n$相同</p><h3 id="线性独立"><a href="#线性独立" class="headerlink" title="线性独立"></a>线性独立</h3><p>向量空间的任意向量可由一组最少向量的线性组合表示, 即基底, 即基底之间是不能相互表示,即线性无关, 对应$(v_1,v_2,\cdots,v_n)$线性独立, 等价于仅存在$c_1=c_2=\cdots =c_n=0$, 使得$c_1v_1+c_2v_2+\cdots+c_nv_n=0$</p><p>可证明向量空间中任意向量可由基底唯一表示,唯一性非常重要,　证明如下<br>$x=a_1v_1+a_2v_2+\cdots+a_nv_n$, 同时有$x=b_1v_1+b_2v_2+\cdots+b_nv_n$, 则$0=(a_1-b_1)v_1+(a_2-b_2)v_2+\cdots+(a_n-b_n)v_n$, 又由于线性无关, 所以$\mathbf{a} =\mathbf{b}$</p><p>已知矩阵$A$求解向量空间基, 可以化简为行阶最简梯形矩阵, 可以以此得到线性无关项, 以及对应列之间的线性关系. $PA=C$, 其中$P,C$分别为基本矩阵的乘积, 行阶最简梯形矩阵. $C$的线性关系可以表示为$Ck=0$, $k=(k_1,k_2,\cdots,k_n)^T$, 可以证明$Ak=P^{-1}Ck=0$, 说明$C,A$的列对应的线性关系相同, 所以$C$中线性无关的列就是$A$中线性无关的列,可以作为基底. 初等矩阵左乘矩阵$A$就是对行进行操作,不会改变行空间, 并保留列空间的线性关系. 同样的右乘就是对列进行操作, 不改变列空间, 并保留行空间线性关系</p><h4 id="矩阵左右乘含义"><a href="#矩阵左右乘含义" class="headerlink" title="矩阵左右乘含义"></a>矩阵左右乘含义</h4><ul><li>矩阵左乘保留列向量关系<br>$PA=B$, 其中$A=(a_1,a_2,\cdots,a_n), B=(b_1,b_2,\cdots,b_n)$, 对于任意向量$a_j=Ac\in \mathcal{A}$, 则对应变换后向量$b_j=Pa_j=PAc=Bc$, 即$\mathcal{A}$空间线性关系可推导$\mathcal{B}$线性关系.当$P$可逆则可以通过$\mathcal{B}$推导$\mathcal{A}$线性关系, 但是如果不可逆,那$\mathcal{B}$保留$\mathcal{A}$的线性关系,但是没办法通过$\mathcal{B}$推导$\mathcal{A}$线性关系;<br>可逆矩阵左乘不改变行空间: $\forall b \in C(B^T)$, 即$b=x^TB=x^TPA=y^TA$, 即$B \subset A$, 同理如果$P$可逆, 则可以证明$A \subset B$, 所以行空间不变$C(A^T)=C(B^T)$</li><li>矩阵右乘保留行向量关系<br>有$A^TP^T=B^T$, 上面分析已经得到左乘关系, 即$A^T, B^T$行向量保持关系,如果$P$可逆</li></ul><h3 id="子空间并集与交集计算"><a href="#子空间并集与交集计算" class="headerlink" title="子空间并集与交集计算"></a>子空间并集与交集计算</h3><ul><li>合集<br>针对列空间表达$\mathcal{X}=C(X),\mathcal{Y}=C(Y)$<script type="math/tex; mode=display">\mathcal{X} \bigcup \mathcal{Y}=C(\begin{bmatrix} X & Y \end{bmatrix})</script>针对零空间表达$\mathcal{X}=N(A),\mathcal{Y}=N(B)$, 可以先转化为列空间表达再用上面的结果</li><li>交集<br>零空间表达如下<script type="math/tex; mode=display">\mathcal{X} \bigcap \mathcal{Y}= N(\begin{bmatrix}A \\ B\end{bmatrix})</script>列空间可以先转化为行空间再计算, 也可以通过另外一种更简便的方式计算.<br>交集即意味着对应向量可以同时被两个空间表达,即$w=c_1x_1+\cdots c_px_p=d_1y_1+\cdots d_qy_q$化简得到<script type="math/tex; mode=display">\begin{bmatrix}X  & -Y\end{bmatrix}\begin{bmatrix}c \\ d\end{bmatrix}=0</script>对应结果为求零空间得到$c$, 可能有多列,意味着交集的维数, 最后交集为$C(Xc)$</li></ul><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>矩阵乘法最初就是简化复合线性变换表示得到的<sup><a href="#fn_7" id="reffn_7">7</a></sup>, 比如两个线性映射</p><script type="math/tex; mode=display">\begin{array}{l}f\left(\begin{array}{l}x \\y\end{array}\right)=\left(\begin{array}{l}a x+b y \\c x+d y\end{array}\right) \\g\left(\begin{array}{l}x \\y\end{array}\right)=\left(\begin{array}{l}p x+q y \\r x+s y\end{array}\right) .\end{array}</script><p>得到复合映射:</p><script type="math/tex; mode=display">\begin{aligned}h\left(\begin{array}{l}x \\y\end{array}\right) & =f\left(g\left(\begin{array}{l}x \\y\end{array}\right)\right)=f\left(\begin{array}{l}p x+q y \\r x+s y\end{array}\right) \\& =\left(\begin{array}{l}a(p x+q y)+b(r x+s y) \\c(p x+q y)+d(r x+s y)\end{array}\right) \\& =\left(\begin{array}{l}(a p+b r) x+(a q+b s) y \\(c p+d r) x+(c q+d s) y\end{array}\right) .\end{aligned}</script><p>如果用阵列表示线性映射系数, 得到最后的矩阵乘法表示</p><script type="math/tex; mode=display">\left[\begin{array}{ll}a & b \\c & d\end{array}\right]\left[\begin{array}{ll}p & q \\r & s\end{array}\right]=\left[\begin{array}{ll}a p+b r & a q+b s \\c p+d r & c q+d s\end{array}\right]</script><h4 id="矩阵乘法的现代定义"><a href="#矩阵乘法的现代定义" class="headerlink" title="矩阵乘法的现代定义"></a>矩阵乘法的现代定义</h4><p>最好的理解方式是通过线性组合的定义推导其它表示方式</p><ol><li>以列作为计算单元, 线性组合<script type="math/tex; mode=display">A \mathbf{x}=\left[\begin{array}{lll}\mathbf{a}_{1} & \cdots & \mathbf{a}_{n}\end{array}\right]\left[\begin{array}{c}x_{1} \\\vdots \\x_{n}\end{array}\right]=\mathbf{a}_{1} x_{1}+\cdots+\mathbf{a}_{n} x_{n}</script></li><li><p>以列作为单元定义$AB$<br>参考上面线性组合定义</p><script type="math/tex; mode=display">\begin{aligned}A(B \mathbf{x}) & =A\left(x_{1} \mathbf{b}_{1}+\cdots+x_{p} \mathbf{b}_{p}\right)=x_{1}\left(A \mathbf{b}_{1}\right)+\cdots+x_{p}\left(A \mathbf{b}_{p}\right) \\& =\left[\begin{array}{lll}A \mathbf{b}_{1} & \cdots & A \mathbf{b}_{p}\end{array}\right]\left[\begin{array}{c}x_{1} \\\vdots \\x_{p}\end{array}\right]=\left[\begin{array}{lll}A \mathbf{b}_{1} & \cdots & A \mathbf{b}_{p}\end{array}\right] \mathbf{x} .\end{aligned}</script><p>这种方式可用于证明分配律</p><script type="math/tex; mode=display">\begin{aligned}A(B+C) & =A\left[\begin{array}{lll}\mathbf{b}_{1}+\mathbf{c}_{1} & \cdots & \mathbf{b}_{p}+\mathbf{c}_{p}\end{array}\right] \\& =\left[\begin{array}{lll}A\left(\mathbf{b}_{1}+\mathbf{c}_{1}\right) & \cdots & A\left(\mathbf{b}_{p}+\mathbf{c}_{p}\right)\end{array}\right] \\& =\left[\begin{array}{llll}A \mathbf{b}_{1}+A \mathbf{c}_{1} & \cdots & A \mathbf{b}_{p}+A \mathbf{c}_{p}\end{array}\right] \\& =\left[\begin{array}{llll}A \mathbf{b}_{1} & \cdots & A \mathbf{b}_{p}\end{array}\right]+\left[\begin{array}{lll}A \mathbf{c}_{1} & \cdots & A \mathbf{c}_{p}\end{array}\right] \\& =A B+A C .\end{aligned}</script></li><li><p>以元作为计算单元<br>参考线性组合表示方式可以得到</p><script type="math/tex; mode=display">A \mathbf{x}=\left[\begin{array}{lll}\mathbf{a}_{1} & \cdots & \mathbf{a}_{n}\end{array}\right]\left[\begin{array}{c}x_{1} \\\vdots \\x_{n}\end{array}\right]=\begin{bmatrix}row_1(A)x \\\vdots \\row_1(A)x\end{bmatrix}</script><p>进一步推导可得</p><script type="math/tex; mode=display">(A B)_{i j}=\left[\begin{array}{lll}a_{i 1} & \cdots & a_{i n}\end{array}\right]\left[\begin{array}{c}b_{1 j} \\\vdots \\b_{n j}\end{array}\right]=a_{i 1} b_{1 j}+\cdots+a_{i n} b_{n j}</script></li><li><p>以行作为计算单元定义$AB$<br>类似上面, 只需要转置一下原本</p><script type="math/tex; mode=display">(AB)^T=B^TA^T=\begin{aligned}\left[\begin{array}{c}b_{1}^TA^T \\\vdots \\b_{p}^TA^T\end{array}\right]\end{aligned}</script></li><li>以行列展开计算$AB$<script type="math/tex; mode=display">AB=\begin{bmatrix}a_1  & \cdots  &a_n\end{bmatrix}\begin{bmatrix}row_1(B) \\\vdots \\row_n(B)\end{bmatrix}=a_1row_1(B)+\cdots+a_nrow_n(B)</script>证明方式: 参考$(AB)_{ij}$计算方式发现和第3个表示方式完全相同</li><li>以分块作为计算单元<br>首先分别推导小分块矩阵计算</li></ol><ul><li>行x列计算<script type="math/tex; mode=display">AB=A(B_1,B_2)=(AB_1,AB_2)=\begin{bmatrix}\begin{bmatrix}A_1 \\A_2\end{bmatrix}(B_1)  &\begin{bmatrix}A_1 \\A_2\end{bmatrix}(B_2)\end{bmatrix}=\begin{bmatrix}A_1B_1  & A_1B_2\\A_2B_1  &A_2B_2\end{bmatrix}=\begin{bmatrix}A_1\\A_2\end{bmatrix}\begin{bmatrix}B_1 & B_2\end{bmatrix}</script></li><li>列x行计算<script type="math/tex; mode=display">Ax=\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}x_1  \\x_2\end{bmatrix}=A_1x_1+A_2x_2</script><script type="math/tex; mode=display">AB= (Ab_1,Ab_2,\cdots,Ab_n) \\=\begin{bmatrix}\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}c_1  \\d_1\end{bmatrix} &\cdots &\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}c_n  \\d_n\end{bmatrix}\end{bmatrix}\\=\begin{bmatrix}A_1c_1+A_2d_1  & \cdots &A_1c_n+A_2d_n\end{bmatrix}\\=A_1\begin{bmatrix}c_1  & \cdots &c_n\end{bmatrix}+A_2\begin{bmatrix}d_1  & \cdots &d_n\end{bmatrix}\\=A_1B_1+A_2B_2=\begin{bmatrix}A_1  &A_2\end{bmatrix}\begin{bmatrix}B_1  \\B_2\end{bmatrix}</script>最后用$A_1=\begin{bmatrix}A_3  &amp;A_4\end{bmatrix}$, $A_2=\begin{bmatrix}A_5  &amp;A_6 \end{bmatrix}$, $B_1=\begin{bmatrix} B_3  &amp;B_4 \end{bmatrix}$,$B_2=\begin{bmatrix} B_4  &amp;B_6 \end{bmatrix}$, 代入行x列计算, 并结合列x行计算最后得到分块矩阵计算方式<script type="math/tex; mode=display">AB=\begin{bmatrix}A_3  & A_4\\A_5  &A_6\end{bmatrix}\begin{bmatrix}B_3  & B_4\\B_5  &B_6\end{bmatrix}=\begin{bmatrix}A_3B_3+A_4B_5  & A_3B_4+A_4B_6\\A_5B_3+A_6B_5  &A_5B_4+A_6B_6\end{bmatrix}</script></li></ul><p>反过头来所有上述表示最后都可以作为分块矩阵的特例</p><h2 id="4个基本子空间"><a href="#4个基本子空间" class="headerlink" title="4个基本子空间"></a>4个基本子空间</h2><p>对于矩阵$A$来说最终要的4个空间对应列空间$C(A)$, $C(A^T)$, 零空间$N(A)$, $N(A^T)$</p><p>一般矩阵可以经过初等行变换转换为行阶梯形矩阵$EA=R$, 首先对行阶梯形矩阵进行分析</p><h3 id="行阶梯形矩阵4个子空间"><a href="#行阶梯形矩阵4个子空间" class="headerlink" title="行阶梯形矩阵4个子空间"></a>行阶梯形矩阵4个子空间</h3><p>针对常见行阶矩阵$m=3,n=5$<br>$\boldsymbol{R}=\left[\begin{array}{lllll}<br>\mathbf{1} &amp; \mathbf{3} &amp; \mathbf{5} &amp; 0 &amp; \mathbf{7} \\<br>0 &amp; 0 &amp; 0 &amp; \mathbf{1} &amp; \mathbf{2} \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0<br>\end{array}\right]$<br>从行阶梯形矩阵可以得到</p><ol><li>$Dim(C(R^T))=Dim(C(R))=2$, 行空间和列空间的秩相等$r=2$, 矩阵的行秩=矩阵的列秩=矩阵pivots个数. 可以把矩阵化简成行阶最简梯形比较, 首先$E_1AE_2$交换矩阵的行和列确保能化简成$\begin{bmatrix}<br>I_r  &amp; F\\<br>0  &amp; 0<br>\end{bmatrix}$, 对应化简后矩阵秩为$r$</li><li>$Dim(N(R))=n-r$, pivots对应列为1,4,自由变量变量对应2,3,5,即对于$Rx=0$,分别单独设置自由变量为1得到最后的解,对应3维</li><li>$Dim(N(R^T))=m-r$, $R^Tx=0$,对应$x^TR=0$,从$R$中可以看到前2行有pivots,对应线性无关,所以要生成0,对应前两行的系数为0,而最后一行的系数任意,即解$(0, 0, y_3)$, 零空间对应0行的个数</li></ol><p>得到$R^n$中$N(R)$, $C(R^T)$, 以及$R^m$中$C(R)$, $N(R^T)$<br>对应子空间如下,这里暂且把$A$替换成$R$<br><img src="/2023/07/30/线性代数/子空间R.png" alt="子空间"></p><h3 id="矩阵4个基本子空间"><a href="#矩阵4个基本子空间" class="headerlink" title="矩阵4个基本子空间"></a>矩阵4个基本子空间</h3><p>行阶梯形矩阵通过$A$进行初等行变换得到,即$EA=R$, 基本行变换只是在对行空间向量进行重新线性组合,不会改变行空间,所以$C(A^T)=C(R^T)$, $N(A)=N(R)$;<br>基本行变换会影响列空间向量,但是$Ax=0$和$Rx=0$等价,因为$E$为可逆矩阵,即$N(A)=N(R)$,即原本$A$中线性相关项在$R$中也线性相关,所以可以通过$R$来找原本$A$中最小线性组合(<strong>这也是行阶最简梯形可以用于获取原矩阵线性无关项的原因</strong>), 即$Dim(N(A))=Dim(N(R)$, $Dim(C(A))=Dim(C(R)$, 虽然空间不一样($A$最后几行一般不是0,但是$R$的最后几行是0),但是维度相同,所以上面的图也适用于$A$</p><p>进一步看$R^n$中零空间$Ax=0$,对应空间中向量都与$A$行向量垂直,即$C(A^T)$中每个向量都与零空间垂直, 结合$Dim(C(A^T))+Dim(N(A))=n$,所以两个空间正交互补<br><img src="/2023/07/30/线性代数/正交互补.png" alt="子空间正交互补"></p><p>对于$Ax=b$图示如下<br><img src="/2023/07/30/线性代数/空间向量表示.png" alt="子空间正交互补"></p><p>4个空间基底基本算法<sup><a href="#fn_9" id="reffn_9">9</a></sup></p><h3 id="矩阵乘积子空间10"><a href="#矩阵乘积子空间10" class="headerlink" title="矩阵乘积子空间10"></a>矩阵乘积子空间<sup><a href="#fn_10" id="reffn_10">10</a></sup></h3><p>容易得到列空间和零空间基本关系 $C(AB)\subseteq C(A)$, $N(B)\subseteq N(AB)$<br>向量空间的子空间也是矢量空间,所以秩-零定理($dim(\mathbb{R} ^n)=dim(C(A))+dim(N(A))$)同样适用, 即$dim(C(B))=dim(C(AB))+dim(N(A)\bigcap C(B))$, 可以得到$rank(C(AB)) \le rank(C(B))$, 即左乘矩阵维度不会增加, 最多保持原有维度, 如果$A$可逆, 则不改变$B$行空间, 维度保持, 和上面矩阵左右乘含义一致. 也可以从上面等式中推导, $A$可逆意味着$dim(N(A))=0$, 即$dim$C(B)=dim(C(AB))$</p><p>得到$rank(AB)\le min\{rank(A),rank(B)\}$<br><img src="/2023/07/30/线性代数/矩阵乘积.jpg" alt="矩阵乘积子空间"></p><h3 id="列空间和零空间互换表达"><a href="#列空间和零空间互换表达" class="headerlink" title="列空间和零空间互换表达"></a>列空间和零空间互换表达</h3><ol><li><p>零空间用列空间表达<br>$A$列空间$C(A)$和零空间$N(A)$可以互换表达, 即隐式表达换成显式$N(A)=C(P)$, 显式表达换成隐式表达$C(A)=N(Q)$<br>如</p><script type="math/tex; mode=display">A=\begin{bmatrix}1  &4  &1  &0  &-2 \\-1 &-4  &0  &1  &5 \\2  &8  &2  &1  &-2 \\1  &4  &2  &2  &3\end{bmatrix}</script><p>化成行阶最简梯形为</p><script type="math/tex; mode=display">R=\begin{bmatrix}1  &4  &0  &0  &-3 \\0  &0  &1  &0  &1 \\0  &0  &0  &1  &2 \\0  &0  &0  &0  &0\end{bmatrix}</script><p>教科书一般是通过求解方程组的形式获取零空间解,即</p><script type="math/tex; mode=display">\begin{aligned}x_{1}+4 x_{2}-3 x_{5}=0 & \Rightarrow x_{1}=-4 x_{2}+3 x_{5} \\x_{3}+x_{5}=0 & \Rightarrow x_{3}=-x_{5} \\x_{4}+2 x_{5}=0 & \Rightarrow x_{4}=-2 x_{5}\end{aligned}</script><p>最后得到</p><script type="math/tex; mode=display">\left[\begin{array}{l}x_{1} \\x_{2} \\x_{3} \\x_{4} \\x_{5}\end{array}\right]=\alpha\left[\begin{array}{r}-4 \\1 \\0 \\0 \\0\end{array}\right]+\beta\left[\begin{array}{r}3 \\0 \\-1 \\-2 \\1\end{array}\right]=\alpha \mathbf{p}_{1}+\beta \mathbf{p}_{2}</script><p>即</p><script type="math/tex; mode=display">P=\left[\begin{array}{r}-4&3 \\1&0 \\0&-1 \\0&-2 \\0&1\end{array}\right]</script><p>这里可以使用分块矩阵进行计算, 把行阶最简梯形进行列交换得到$R=\left[\begin{array}{r}<br>I_r&amp;F \\<br>0&amp;0 \\<br>\end{array}\right],<br>P=\left[\begin{array}{r}<br>-F \\<br>I_{n-r} \\<br>\end{array}\right]$<br>对于交换了列只是交换了变量, 可以在得到$P$之后把对应列交换回去即可<sup><a href="#fn_8" id="reffn_8">8</a></sup>,可以记住交换后的序列, 最后求出$P$之后再换回去</p></li><li><p>列空间用零空间表达<br>$C(A)=N(Q)$, 求矩阵$Q$, 对应有方程$QA=0$, 即可满足$QAx=0$. 转置得到$A^TQ^T=0$, 所以只需要求得$A^T$的零空间并转置即可, 也可以借助矩阵的4个子空间进行理解.</p></li></ol><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>把空间中向量$b$投影到空间$C(A)$中, 即找到投影后向量和投影前向量最近的值, 对应投影后残余向量$b-Pb$垂直于空间$C(A)$, 根据垂直得到$A^T(b-Ax)=0$, 其中$x$为投影后在空间中的向量, $A^TAx=A^Tb$, 得到$x=(A^TA)^{-1}A^Tb$, 所以投影矩阵$P=(A^TA)^{-1}A^T$</p><p>$A^TA$只要$A$中列向量线性无关即可逆, 可以用SVD分解证明. <strong>对于$A$中存在线性相关项, 则$A^TA$不可逆, 可以使用伪逆,待补充</strong></p><p>误差$e=b-Ax$最小证明:</p><ul><li>几何法<br>如果$e$与$Ax$不垂直,其它任意向量可以组成三角形,都大于垂直向量</li><li>代数法<br>$Ax=b=p+e$, 其中$b\in R^m$, $p\in C(A) \bot e \in N(A^T)$, 只有$Ax=p$有解, $min||Ax-b||^2=min||Ax-p-e||^2=min(||Ax-p||^2+||e||^2)=||e||^2$</li><li>微积分<br>$min||Ax-b||^2$即取导数为0的点$f=(Ax-b)^T(Ax-b)=x^TA^TAx-2b^TAx+b^Tb$, 即$df=2(A^TAx-A^Tb)dx$, 所以$A^TAx=A^Tb$对应最小误差的地方<br>图形表示如下<br><img src="/2023/07/30/线性代数/最小误差解.png" alt="最小误差解"></li></ul><h2 id="正交基和施密特正交化"><a href="#正交基和施密特正交化" class="headerlink" title="正交基和施密特正交化"></a>正交基和施密特正交化</h2><h3 id="正交基的优良特性"><a href="#正交基的优良特性" class="headerlink" title="正交基的优良特性"></a>正交基的优良特性</h3><p>$Q$所有列单位正交, 对应$Q^TQ=I$</p><ul><li>$Q$不为方阵, 则$Q^T$是$Q$的左逆</li><li>$Q$为方阵, $Q^TQ=I$ -&gt; $Q^T=IQ^{-1}=Q^{-1}I$ -&gt; $QQ^T=I$, $Q^T$为双边逆, 转置即逆</li></ul><p>使用正交基投影, 即$Q$代$A$, 则有$Q^TQx=Q^Tb=x$, 投影矩阵为$QQ^T$, 这里没有$A^TA$带来的耦合(或者说协方差矩阵之类的), $x=Q^Tb$也就是$b$分别投影到每个正交基(点乘), 已经<strong>解耦成1维投影</strong></p><p>当$Q$是方阵时, 投影向量$p=QQ^Tb=b$, 即全空间投影还是本身. 这里的$QQ^T=I$非常重要, 很多变换(傅里叶变换)就是基于类似原理进行分解, 把向量或者和函数分解到垂直的空间. $p=q_1(q_1^Tb)+q_2(q_2^Tb)+ \cdots +q_n(q_n^Tb)$</p><h3 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h3><p>正交基可以解耦投影, 针对空间空任意基可以通过施密特正交化获得正交基. 核心是”Subtract from every new vector its projections in the directions already set”</p><p>比如给定一组独立向量$a,b,c$, 正交化得$A,B,C$,最后单位化即为单位正交基</p><ol><li>$A=a$, 初始向量不变</li><li>$B=b-A\frac{A^Tb}{A^TA}$, 即把$b$中正交投影到$a$的去除了,剩下的就是垂直于$a$, 可以通过$A^TB=A^Tb-A^Tb=0$证明</li><li>$C=c-A\frac{A^Tc}{A^TA}-B\frac{B^Tc}{B^TB}$, 分别把正交投影到其它向量的给剔除了</li></ol><p>改进的施密特正交化数值计算更加稳定, 相对于直接一次把投影到所有正交基分量减去, 可以逐个减</p><ol><li>$q_1=\frac{a} {||a||}$</li><li>$B=b-(q_1^Tb)q_1$, $q_2 = \frac{B} {||B||}$</li><li>$C^<em>=c-(q_1^Tc)q_1$, $C=C^</em>-(q_2^TC^*)q_2$, $q_3=\frac{C}{||C||}$</li></ol><h3 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h3><p>施密特正交化把空间中线性无关的基变换成单位正交基, 这两组基表示同一个空间, 之间的关系就是$A=QR$, $q_i$只与$a_1\cdots a_i$相关, 对应$R$为三角矩阵</p><script type="math/tex; mode=display">\left[\begin{array}{lll}\boldsymbol{a} & \boldsymbol{b} & \boldsymbol{c}\end{array}\right]=\left[\begin{array}{lll}\boldsymbol{q}_{1} & \boldsymbol{q}_{2} & \boldsymbol{q}_{3} \\& &\end{array}\right]\left[\begin{array}{lll}\boldsymbol{q}_{1}^{\mathrm{T}} \boldsymbol{a} & \boldsymbol{q}_{1}^{\mathrm{T}} \boldsymbol{b} & \boldsymbol{q}_{1}^{\mathrm{T}} \boldsymbol{c} \\& \boldsymbol{q}_{2}^{\mathrm{T}} \boldsymbol{b} & \boldsymbol{q}_{2}^{\mathrm{T}} \boldsymbol{c} \\& & \boldsymbol{q}_{3}^{\mathrm{T}} \boldsymbol{c}\end{array}\right]</script><p>很多分解都是为了方便解方程, 对于最小二乘法$A^TAx=A^Tb$, 使用QR分即可得$A^TAx=R^TRx=R^TQb$, 即$Rx=Q^Tb$(R满秩可逆), 由于$R$为上三角矩阵, 直接反过来代入即可求解</p><p>使用施密特正交化可以得到$Q$, 则$Q^TA=Q^TQR=R$可用于直接求解$R$<br>可以用于理解行列式意义<sup><a href="#fn_4" id="reffn_4">4</a></sup>, 可以用QR分解帮助理解$|A|=|QR|=|Q||R|$, 所以由$A$列向量组成的空间体积可以由以$Q$为基, $diag(R)$为长度组成的体积, 所以行列式的绝对值就是多面体的体积. 另外不依赖于$|AB|=|A||B|$也可以推导, 第$k$个向量在前$k-1$个向量组成的空间中给出垂直分量,即为$R$对角线上值$r_{kk}$, 所以体积在前面的集成上乘$r_{kk}$, 所以多面体体积$V= {\textstyle \prod_{i=1}^{n} r_{ii}} = |R|$</p><p>比如求n个列向量组成的多面体体积, 组成的矩阵$A\in R^{m\times n}$, $V=\sqrt{A^TA}$, $|A^TA|\geq 0$, 即$A^TA$为半正定矩阵. 可以补充$A$垂直子空间中$m-n$个单位正交向量得到$B$,则</p><script type="math/tex; mode=display">|B^TB|=\begin{vmatrix}A^TA  & 0\\0  & I_{m-n}\end{vmatrix} = |A^TA|=|B|^2</script><p>对应体积的平方, 所以多面体体积$V=\sqrt {B^TB}=\sqrt {A^TA}$, 这里主要针对$A$不是方阵, 如果是方阵, $|A^TA|=|R^TQ^TQR|=|R|^2=V^2$</p><h4 id="线性变换把面积伸缩了5"><a href="#线性变换把面积伸缩了5" class="headerlink" title="线性变换把面积伸缩了5"></a>线性变换把面积伸缩了<sup><a href="#fn_5" id="reffn_5">5</a></sup></h4><p>线性变换就是把1个空间变换成另外1个空间, 两个空间之间的面积/体积存在一定的关系, 针对线性变换$Ax$, 可以得到原来单位体积 $V=e_1e_2 \cdots e_n$, 其中空间基为$e_1. e_2,\cdots, e_n$, 则新的空间基为$Ae_1, Ae_2, \cdots, Ae_n$, 对应矩阵$\begin{bmatrix} Ae_1&amp;  Ae_2&amp; \cdots &amp; Ae_n \end{bmatrix}=AI=A$的体积, 即$V=|A|$, 即原本体积放大了$|A|$倍, 针对任意封闭多面体可以分成很多个小立方体近似, 平移不会改变多面体的体积, 所以任意多面体经过线性变换后体积缩放了$|A|$倍. 如果$A$不是方阵, 则放大倍数为$\sqrt{|A^TA|}$, 如果矩阵只有单个元素, 放大倍数就是本生, 属于矩阵的特例</p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>矩阵的行列式就是对应行组成的多面体的体积, 可以简单看成2x2/3x3矩阵推广到nxn, 原本可能就是想求面积或者体积之类的</p><p>3个最重要性质如下, 后面几个性质可以通过前3个进行推导<sup><a href="#fn_6" id="reffn_6">6</a></sup>, 使用面积(多面体体积更好理解) </p><ol><li>单位矩阵行列式=1, $|I|=1$, 简单理解就是单位立方体(包含多维)</li><li>两行交换, 行列式异号. 可以简单使用2x2矩阵进行验证.<br>求向量面积$A=\begin{bmatrix}<br>a  &amp; b\\<br>c  &amp; d<br>\end{bmatrix}$, 面积$S=ad-bs$, 结合性质3得到$|A|=$</li><li>行列式是任1行的线性函数(其他行不变)<script type="math/tex; mode=display">\begin{array}{l}\left|\begin{array}{cc}t a & t b \\c & d\end{array}\right|=t\left|\begin{array}{ll}a & b \\c & d\end{array}\right| \\\left|\begin{array}{cc}a+a^{\prime} & b+b^{\prime} \\c & d\end{array}\right|=\left|\begin{array}{ll}a & b \\c & d\end{array}\right|+\left|\begin{array}{cc}a^{\prime} & b^{\prime} \\c & d\end{array}\right| .\end{array}</script></li><li>矩阵两行相同, 则$|A|=0$, 可以通过第二条推导, 交换两行异号</li><li>某一行减去其它任一行的倍数,行列式不变. 初等行变换, 可以通过第3条线性进行推导</li><li>带有0行的矩阵行列式=0. 直接在原矩阵0行上加上其它任一行不改变行列式, 两行相同对应行列式相等</li><li>三角矩阵行列式=对角线pivots值相乘. 可以初等行变换化为对角矩阵, 行列式不变</li><li>$A$奇异对应$|A|=0$, 反之也成立</li><li>$|AB|=|A||B|$, 可以使用初等行变换把$A,B$化为对角矩阵得到行列式乘积, $|A|=|LPA|=|D|$, $P, L$, 分别是行交换和初等行变换. $|AB|=|LPAB|=|DB|=|A||B|$, 这里的$L$包括下三角和上三角矩阵, $D$为对角矩阵, 对B每行分别进行乘积, 可由性质3推导: 对角矩阵分解成只有1个元素保留,其它元素为1的矩阵乘积, 相当于每次单独对矩阵某行进行乘积. 或者也可以把矩阵直接化简为初等矩阵的乘积, 初等矩阵本生满足$|P_1P_2|=|P_1||P_2|$, 则$|AB|=|P_1P_2\cdots P_nQ_1Q_2\cdots Q_n|=|P_1P_2\cdots P_n||Q_1Q_2\cdots Q_n|=|A||B|$ </li><li>$|A^T|=|A|$, <strong>行列式对于行的性质同样适用于列</strong>. 可用$PA=LU$证明, $|A|=|P^{-1}LU|=|P^{-1}||L||U|$, $|A^{T}|=|U^T||L^T||P^{-T}|$, 可以发现各自相等, 其中$L, U$对三角矩阵, $P$为行交换矩阵, $P^{-1}=P=P^T$</li></ol><p>行列式求值<br>可以使用前三个基本规则确定, 求行列式$|A|$, 首先使用线性性质得到</p><script type="math/tex; mode=display">|A|=\begin{vmatrix}a_{11} &  a_{12} &  \cdots & a_{1n}\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} =\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} +\begin{vmatrix}0 &  a_{12} &  \cdots & 0\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} + \cdots +\begin{vmatrix}0 &  0 &  \cdots & a_{1n}\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix}</script><p>然后针对单个行列式依次进行再拆分, 第2个行列式为0, 同样的第一列所有除$a_{11}$的元素都可以消除为0, 最后化简成每一行/列只能选取1个元素. 对应总共由$n!$个行列式, 每个行列式可以化简成单位阵, 即行列式值$=||P||||A_i||$, 使用了基本性质1-3</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\a_{21} &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} =\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\0 &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} +\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\a_{21} &  0 &  \cdots & 0\\\vdots &  \vdots &  \vdots & \vdots\\a_{n1} &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} =\begin{vmatrix}a_{11} &  0 &  \cdots & 0\\0 &  a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots &  \vdots & \vdots\\0 &  a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} = -1^{1+1-2}a_{11}\begin{vmatrix}a_{22} &  \cdots & a_{2n}\\\vdots &  \vdots & \vdots\\a_{n2} &  \cdots & a_{nn}\\\end{vmatrix} = a_{11}C_{11}</script><p>其中符号取决为$(-1)^{j+i-2}=(-1)^{i+j}$, 对应$a_{ij}$, 其实就是利用行列式基本性质2以及行和列具有相同性质把$a_{ij}$交换到$a_{11}$, 对应$i+j-2$次交换<br>得到两种计算行列式算法<br>$|A|=\sum |P|a_{1i}a_{2j}\cdots a_{nk}$, 其中$i, j, k$为列的排列<br>$|A|=a_{i1}C_{i1} + a_{i2}C_{i2} + \cdots a_{in}C_{in}$, 其中$C_{in}$为代数余子式</p><h3 id="Cramer’s-Rule"><a href="#Cramer’s-Rule" class="headerlink" title="　Cramer’s Rule"></a>　Cramer’s Rule</h3><p>回到求解方程$Ax=b$, 之前是通过消去法得到的解,这次直接使用代数法<br>$Ax=b$, 可以扩充矩阵成为</p><script type="math/tex; mode=display">A\begin{bmatrix}x_1  & 0 & 0\\x_2  & 1 & 0\\x_3  & 0 & 1\end{bmatrix} = \begin{bmatrix}b & a_2 & a_3\end{bmatrix} = B_1</script><p>所以$|A|x_1=|B_1|$, 通过这种方式可以求得$x$, 针对$x_2$, 只需要把$x$放在矩阵第二列即可, 对应方程解$x_1=\frac{|B_1|}{|A|}, x_2=\frac{|B_2|}{|A|}, \cdots, x_n=\frac{|B_n|}{|A|}$, 这就是<strong>Cramer’s Rule</strong>, 这种方式计算效率比较低, 但是可以用于简单矩阵的符号推导. 求逆矩阵就是求了3次$Ax=b$方程, 对应求$AA^{-1}=I$, $b$分别为$I$矩阵种的列, 得到$A^{-1}_{ij} = \frac{C_{ji}}{|A|}$, 注意这里不是$C_{ij}$, 整合得到</p><script type="math/tex; mode=display">A^{-1}=\frac{C^T}{|A|}</script><p>直接证明$A^{-1}=\frac{C^T}{|A|}$, 等价于$AC^T=|A|I$</p><script type="math/tex; mode=display">\left[\begin{array}{lll}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{array}\right]\left[\begin{array}{lll}C_{11} & C_{21} & C_{31} \\C_{12} & C_{22} & C_{32} \\C_{13} & C_{23} & C_{33}\end{array}\right]=\left[\begin{array}{ccc}\operatorname{det} A & 0 & 0 \\0 & \operatorname{det} A & 0 \\0 & 0 & \operatorname{det} A\end{array}\right]</script><p>其中$a_{21}C_{11}+a_{22}C_{12}+a_{23}C_{13}=0$, 可以看成是把$A$的第二行拷贝到第1行得到$A^<em>$行列式$|A^</em>|=0$</p><p>这里可以推导得到2维矩阵逆方便使用, 对于非奇异矩阵,$A=\begin{bmatrix} a  &amp; b\\ c  &amp; d\end{bmatrix}$且 $|A|\ne 0$<br>则有</p><script type="math/tex; mode=display">A^{-1}=\frac{\begin{bmatrix}d  & -b\\-c  & a\end{bmatrix}}{|A|}</script><h3 id="行列式常见含义"><a href="#行列式常见含义" class="headerlink" title="行列式常见含义"></a>行列式常见含义</h3><ul><li><p>三角形面积<br>三角形顶点$(x_1, y_1), (x_2, y_2), (x_3, y_3)$, 面接为</p><script type="math/tex; mode=display">\frac{1}{2}\begin{vmatrix}x_1  & y_1 & 1\\x_2  & y_2 & 1\\x_3  & y_3 & 1\end{vmatrix}</script><p>从第三列展开对应就是3个三角形的面积和, 小三角形的1个顶点为原点</p></li><li><p>叉乘, 也可以用反堆成矩阵表示成矩阵和向量的乘积</p><script type="math/tex; mode=display">u \times v=\begin{vmatrix}i  & j & k\\u_1  & u_2 & u_3\\v_1  & v_2 & v_3\end{vmatrix}</script></li><li><p>体积, 可以借助叉乘理解, 叉乘就是向量构成的平行四边形面积, 最后增加1个点乘, 只需要把$i, j, k$替换成第3个向量即可</p><script type="math/tex; mode=display">(u\times v)w=\begin{vmatrix}w \\u \\v\end{vmatrix}</script></li></ul><h2 id="特征值-amp-特征向量"><a href="#特征值-amp-特征向量" class="headerlink" title="特征值 &amp; 特征向量"></a>特征值 &amp; 特征向量</h2><p>$Px=\lambda x$具有很有用的性质, $\lambda$为特征值, $x$为特征向量.</p><ul><li>投影矩阵, $Px=x, Py=0$, 把空间分成列空间和零空间, 对应特征值$\lambda=1$, $\lambda=0$, 列空间投影为本身, 零空间投影成0</li><li>反射矩阵, reflection matrix, $R=2P-I$, 对应$Rx=x, Ry=-y$, 对应特征值$\lambda=1$, $\lambda=-1$</li><li>旋转矩阵, 特征值是复数</li><li>反对称矩阵, 特征值为纯虚数, 待证明</li><li>对称矩阵, 特征值为实数. 任何矩阵都可以分解成对称矩阵和反对称矩阵和(卡式分解, Cartesian decomposition)$A=(\frac{A}{2} + \frac{A^T}{2}) + (\frac{A}{2} - \frac{A^T}{2})$</li></ul><p>$(A-\lambda I)x=0$, 对应$|A-\lambda x|=0$, 可求得特征值</p><p>特征值基本性质</p><ol><li>$\sum \lambda_i=trac(A)$<br>$|A-\lambda I|=|\lambda I - A|=0$, 对应$\lambda ^n - (a_{11}+a_{22}+\cdots + a_{nn})\lambda ^{n-1} + \cdots=0$, 同时有$(\lambda - \lambda_1)(\lambda - \lambda_2)\cdots(\lambda - \lambda_n)=0$ 对应有$\lambda ^n - (\lambda_1+\lambda_2+\cdots + \lambda_n)\lambda ^{n-1} + \cdots=0$, 对比$\lambda^{n-1}$系数即可得到证</li><li>$\prod \lambda_i=|A|$<br>所有特诊向量集合可得$A(x_1, x_2, \cdots, x_n)=(x_1, x_2, \cdots, x_n)\Lambda$, 即$|A||Q|=|Q||\Lambda|$, $|A|=||Lambda|$, 其中$\Lambda$为特诊值组成的对角矩阵</li><li>三角矩阵特征值就是对角线元素pivots, 直接用定义求即可证</li></ol><h2 id="矩阵对角化"><a href="#矩阵对角化" class="headerlink" title="矩阵对角化"></a>矩阵对角化</h2><p>所有矩阵特征值不相等,对应特征向量线性无关, 即$X$可逆, 矩阵可对角化, $AX=X\Lambda$, 对应$\Lambda = X^{-1}AX$, $Ax=X\Lambda X^{-1}x$, 物理意义就是$x$投影到特征向量上缩放后得到的向量, 相当于在特征向量的方向进行了处理<br>反证法, 假如线性相关, 则$c_1x_1+c_2x_2+\cdots+c_nx_n=0$, 其中系数不全为0(为方便推导可直接把0项去除), 左乘矩阵得到$c_1\lambda_1x_1+c_2\lambda_2x_2+\cdots+c_n\lambda_nx_n=0$, 两式结合消除$x_n$, 则说明前n-1项线性相关, 通过不断递推到$x_1$, 证明$c_1=0$, 也可证明$c_i=0$, 和原本假设相悖, 所以线性无关</p><p>矩阵可对角化和可逆没有必然联系</p><ul><li>矩阵不可逆, 对应特征值$\lambda_i=0$</li><li>矩阵可对角化, 特征向量是否足够作为空间一组基</li></ul><p>能否对角化判定依据: GM=AM</p><ul><li>Geometric Multiplicity: 几何重数, $\lambda_i$对应特征向量的个数, 也就是$A-\lambda I$的零空间维数</li><li>Algebraic Multiplicity: 代数重数, $\lambda_i$重根数, 即$|A-\lambda I|$根</li></ul><h3 id="矩阵幂计算"><a href="#矩阵幂计算" class="headerlink" title="矩阵幂计算"></a>矩阵幂计算</h3><p>$A^n=(X\Lambda X^{-1})^n=X\Lambda ^n X^{-1}$, 实际中非常有用, 比如求 Fibonacci number第100个, 0, 1, 1, 2, 3……, 后1个数是前来两个数之和, 可以用矩阵表示</p><script type="math/tex; mode=display">u_{k+1}=\begin{bmatrix}F_{k+2} \\F_{k+1}\end{bmatrix} = \begin{bmatrix}1  & 1\\1  & 0\end{bmatrix}\begin{bmatrix}F_{k+1} \\F_{k}\end{bmatrix}=Au_k</script><p>这里就可以用到矩阵幂, 实现快速求解$u_{100}=X\Lambda^{100}X^{-1}u_0$</p><p>计算$A^nu$</p><ul><li>$A$可对角化,即特征向量线性无关充满整个空间<br>$A^nu=X\Lambda^{n} X^{-1}u$, 令$X^{-1}u=c$,即$u=Xc$, 对应用特征向量表示$u$. $X\Lambda X^{-1}u$整个含义是把$u$投影到特征向量$X$上, 然后缩放特征值倍数, 最后在特征向量上表示(即向量空间沿着特征向量缩放特征值倍数)</li><li>$A$不能对角化, 即特征向量构成的空间小于矩阵的维度<br>只要$u$可有用仅有的特征向量表示也可以实现快速简单计算. <script type="math/tex; mode=display">A^nu=A^nXc=A^n\begin{bmatrix}x_1 & \cdots & x_n\end{bmatrix}\begin{bmatrix}c_1 \\\vdots \\c_n\end{bmatrix}=c_1\lambda_1^kx_1+\cdots+c_n\lambda_n^kx_n</script></li></ul><h3 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h3><p>相似矩阵的特征值相等, 可以从对角矩阵开始, $A=X\Lambda X^{-1}$, $X$为特征向量.任意选择一组基即可得到对应的$A$, 所以$A,\Lambda$相似. 拓展到任意矩阵$A=BCB^{-1}$, 只需要确保$B$可逆即可, 同时$A, C$矩阵不一定可以对角化.下面证明特征值相等<br>假如$Cx=\lambda x$, 则$A(Bx)=BCB^{-1}Bx=BCx=\lambda (Bx)$</p><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p>把一般微分方程推广到矩阵$\frac{du}{dt}=\lambda u$, 对应$u=e^{\lambda t}u_0$<br>$\frac{d\mathbf u}{dt}=A\mathbf u$, 假设$\mathbf u=e^{\lambda_it}{x_i}$, 其中$\lambda_i, x_i$分别为$A$的特征值和特征向量, 带回原式刚好满足, n个特征向量对应n个解, 所以解为, </p><script type="math/tex; mode=display">\mathbf u= c_1e^{\lambda_1t}x_1+c_2e^{\lambda_2t}x_2+\cdots+c_ne^{\lambda_nt}x_n=X\begin{pmatrix}e^{\lambda_1}  &  & \\  & \ddots & \\  &  & e^{\lambda_n }\end{pmatrix}c</script><p>满足$Xc=\mathbf u_0$, 如果$X$可逆, 对应$c=X^{-1}\mathbf u_0$, 类似单变量微分方程, 遇到两个$\lambda_i$相等且只有1个特征向量, 则需要增加解$te^{\lambda_it}$, 这里用二阶方程进行简要证明$\ddot x + p \dot x + qx=0$, 当两个根相等时即$\lambda=-\frac{p}{2}$, 对应一个解$x_1=e^{\lambda t}$, 需要找到另外一个线性无关解设为$x_2= u_xe^{\lambda t}$, 带入原方程得到$(\ddot u + (2\lambda+p)\dot u+(\lambda ^2 + p\lambda+1)u)e^{\lambda t}=0$, 其中$2\lambda+p=0, \lambda ^2 + p\lambda+1=0$, 所以$\ddot u=0$, 取$u=t$, 所以$x_2=te^{\lambda t}$</p><p>还有另一种处理方式, 针对可对角化矩阵$A=X\Lambda X^{-1}$可以进行变量解耦, 令$z=X^{-1}u$, 得到$\frac{dz}{dt}=\Lambda z$, 对应$z=\begin{bmatrix}<br>e^{\lambda_1t}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_nt}<br>\end{bmatrix}\begin{bmatrix}<br>c_1 \\<br>\cdots \\<br>c_n<br>\end{bmatrix}$, 最后得到<br>$<br>u=Xz=X\begin{bmatrix}<br>e^{\lambda_1t}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_nt}<br>\end{bmatrix}\begin{bmatrix}<br>c_1 \\<br>\vdots \\<br>c_n<br>\end{bmatrix}=X\begin{bmatrix}<br>e^{\lambda_1t}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_nt}<br>\end{bmatrix}c<br>$</p><p>矩阵形式的微分方程可以从多阶微分方程得到,比如$\ddot x + b\dot x + k x=0$, 常见的单位质量弹簧阻尼系统, 对应$\dot x = \dot x$, $\ddot x=-kx-b\dot x$, 对应矩阵$\frac{d\mathbf u}{dt}=A\mathbf u$, 使用矩阵得到的解和直接微分方程解相同, 只不过会附带$\dot x$状态. 其余高阶微分方程也可以通过这种方式进行求解</p><script type="math/tex; mode=display">\begin{bmatrix}\dot x \\\ddot x\end{bmatrix} = \begin{bmatrix}0  & 1\\-k & -b\end{bmatrix}\begin{bmatrix}x \\\dot x\end{bmatrix}</script><p>这里接触指数函数定义矩阵指数, 如果特征向量足够且线性无关,有<br>$e^{At}=I+At+\frac{At^2}{2}+\cdots=X\begin{pmatrix}<br>e^{\lambda_1}  &amp;  &amp; \\<br>  &amp; \ddots &amp; \\<br>  &amp;  &amp; e^{\lambda_n }<br>\end{pmatrix}X^{-1}$, 所以矩阵微分方程的解有可以写成$\mathbf u=e^{At}\mathbf u_0$, 这里只是针对齐次常微分方程的解,相当于零空间解,非齐次方程还需要得到特解+通解, 实际使用中通常使用数值法<strong>Runge-Kutta</strong>求常微分方程. 微分方程参考<a href="math.mit.edu/dela">Differential Equations and Linear Algebra</a><br>对应导数<br>$\frac{de^{At}}{dt}=Ae^{At}=e^{At}A$</p><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><ol><li>实对称矩阵特征向量是实数<br>证明: $Sx=\lambda x$, 则有$S\overline{x}=\overline{\lambda}\overline{x}$, 即$\overline{x}^TS=\overline{x}^T\overline{\lambda}$, 进一步得到$\overline{x}^TSx=\overline{x}^T\overline{\lambda}x$<br>另一方面,$\overline{x}^TSx=\overline{x}^T\lambda x$,<br>和上式比较得到$(\lambda-\overline{\lambda})\overline{x}^Tx=0$, 又由于$\overline{x}^T x\ne 0$, 所以$\overline{\lambda}=\lambda$, 即特征值为实数.<ul><li>实矩阵$Ax=\lambda x$, 对应有$A\overline{x}=\overline{\lambda}\overline{x}$, 所以实矩阵对应的特征值共轭,特征向量共轭</li></ul></li><li>实对称矩阵不同特征值对应的特征向量垂直<script type="math/tex; mode=display">\left(\lambda_{1} \boldsymbol{x}\right)^{\mathrm{T}} \boldsymbol{y}=(S \boldsymbol{x})^{\mathrm{T}} \boldsymbol{y}=\boldsymbol{x}^{\mathrm{T}} S^{\mathrm{T}} \boldsymbol{y}=\boldsymbol{x}^{\mathrm{T}} S \boldsymbol{y}=\boldsymbol{x}^{\mathrm{T}} \lambda_{2} \boldsymbol{y}</script>其中$\lambda_1\ne \lambda_2$, 所以$\mathbf x^T \mathbf y=0$,即垂直</li></ol><p>$S=Q\Lambda Q^T$ 待证明即使有相同特征值的对称矩阵也满足</p><h2 id="未同步补充项"><a href="#未同步补充项" class="headerlink" title="未同步补充项"></a>未同步补充项</h2><p>待证明:对称矩阵pivots符号=特征值的符号<br>正定矩阵: 所有特征值都是正数</p><h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><ol><li><p>矩阵左逆和右逆相等<sup><a href="#fn_2" id="reffn_2">2</a></sup>, 针对方阵<br>之前学习的时候更多的是直接定义$AA^{-1}=I$以及$A^{-1}A=I$, 可以通过结合律进行推导, 假设$BA=I$, $AC=I$, 则有 $(BA)C=B(AC)$, 即$C=B$<br>结合律证明$(AB)C=A(BC)$<br>等式左边: $(AB)C=AB(c_1,c_2,…,c_n)=(ABc_1,ABc_2,…,ABc_n)$<br>等式右边: $A(BC)=A(Bc_1,Bc_2,…,Bc_n)=(ABc_1,ABc_2,…,ABc_n)$</p></li><li><p>高斯消元法(Gauss-Jordan)<br>就是用多个初等矩阵<a href="**基本矩阵, 单位阵经过1次初等行/列变换得到: 两行(列">^3</a>互换、某行乘以非零常数、把第i行(列)加上第j行(列)的k倍<strong>) 左乘目标矩阵简化为行阶梯形矩阵, 一般用于方程求逆、矩阵的秩、线性方程组求解.<br>求$Ax=b$, 对增广矩阵进行高斯消元$(A,b)$, 得到$(U,c)$(</strong>A=LU分解<strong>, 可以进一步分解$U$为对角矩阵$A=LDU$), 再反向求解$x$,从$x_n$开始.<br>矩阵求逆类似$AA^{-1}=I$, 可以看成$n$个方程$Ax_i=e_i$, 最后得到逆矩阵, 这里可以不用反向求$x_i$, 可以直接再用初等矩阵把$A$变换为对角阵(元素积为$|A|$), 最后变为单位阵, 则右边的直接就是$A^{-1}$, 即$(A,I)$通过初等变换得到$(I,A^{-1})$. 矩阵求逆计算量较大, 所以matlab建议直接使用 <code>A\b</code>代替<code>inv(A)b</code><br>LU分解, 当$A^T=A$即</strong>对称矩阵**(最重要的矩阵), 分别分解$A^T=U^TDL^T、A=LDU$, 本生$A=A^T$, 所以分解出来的$L=U^T、L^T=U$, 即$A=LDL^T$<br>针对方程求解$Ax=b$解$x$=特解+零空间解, 首先使用高斯消元得到行阶梯形矩阵, 可以得到pivot(行阶梯形矩阵中每行第一个非零)和free variables(自由变量), 特解可以选取自由变量区零对应方程解, 零空间解则直接就是各个自由变量各自分别取1得到的解</p></li><li><p>对角线优势的矩阵可逆<br>对角线元素绝对值大于同行其他元素绝对值之和$|a_{ii}|&gt;\sum_{j \neq i}{a_{ij}}$. 矩阵不可逆=&gt;$Ax=0$存在非零解, 对于任意非0$x$, 假设$x_i$绝对值最大, 则$A_ix_i \neq 0$, 因为$a_{ii}x_i$比其余项之和还大, 所以解只有$x=0$, 对应$A$可逆</p></li><li><p>矩阵转置<br>$(Ax)^T=x^TA^T$ 证明$(Ax)^T=\begin{bmatrix}  a_1x\\  a_2x\\  …\\  a_nx \end{bmatrix}^T=[x^Ta_1^T,x^Ta_2^T,…,x^Ta_n^T]=x^TA^T$ 或者$Ax$是$A$的列向量线性组合, $x^TA^T$是$A^T$行向量线性组合, 相同向量的相同组合<br>$(AB)^T=B^TA^T$ 证明同理, 只需要将$B=(b_1,b_2,…,b_n)$类似证明<br>$(A^T)^{-1})=((A^{-1})^{T}$ 证明 $A^T((A^{-1})^T)=(A^{-1}A)^T=I$</p></li></ol><blockquote id="fn_1"><sup>1</sup>. <a href="https://ccjou.wordpress.com/%e9%96%b1%e8%ae%80%e5%b0%8e%e5%bc%95/%e7%9f%a9%e9%99%a3%e7%90%86%e8%ab%96%e5%ad%b8%e7%bf%92%e5%b0%8e%e5%bc%95/" target="_blank" rel="noopener">https://ccjou.wordpress.com/%e9%96%b1%e8%ae%80%e5%b0%8e%e5%bc%95/%e7%9f%a9%e9%99%a3%e7%90%86%e8%ab%96%e5%ad%b8%e7%bf%92%e5%b0%8e%e5%bc%95/</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. Gilbert Strang, Introduction to Linear Algebra, 3rd edition, Wellesley-Cambridge Press, 2003.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://en.wikipedia.org/wiki/Elementary_matrix" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Elementary_matrix</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://ccjou.wordpress.com/2010/04/29/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/04/29/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%B9%BE%E4%BD%95%E6%84%8F%E7%BE%A9/</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. <a href="https://ccjou.wordpress.com/2011/01/03/%e7%b7%9a%e6%80%a7%e8%ae%8a%e6%8f%9b%e6%8a%8a%e9%9d%a2%e7%a9%8d%e4%bc%b8%e7%b8%ae%e4%ba%86/#comment-7584" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/01/03/%e7%b7%9a%e6%80%a7%e8%ae%8a%e6%8f%9b%e6%8a%8a%e9%9d%a2%e7%a9%8d%e4%bc%b8%e7%b8%ae%e4%ba%86/#comment-7584</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. <a href="https://ccjou.wordpress.com/2010/12/01/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E9%81%8B%E7%AE%97%E5%85%AC%E5%BC%8F%E8%88%87%E6%80%A7%E8%B3%AA/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/12/01/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E9%81%8B%E7%AE%97%E5%85%AC%E5%BC%8F%E8%88%87%E6%80%A7%E8%B3%AA/</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. <a href="https://ccjou.wordpress.com/2010/06/18/%e7%b7%9a%e6%80%a7%e4%bb%a3%e6%95%b8%e7%9a%84%e7%ac%ac%e4%b8%80%e5%a0%82%e8%aa%b2-%e7%9f%a9%e9%99%a3%e4%b9%98%e6%b3%95%e7%9a%84%e5%ae%9a%e7%be%a9/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/06/18/%e7%b7%9a%e6%80%a7%e4%bb%a3%e6%95%b8%e7%9a%84%e7%ac%ac%e4%b8%80%e5%a0%82%e8%aa%b2-%e7%9f%a9%e9%99%a3%e4%b9%98%e6%b3%95%e7%9a%84%e5%ae%9a%e7%be%a9/</a><a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. <a href="https://ccjou.wordpress.com/2011/07/04/%E8%A1%8C%E7%A9%BA%E9%96%93%E8%88%87%E9%9B%B6%E7%A9%BA%E9%96%93%E7%9A%84%E4%BA%92%E6%8F%9B%E8%A1%A8%E9%81%94/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2011/07/04/%E8%A1%8C%E7%A9%BA%E9%96%93%E8%88%87%E9%9B%B6%E7%A9%BA%E9%96%93%E7%9A%84%E4%BA%92%E6%8F%9B%E8%A1%A8%E9%81%94/</a><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. <a href="https://ccjou.wordpress.com/2012/11/19/%E7%9F%A9%E9%99%A3%E7%9A%84%E5%9B%9B%E5%80%8B%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%96%93%E5%9F%BA%E5%BA%95%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2012/11/19/%E7%9F%A9%E9%99%A3%E7%9A%84%E5%9B%9B%E5%80%8B%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%96%93%E5%9F%BA%E5%BA%95%E7%AE%97%E6%B3%95/</a><a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. <a href="https://ccjou.wordpress.com/2010/07/27/%e7%9f%a9%e9%99%a3%e4%b9%98%e7%a9%8d%e7%9a%84%e5%ad%90%e7%a9%ba%e9%96%93%e5%88%86%e6%9e%90/" target="_blank" rel="noopener">https://ccjou.wordpress.com/2010/07/27/%e7%9f%a9%e9%99%a3%e4%b9%98%e7%a9%8d%e7%9a%84%e5%ad%90%e7%a9%ba%e9%96%93%e5%88%86%e6%9e%90/</a><a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;
&lt;!-- code_chunk_output --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vector-spaces&quot;&gt;Ve
      
    
    </summary>
    
      <category term="线性代数" scheme="http://yangbenbo.github.io/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="线性代数" scheme="http://yangbenbo.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LaTex公式编辑</title>
    <link href="http://yangbenbo.github.io/2023/07/11/LaTex%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/"/>
    <id>http://yangbenbo.github.io/2023/07/11/LaTex公式编辑/</id>
    <published>2023-07-10T22:37:51.000Z</published>
    <updated>2023-07-12T22:54:28.547Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#基本使用">基本使用</a><ul><li><a href="#公式编号">公式编号</a></li><li><a href="#注释">注释</a></li></ul></li><li><a href="#引用">引用</a></li><li><a href="#附录">附录</a></li></ul><!-- /code_chunk_output --><p>想要在文档中快速敲出好看的公式，<a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTex</a>必不可少。LaTeX系统是一种可以处理排版和渲染的标记语言，一种基于TEX的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，非常适用于生成高印刷质量的科技和数学、物理文档。</p><p>简单公式可以参考下面规则,对于复杂公式可以直接使用<a href="https://www.latexlive.com/" target="_blank" rel="noopener">在线latex</a>, 或者使用mathtype编辑后复制,对应公式识别可以使用<a href="https://mathpix.com/" target="_blank" rel="noopener">mathpix</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li><p>常用字符</p><pre><code>  `$`: 左对齐公式  $$$$: 居中对齐公式  `_`、`^`: 下标，上标  `\`: 转义字符  `\\`: 换行          $$          f(x)=2x+1 \\          =2+1 \\          =3          $$</code></pre></li><li><p>对齐<br>  <code>begin{aligned}</code>对齐，<code>&amp;</code>为对齐位置，一般在<code>=</code>前面</p><pre><code>  $$  \begin{aligned}  f(x)&amp;=2x+1 \\  &amp;=2+1 \\  &amp;=3  \end{aligned}  $$</code></pre><script type="math/tex; mode=display">  \begin{aligned}  f(x)&=2x+1 \\  &=2+1 \\  &=3  \end{aligned}</script></li><li><p>字体<br>  具体根据需要查询<a href="https://www.latexlive.com/help" target="_blank" rel="noopener">latex在线help</a></p><p>  比如拉式变换用到的花体$\mathcal{L}$</p></li><li><p>空格<br>  <code>quad</code>: 空1格<br>  <code>qquad</code>: 空2格</p></li><li><p>绝对值范数<br>  <code>||</code>, <code>||||</code>, 绝对值和范数</p></li><li><p>括号<br>  <code>(), [], |</code>为符号本身，大括号用<code>\{\}</code>，需要转义(上下标集合用了花括号)<br>  长括号<script type="math/tex">\left(表达式\right)</script></p></li><li><p>分式<br>  <code>\frac{分子}{分母}</code>, 简单可使用<code>\frac ab</code>, 对应$\frac ab$，复杂可以使用<code>分子 \over 分母</code>, $a \over b$</p></li><li><p>根<br>  \sqrt [根指数] {被开方数}<br>  缺省根指数时为2</p></li><li><p>对数<br>  \log_{对数底数}{表达式}</p><p>  表达式的大括号可省略</p></li><li><p>省略号<br>  数学公式中常见的省略号有两种，<code>\ldots</code> 表示与文本底线对齐的横向省略号$\ldots…$，<code>\cdots</code> 表示与文本中线对齐的横向省略号$\cdots⋯$</p></li><li><p>最值<br>  <code>\max_{下标表达式}{最值表达式}</code>表示最大值，<code>\min_{下标表达式}{最值表达式}</code>表达最小值</p></li><li><p>累加累乘<br>  使用 <code>\sum_{下标表达式}^{上标表达式}{累加表达式}</code>来输入一个累加。<br>  与之类似，使用 <code>\prod \bigcup \bigcap</code>来分别输入累乘、并集和交集。<br>  此类符号在行内显示时上下标表达式将会移至右上角和右下角。</p><pre><code>  $$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$</code></pre><p>  对应</p><script type="math/tex; mode=display">\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R</script></li><li><p>矢量<br>  使用 <code>\vec{矢量}</code>来自动产生一个矢量。<script type="math/tex">\vec{a}</script>对应$\vec{a}$</p></li><li><p>极限<br>  <code>\lim_{变量 \to 表达式} 表达式</code>, 比如<code>\lim_{n \to +\infty} \frac{1}{n(n+1)}</code><br>  对应</p><script type="math/tex; mode=display">\lim_{n \to +\infty} \frac{1}{n(n+1)}</script></li><li><p>导数<br>  ${\rm d}x$或${\text d}x$或$\text{d}x$</p></li><li><p>偏导<br>  <script type="math/tex">{\partial y} \over {\partial x}</script>对应${\partial y} \over {\partial x}$</p></li><li><p>梯度<br>  <script type="math/tex">\nabla f(x)</script>对应$\nabla f(x)$</p></li><li>积分<br>  \int_积分下限^积分上限 {被积表达式}, <code>\int_0^1 {x^2} \,{\rm d}x</code>对应<script type="math/tex; mode=display">\int_0^1 {x^2} \,{\rm d}x</script></li></ul><h3 id="公式编号"><a href="#公式编号" class="headerlink" title="公式编号"></a>公式编号</h3><ul><li><p>自动编号</p><pre><code>  $$  \begin{equation}  a^2+b^2=c^2  \end{equation}  $$</code></pre><p>  只需要在开始增加<code>\begin{equation}</code>，结束增加<code>\end{equation}</code></p><script type="math/tex; mode=display">  \begin{equation}  a^2+b^2=c^2  \end{equation}</script></li><li><p>手动编号</p><pre><code>  $$  x+y=z  \tag{3}  $$</code></pre><p>  对应只需要增加<code>\tag{编号}</code>，可以自定义修改公式编号，推荐自动编号</p><script type="math/tex; mode=display">  x+y=z  \tag{3}</script></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>%</code>单行注释, 主要方便自己对公式的维护和阅读</p><script type="math/tex; mode=display">% test commentx+y=z\tag{3}</script><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.latexlive.com/help" target="_blank" rel="noopener">在线文档</a></li><li><a href="https://www.latexlive.com/" target="_blank" rel="noopener">LaTex在线编辑器</a></li><li><a href="https://blog.csdn.net/NSJim/article/details/109066847" target="_blank" rel="noopener">LaTeX详细教程+技巧总结</a></li><li><a href="https://blog.csdn.net/NSJim/article/details/109045914" target="_blank" rel="noopener">LaTeX数学公式-详细教程</a></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>常用希腊字母对照</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">小写</th><th style="text-align:center">LaTeX</th><th style="text-align:center">读音</th><th style="text-align:center">序号</th><th style="text-align:center">大写</th><th style="text-align:center">LaTeX</th><th style="text-align:center">读音</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$\alpha$</td><td style="text-align:center">\alpha</td><td style="text-align:center">/ˈælfə/</td><td style="text-align:center">22</td><td style="text-align:center">$\sigma$</td><td style="text-align:center">\sigma</td><td style="text-align:center">/ˈsɪɡmə/</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$\beta$</td><td style="text-align:center">\beta</td><td style="text-align:center">/ˈbiːtə/, US: /ˈbeɪtə/</td><td style="text-align:center">23</td><td style="text-align:center">$\varsigma$</td><td style="text-align:center">\varsigma</td><td style="text-align:center">/ˈsɪɡmə/</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$\gamma$</td><td style="text-align:center">\gamma</td><td style="text-align:center">/ˈɡæmə/</td><td style="text-align:center">24</td><td style="text-align:center">$\tau$</td><td style="text-align:center">\tau</td><td style="text-align:center">/taʊ, tɔː/</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$\delta$</td><td style="text-align:center">\delta</td><td style="text-align:center">/ˈdɛltə/</td><td style="text-align:center">25</td><td style="text-align:center">$\upsilon$</td><td style="text-align:center">\upsilon</td><td style="text-align:center">/ˈʌpsɪlɒn/</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$\epsilon$</td><td style="text-align:center">\epsilon</td><td style="text-align:center">/ˈɛpsɪlɒn/</td><td style="text-align:center">26</td><td style="text-align:center">$\phi$</td><td style="text-align:center">\phi</td><td style="text-align:center">/faɪ/</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$\varepsilon$</td><td style="text-align:center">\varepsilon</td><td style="text-align:center">/ˈɛpsɪlɒn/</td><td style="text-align:center">27</td><td style="text-align:center">$\varphi$</td><td style="text-align:center">\varphi</td><td style="text-align:center">/faɪ/</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$\zeta$</td><td style="text-align:center">\zeta</td><td style="text-align:center">/ˈzeɪtə/</td><td style="text-align:center">28</td><td style="text-align:center">$\chi$</td><td style="text-align:center">\chi</td><td style="text-align:center">/kaɪ/</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">$\eta$</td><td style="text-align:center">\eta</td><td style="text-align:center">/ˈeɪtə/</td><td style="text-align:center">29</td><td style="text-align:center">$\psi$</td><td style="text-align:center">\psi</td><td style="text-align:center">/psaɪ/</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">$\theta$</td><td style="text-align:center">\theta</td><td style="text-align:center">/ˈθiːtə/</td><td style="text-align:center">30</td><td style="text-align:center">$\omega$</td><td style="text-align:center">\omega</td><td style="text-align:center">/oʊˈmeɪɡə/</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">$\vartheta$</td><td style="text-align:center">\vartheta</td><td style="text-align:center">/ˈθiːtə/</td><td style="text-align:center">31</td><td style="text-align:center">$\Gamma$</td><td style="text-align:center">\Gamma</td><td style="text-align:center">/ˈɡæmə/</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">$\iota$</td><td style="text-align:center">\iota</td><td style="text-align:center">/aɪˈoʊtə/</td><td style="text-align:center">32</td><td style="text-align:center">$\Delta$</td><td style="text-align:center">\Delta</td><td style="text-align:center">/ˈdɛltə/</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">$\kappa$</td><td style="text-align:center">\kappa</td><td style="text-align:center">/ˈkæpə/</td><td style="text-align:center">33</td><td style="text-align:center">$\Theta$</td><td style="text-align:center">\Theta</td><td style="text-align:center">/ˈθiːtə/</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">$\lambda$</td><td style="text-align:center">\lambda</td><td style="text-align:center">/ˈlæmdə/</td><td style="text-align:center">34</td><td style="text-align:center">$\Lambda$</td><td style="text-align:center">\Lambda</td><td style="text-align:center">/ˈlæmdə/</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">$\mu$</td><td style="text-align:center">\mu</td><td style="text-align:center">/mjuː/</td><td style="text-align:center">35</td><td style="text-align:center">$\Xi$</td><td style="text-align:center">\Xi</td><td style="text-align:center">/zaɪ, ksaɪ/</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">$\nu$</td><td style="text-align:center">\nu</td><td style="text-align:center">/njuː/</td><td style="text-align:center">36</td><td style="text-align:center">$\Pi$</td><td style="text-align:center">\Pi</td><td style="text-align:center">/paɪ/</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">$\xi$</td><td style="text-align:center">\xi</td><td style="text-align:center">/zaɪ, ksaɪ/</td><td style="text-align:center">37</td><td style="text-align:center">$\Sigma$</td><td style="text-align:center">\Sigma</td><td style="text-align:center">/ˈsɪɡmə/</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">$o$</td><td style="text-align:center">o</td><td style="text-align:center">/ˈɒmɪkrɒn/</td><td style="text-align:center">38</td><td style="text-align:center">$\Upsilon$</td><td style="text-align:center">\Upsilon</td><td style="text-align:center">/ˈʌpsɪlɒn/</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">$\pi$</td><td style="text-align:center">\pi</td><td style="text-align:center">/paɪ/</td><td style="text-align:center">39</td><td style="text-align:center">$\Phi$</td><td style="text-align:center">\Phi</td><td style="text-align:center">/faɪ/</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">$\varpi$</td><td style="text-align:center">\varpi</td><td style="text-align:center">/paɪ/</td><td style="text-align:center">40</td><td style="text-align:center">$\Psi$</td><td style="text-align:center">\Psi</td><td style="text-align:center">/psaɪ/</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">$\rho$</td><td style="text-align:center">\rho</td><td style="text-align:center">/roʊ/</td><td style="text-align:center">41</td><td style="text-align:center">$\Omega$</td><td style="text-align:center">\Omega</td><td style="text-align:center">/oʊˈmeɪɡə/</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">$\varrho$</td><td style="text-align:center">\varrho</td><td style="text-align:center">/roʊ/</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;
&lt;!-- code_chunk_output --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本使用&quot;&gt;基本使用&lt;/a&gt;&lt;ul
      
    
    </summary>
    
      <category term="Blog" scheme="http://yangbenbo.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>书单</title>
    <link href="http://yangbenbo.github.io/2023/07/09/%E4%B9%A6%E5%8D%95/"/>
    <id>http://yangbenbo.github.io/2023/07/09/书单/</id>
    <published>2023-07-09T09:29:07.000Z</published>
    <updated>2023-07-09T13:41:46.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ol><li>《MEASUREMENT》PAUL LOCKHART, 中文版《度量》</li></ol><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><ol><li><a href="https://www.feynmanlectures.caltech.edu/" target="_blank" rel="noopener">《费曼物理学讲义》</a></li></ol><h2 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h2><ol><li><a href="http://hades.mech.northwestern.edu/index.php/Modern_Robotics" target="_blank" rel="noopener">《Modern Robotics: Mechanics, Planning, and Control》</a>Kevin M. Lynch and Frank C. Park 《现代机器人学：机构、规划与控制》</li><li>《Introduction to Robotics:Mechanics and Control》John J. Craig 《机器人学导论》</li></ol><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><ul><li><p>Linux</p><ol><li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a></li></ol></li><li><p>Ros</p><ol><li>《ROS机器人编程》更多资源参考<a href="http://wiki.ros.org/cn" target="_blank" rel="noopener">Ros官网</a></li></ol></li><li><p>C++</p><ol><li>《数据结构与算法》邓俊辉</li><li><a href="https://gearyyoung.gitbooks.io/cmake-api/content/" target="_blank" rel="noopener">《cmake-api》</a></li><li>《[设计模式：可复用面向对象软件的基础]》李英军等译，视频学习参考<a href="https://www.bilibili.com/video/BV1Yr4y157Ci/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8b3168fa50de13b934ede65b59261239" target="_blank" rel="noopener">C++设计模式入门</a></li></ol></li></ul><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><ol><li>《Feedback Control of Dynamic Systems》Gene F. Franklin_ J. Da Powell_ Abbas Emami-Naeini</li><li>《信号与系统》奥本海默</li></ol><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><ol><li>《金字塔原理》</li></ol><h2 id="在读"><a href="#在读" class="headerlink" title="在读"></a>在读</h2><ol><li>《毛泽东选集》毛泽东</li><li>《野草》鲁迅</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.cnblogs.com/yaoz/p/7392564.html" target="_blank" rel="noopener">国外优秀数学教材选评</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数学&quot;&gt;&lt;a href=&quot;#数学&quot; class=&quot;headerlink&quot; title=&quot;数学&quot;&gt;&lt;/a&gt;数学&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;《MEASUREMENT》PAUL LOCKHART, 中文版《度量》&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;物理&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="读书" scheme="http://yangbenbo.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波</title>
    <link href="http://yangbenbo.github.io/2021/07/04/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    <id>http://yangbenbo.github.io/2021/07/04/卡尔曼滤波/</id>
    <published>2021-07-04T02:21:23.000Z</published>
    <updated>2023-07-08T23:10:12.034Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#卡尔曼滤波基本原理">卡尔曼滤波基本原理</a></li><li><a href="#理论推导">理论推导</a><ul><li><a href="#高斯分布融合">高斯分布融合</a></li><li><a href="#计算值和测量值融合">计算值和测量值融合</a></li></ul></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="卡尔曼滤波基本原理"><a href="#卡尔曼滤波基本原理" class="headerlink" title="卡尔曼滤波基本原理"></a>卡尔曼滤波基本原理</h2><p>现实中存在很多不确定性：</p><ul><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量的传感器存在误差</li></ul><p>卡尔曼滤波就是融合同一值的多个不确定性得到更准确的值，这里可以是模型计算值和测量值融合。参考知乎解释<a href="https://www.zhihu.com/question/23971601/answer/26254459" target="_blank" rel="noopener">如何通俗并尽可能详细地解释卡尔曼滤波？ - Kent Zeng的回答</a></p><p>用两个传感器同时测一个数值，最终结果可以取平均值，如果其中一个传感器更准确，取加权平均，加权的系数根据两个传感器的噪声分布（高斯分布）确定。实际中是数学模型计算出一个值，传感器测量出一个值，把这个两个值进行高斯分布的融合，得到的值的概率分布的方差更小（数据更准确）</p><h2 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h2><h3 id="高斯分布融合"><a href="#高斯分布融合" class="headerlink" title="高斯分布融合"></a>高斯分布融合</h3><p>两个一维高斯分布的融合就是概率的乘积然后归一化。一维高斯分布方程为$\mathcal{N}(x, \mu, \sigma)=\frac{1}{\sigma \sqrt{2 \pi}} e^{-\frac{(z-\mu)^{2} }{2 \sigma^{2}} }$。融合得到</p><script type="math/tex; mode=display">{\cal N}\left( {x,{\mu _0},{\sigma _0}} \right) \cdot {\cal N}\left( {x,{\mu _1},{\sigma _1}} \right) = {\cal N}\left( {x,{\mu ^\prime },{\sigma ^\prime }} \right)</script><p>其中</p><script type="math/tex; mode=display">{\mu ^\prime } = {\mu _0} + { {\sigma _0^2\left( { {\mu _1} - {\mu _0} } \right)} \over {\sigma _0^2 + \sigma _1^2} }</script><script type="math/tex; mode=display">{\sigma ^{\prime 2} } = \sigma _0^2 - { {\sigma _0^4} \over {\sigma _0^2 + \sigma _1^2} }</script><p>令${\bf{k}} = { {\sigma _0^2} \over {\sigma _0^2 + \sigma _1^2}}$则有</p><script type="math/tex; mode=display">{\mu ^\prime } = {\mu _0} + {\bf{k} }\left( { {\mu _1} - {\mu _0} } \right)</script><script type="math/tex; mode=display">{\sigma ^{\prime 2} } = \sigma _0^2 - {\bf{k} }\sigma _0^2</script><p>写成矩阵形式</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{K}=\Sigma_{0}\left(\Sigma_{0}+\Sigma_{1}\right)^{-1} \\\vec{\mu}^{\prime}=\overrightarrow{\mu_{0}}+\mathbf{K}\left(\overrightarrow{\mu_{1}}-\overrightarrow{\mu_{0}}\right) \\\Sigma^{\prime}=\Sigma_{0}-\mathbf{K} \Sigma_{0}\end{array}</script><p>其中$\mathbf{K}$为卡尔曼增益。</p><h3 id="计算值和测量值融合"><a href="#计算值和测量值融合" class="headerlink" title="计算值和测量值融合"></a>计算值和测量值融合</h3><p>连续系统的状态空间方程</p><script type="math/tex; mode=display">{ {\dot X}_t} = A{X_x} + B{U_t}</script><script type="math/tex; mode=display">{Z_t} = H{X_t}</script><p>其中$X$为系统的状态，$U$为系统的输入，$Z$传感器测量值，$H$状态到测量值的转换举证，由于传感器示数和状态的单位或者刻度不一样，$H$可能不是单位举证。</p><p>转换为离散形式，具体转换过程就叙述了，注意不是简单的替换，这里只是为了方便说明。</p><ol><li><p>计算值</p><script type="math/tex; mode=display">{X_k} = A{X_{k - 1}} + B{U_k} + {w_{k - 1}}</script><script type="math/tex; mode=display">{Z_k} = H{X_k}</script><p> 其中$w = {\cal N}(0,Q)$是由于模型不确定性和干扰带来的过程噪音</p><p> 设$Cov({X_k}) = {P_k}$为${X_k}$的协方差矩阵，又认为$U$的的协方差为0，并且和状态无关，过程噪声和状态也没有关系，则有${P_k} = A{P_{k - 1}}{A^{\rm{T}}}$<br> 所以就算值的协方差矩阵为</p><script type="math/tex; mode=display">Cov({Z_k}) = H{P_k}{H^{\rm{T}}}</script><p> 综上，计算值的概率分布为</p><script type="math/tex; mode=display">({\mu _0},{\Sigma _0}) = {\cal N}({H_k}{X_k},{H_k}{P_k}{H_k}^{\rm{T}})</script></li><li><p>测量值<br> 测量值的概率分布为，<script type="math/tex">({\mu _1},{\Sigma _1}) = {\cal N}({Z_k},{R_k})</script><br> 其中$R$为传感的噪声的方差</p></li><li><p>融合计算值和测量值<br> 借助上面高斯分布融合公式得到如下公式，用估计值作为计算值迭代求解下次估计值，初始状态估计值的均值的协方差可以大概给一个，会随着迭代次增加接近真实值。</p><script type="math/tex; mode=display">{\bf{\hat K}} = {P_k}H_k^T{\left( { {H_k}{P_k}H_k^T + {R_k} } \right)^{ - 1} }</script><script type="math/tex; mode=display">{ {\hat X}_k} = {X_k} + {\bf{\hat K} }\left( { {Z_k} - {H_k}{X_k} } \right)</script><script type="math/tex; mode=display">{ {\hat P}_k} = {P_k} - {\bf{\hat K} }{H_k}{P_k}</script></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://space.bilibili.com/230105574/channel/detail?cid=139198" target="_blank" rel="noopener">卡尔曼滤波器 视频详解</a></li><li><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener">How a Kalman filter works, in pictures</a></li><li><a href="https://blog.csdn.net/u010720661/article/details/63253509?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control" target="_blank" rel="noopener">详解卡尔曼滤波原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;
&lt;!-- code_chunk_output --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#卡尔曼滤波基本原理&quot;&gt;卡尔曼滤波基
      
    
    </summary>
    
      <category term="Math" scheme="http://yangbenbo.github.io/categories/Math/"/>
    
    
      <category term="卡尔曼滤波" scheme="http://yangbenbo.github.io/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>机械臂动力学</title>
    <link href="http://yangbenbo.github.io/2021/01/16/%E6%9C%BA%E6%A2%B0%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
    <id>http://yangbenbo.github.io/2021/01/16/机械臂动力学/</id>
    <published>2021-01-16T05:50:54.000Z</published>
    <updated>2023-07-08T23:10:12.070Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#机械臂动力学">机械臂动力学</a><ul><li><a href="#牛顿欧拉递推动力学">牛顿欧拉递推动力学</a></li></ul></li></ul><!-- /code_chunk_output --><h2 id="机械臂动力学"><a href="#机械臂动力学" class="headerlink" title="机械臂动力学"></a>机械臂动力学</h2><p>动力学主要研究:</p><ul><li>已知轨迹点求期望的关机力矩,用于机械臂控制</li><li>已知力矩求机械臂运动的轨迹点,用于仿真</li></ul><h3 id="牛顿欧拉递推动力学"><a href="#牛顿欧拉递推动力学" class="headerlink" title="牛顿欧拉递推动力学"></a>牛顿欧拉递推动力学</h3><p>牛顿欧拉递推动力学是一种高效的动力学计算方法</p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>${ }^{B} V_{Q}$: $Q$点在坐标系$\{B\}$中求导并表示</li><li>${ }^A({ }^{B} V_{Q})$: $Q$点在坐标系$\{B\}$中求导并在坐标系$\{A\}$中表示</li><li>$v_c = { }^{U} V_{CORG}$: 坐标系$\{C\}$原点在常见坐标系$\{U\}$中求导并表示</li><li>${ }^{A} v_c = { }^B_A R { }^{U} V_{CORG}$: 坐标系$\{C\}$原点在常见坐标系$\{U\}$中求导并表示</li><li>${ }^{A} \Omega_{B}$: 坐标系$\{B\}$相对于坐标系$\{A\}$的旋转角速度</li><li>$w_c = { }^{U} \Omega_{C}$: 坐标系$\{C\}$相对于世界坐标系$\{U\}$的旋转角速度</li><li>${}^Aw_c = {}^A_UR{ }^{U} \Omega_{C}$: 坐标系$\{C\}$相对于世界坐标系$\{U\}$的旋转角速度在坐标系$\{A\}$中的表示</li></ul><h4 id="刚体线速度-线加速度"><a href="#刚体线速度-线加速度" class="headerlink" title="刚体线速度/线加速度"></a>刚体线速度/线加速度</h4><p>坐标系$\{A\}$固定,$\{B\}$与$\{A\}$的原点重合,则$\{B\}$中一点$Q$的速度为:</p><script type="math/tex; mode=display">{ }^{A} V_{Q}={ }_{B}^{A} R^{B} V_{Q}+{ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} Q</script><p>扩展到原点不重合:</p><script type="math/tex; mode=display">{ }^{A} V_{Q}={}^AV_Q + { }_{B}^{A} R^{B} V_{Q}+{ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} Q</script><p>求导得:</p><script type="math/tex; mode=display">\begin{aligned}{ }^{A} V_{Q}={ }^{A} \dot{V}_{B O R G} &+{ }_{B}^{A} R^{B} \dot{V}_{Q}+2^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} V_{Q}+{ }^{A} \dot{\Omega}_{B} \times{ }_{B}^{A} R^{B} Q \\&+{ }^{A} \Omega_{B} \times\left({ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} Q\right)\end{aligned}</script><p>此式子可根据不同情况进行简化,比如${}^BQ$是常量时${ }^{B} V_{Q}={ }^{B} \dot{V}_{Q}=0$</p><h4 id="角速度-角加速度"><a href="#角速度-角加速度" class="headerlink" title="角速度/角加速度"></a>角速度/角加速度</h4><p>$\{B\}$相对于于$\{A\}$的角速度${}^A\Omega_B$,$\{C\}$相对于于$\{B\}$的角速度${}^B\Omega_C$,则有</p><script type="math/tex; mode=display">{ }^{A} \Omega_{C}={ }^{A} \Omega_{B}+{ }_{B}^{A} R^{B} \Omega_{C}</script><p>求导得:</p><script type="math/tex; mode=display">{ }^{A} \dot{\Omega}_{C}={ }^{A} \dot{\Omega}_{B}+{ }_{B}^{A} R^{B} \dot{\Omega}_{C}+{ }^{A} \Omega_{B} \times{ }_{B}^{A} R^{B} \Omega_{C}</script><h4 id="连杆速度传递"><a href="#连杆速度传递" class="headerlink" title="连杆速度传递"></a>连杆速度传递</h4><p>机械臂关节坐标系如图所示<br><img src="/2021/01/16/机械臂动力学/连杆速度传递.png" alt="连杆速度传递(图片来自Introduction to Robotics:Mechanics and Control)"></p><ol><li><p>直接采用前面推论进行替换得到最终的表达式<br> 角速度/角加速度推导</p><ul><li><p>坐标系$\{A\}$替换为坐标系$\{0\}$(世界坐标系),$\{B\}$替换为$\{i\}$,$\{Q\}$替换为$\{i+1\}$(可在$Q$点建立一个坐标系)</p></li><li><p>替换完之后左乘矩阵${}^{i+1}_0R$即可得到最终表达时</p><p>线速度/线加速度推导</p></li><li><p>坐标系$\{A\}$替换为坐标系$\{0\}$(世界坐标系),$\{B\}$替换为$\{i\}$,$\{C\}$替换为$\{i+1\}$</p></li><li><p>替换完之后左乘矩阵${}^{i+1}_0R$即可得到最终表达时</p></li></ul></li><li><p>直接求导推导<br> 世界坐标系下角速度:连杆的角速度等于上一个连杆的角速度加上由于关节转动带来的角速度</p><script type="math/tex; mode=display"> \boldsymbol{\omega}_{i+1}=\boldsymbol{\omega}_{i}+\dot{\boldsymbol{\theta}}_{i+1} \boldsymbol{z}_{i+1}</script><p> 求导然后左乘${}^{i+1}_0R$即可得到角加速度表达式,借助公式${}^0_i \dot{\boldsymbol{R}} = {}^0 \omega_{i} \times {}^0_i\boldsymbol{R}$</p><script type="math/tex; mode=display"> { }^{i+1} \dot{\omega}_{i+1}={ }_{i}^{i+1} R^{i} \dot{\omega}_{i}+{ }_{i}^{i+1} R^{i} \omega_{i} \times \dot{\theta}_{i+1}{ }^{i+1} \hat{z}_{i+1}+\ddot{\theta}_{i+1}{ }^{i+1} \hat{z}_{i+1}</script><p> 同理世界坐标系下线速度:连杆的线速度等于上一个连杆的线速度,上一个连杆转动带来的线速度,以及关节平移(移动关节才有)带来的速度之和</p><script type="math/tex; mode=display"> \boldsymbol{v}_{i+1}=\boldsymbol{v}_{i}+\boldsymbol{\omega}_{i} \times ({}^0_iR{}^i\boldsymbol{p}_{i+1})+\dot{\boldsymbol{d}}_{i+1} \boldsymbol{z}_{i+1}</script><p> ${}^0_iR{}^i\boldsymbol{p}_{i+1}$表示连杆坐标系$\{i\}$原点到$\{i+1\}$原点向量在世界坐标系下的表示<br> 求导即可得到线加速度关系,注意如果是移动关节,那么$\boldsymbol{p}_{i+1}$也是变化的所以才会有公式里面的倍数2,对应科式加速度</p><script type="math/tex; mode=display"> \begin{aligned} { }^{i+1} \dot{v}_{i+1} &={ }_{i}^{i+1} R\left({ }^{i} \dot{\omega}_{i} \times{ }^{i} P_{i+1}+{ }^{i} \omega_{i} \times\left({ }^{i} \omega_{i} \times{ }^{i} P_{i+1}\right)+{ }^{i} \dot{v}_{i}\right) \\ &+2^{i+1} \omega_{i+1} \times \dot{d}_{i+1}{ }^{i+1} \hat{z}_{i+1}+\ddot{d}_{i+1}{ }^{i+1} \hat{z}_{i+1} \end{aligned}</script><p> 也可以根据绝对加速度=相对加速度+牵连加速度+科式加速度来计算,在之前的文章<a href="/2020/01/13/科式加速度/" title="科式加速度">科式加速度</a>中有提到过<br> 质心的加速度更明显一点</p><script type="math/tex; mode=display"> {}^i \dot{v}_{C_{i}}={}^i\dot{\omega}_{i} \times^{i} P_{C_{i}}+{ }^{i} \omega_{i} \times\left({ }^{i} \omega_{i} \times { }^{i} P_{C_{i}}\right)+^{i} \dot{v}_{i}</script></li></ol><h4 id="连杆力-力矩传递"><a href="#连杆力-力矩传递" class="headerlink" title="连杆力/力矩传递"></a>连杆力/力矩传递</h4><p>不考虑重力,利用平衡方程递推关节力矩</p><script type="math/tex; mode=display">\begin{array}{l}F_{i}=m \dot{v}_{c_{i}} \\N_{i}=^{c_{i}} I \dot{\omega}_{i}+\omega_{i} \times^{c_{i}} I \omega_{i}\end{array}</script><p>得到转动关节递推算法:<br>外推:1-&gt;5:<br>${}^{i+1}  \omega_{i+1}={ }_{i}^{i+1} R^{i} \omega_{i}+\dot{\theta}_{i+1}^{i+1} \hat{Z}_{i+1}$<br>${ }^{i+1} \dot{\omega}_{i+1} ={ }_{i}^{i+1} R^{i} \dot{\omega}_{i}+{ }_{i}^{i+1} R^{i} \omega_{i} \times \dot{\theta}_{i+1}^{i+1} \hat{Z}_{i+1}+\ddot{\theta}_{i+1}^{i+1} \hat{Z}_{i+1}$<br>${ }^{i+1} \dot{v}_{i+1} ={ }_{i}^{i+1} R\left({ }^{i} \dot{\omega}_{i} \times{ }^{i} P_{i+1}+{ }^{i} \omega_{i} \times\left({ }^{i} \omega_{i} \times{ }^{i} P_{i+1}\right)+{ }^{i} \dot{v}_{i}\right)$<br>${ }^{i+1} \dot{v}_{C_{i+1}} ={ }^{i+1} \dot{\omega}_{i+1} \times{ }^{i+1} P_{C_{i+1}}+{ }^{i+1} \omega_{i+1} \times\left({ }^{i+1} \omega_{i+1} \times{ }^{i+1} P_{C_{i+1}}\right)+{ }^{i+1} \dot{v}_{i+1} $<br>${ }^{i+1} F_{i+1} =m_{i+1}{ }^{i+1} \dot{v}_{C_{i+1}}$<br>${ }^{i+1} N_{i+1} ={}^{C_{i+1}} I_{i+1}{ }^{i+1} \dot{\omega}_{i+1}+{ }^{i+1} \omega_{i+1} \times {}^{C_{i+1}} I_{i+1}{ }^{i+1} \omega_{i+1}$</p><p>内推:6-&gt;1<br>${}^i f_{i}={ }_{i+1}^{i} R^{i+1} f_{i+1}+{ }^{i} F_{i}$<br>${ }^{i} n_{i}={ }^{i} N_{i}+{ }_{i+1}^{i} R^{i+1} n_{i+1}+{ }^{i} P_{C_{i}} \times{ }^{i} F_{i}+{ }^{i} P_{i+1} \times{ }_{i+1}^{i} R^{i+1} f_{i+1}$<br>$\tau_{i}={ }^{i} n_{i}^{T} i \hat{Z}_{i}$</p><p>考虑重力:令${ }^{0} \dot{v}_{0}=G$,其中$G$与重力大小相等,方向相反,等价于机器人以1g的加速度向上做加速运动</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li>机器人学导论(Introduction to Robotics:Mechanics and Control)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=2650215895&amp;idx=1&amp;sn=98163c17bc650fc26c7dd2b52cede55c&amp;chksm=f1fb2efbc68ca7ed54b5c4c8ef33a2a02f27fe0dbb168a47d7550bdae2d1e22fd0950810169c&amp;mpshare=1&amp;scene=1&amp;srcid=01164QqSklrW7oMLuaaQ3E3v&amp;sharer_sharetime=1610778773411&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=A0RunuAtEUc1BIRp1U8qEPs%3D&amp;pass_ticket=fSV9aDHJ8qPwgo9Tg8KgiZWwCQ1rLqEqLnyLTx1rWWkQ12bzO4ZqXXrvKB6W%2FXxk&amp;wx_header=0#rd" target="_blank" rel="noopener">干货 | 机械臂的动力学（一）：牛顿欧拉法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;
&lt;!-- code_chunk_output --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#机械臂动力学&quot;&gt;机械臂动力学&lt;/a
      
    
    </summary>
    
      <category term="Math" scheme="http://yangbenbo.github.io/categories/Math/"/>
    
    
      <category term="机器人学" scheme="http://yangbenbo.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>GitHub的raw.githubusercontent.com无法链接</title>
    <link href="http://yangbenbo.github.io/2020/12/27/GitHub%E7%9A%84raw-githubusercontent-com%E6%97%A0%E6%B3%95%E9%93%BE%E6%8E%A5/"/>
    <id>http://yangbenbo.github.io/2020/12/27/GitHub的raw-githubusercontent-com无法链接/</id>
    <published>2020-12-27T09:57:04.000Z</published>
    <updated>2023-07-08T23:10:11.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无法使用rosdep-update更新"><a href="#无法使用rosdep-update更新" class="headerlink" title="无法使用rosdep update更新"></a>无法使用rosdep update更新</h2><p><code>rosdep update</code>报错</p><pre><code>&lt;urlopen error &lt;urlopen error [Errno 111] Connection refused&gt; (https://raw.githubusercontent.com/ros/rosdistro/master/index-v4.yaml)&gt;</code></pre><p>排查问题<br><code>ping</code>延迟太小了,国外服务器不可能延迟这么低,应该是本地的ip</p><pre><code>ping raw.githubusercontent.com      64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.030 ms64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.036 ms64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.025 ms</code></pre><p>进入<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a>,输入githubusercontent.com,得到<br>199.232.96.133,发现<code>ping</code>延迟很高,说明这才是真正的ip</p><pre><code>ping 199.232.96.13364 bytes from 199.232.96.133: icmp_seq=1 ttl=42 time=239 ms64 bytes from 199.232.96.133: icmp_seq=2 ttl=42 time=267 ms64 bytes from 199.232.96.133: icmp_seq=3 ttl=42 time=287 ms</code></pre><p>说明是DNS解析ip地址出了问题</p><p>解决方案:</p><ol><li><p>把真是ip写入host</p><pre><code> sudo gedit /etc/hosts # 增加一行   199.232.96.133 raw.githubusercontent.com</code></pre></li><li><p>修改DNS解析</p><pre><code> sudo gedit /etc/resolv.conf # 增加两行 nameserver 8.8.8.8 #google域名服务器 nameserver 8.8.4.4 #google域名服务器</code></pre><p> 进入这个文件发现提示不建议修改<strong>DO NOT EDIT THIS FILE BY HAND — YOUR CHANGES WILL BE OVERWRITTEN</strong><br> 不过也能用,之后再研究一下ubuntu DNS解析的内容</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.cnblogs.com/xyann/p/12738326.html" target="_blank" rel="noopener">GitHub的raw.githubusercontent.com无法链接</a></li><li><a href="https://blog.csdn.net/mrh1714348719/article/details/103803110" target="_blank" rel="noopener">ubuntu安装ROS进行到rosdep update时出现错误，如ERROR: unable to process source …</a></li><li><a href="http://hshsh.me/post/2016-08-09-ubuntu-14.04-dnsmasq/" target="_blank" rel="noopener">Ubuntu14.04上DNS引发的血案</a>            </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;无法使用rosdep-update更新&quot;&gt;&lt;a href=&quot;#无法使用rosdep-update更新&quot; class=&quot;headerlink&quot; title=&quot;无法使用rosdep update更新&quot;&gt;&lt;/a&gt;无法使用rosdep update更新&lt;/h2&gt;&lt;p&gt;&lt;c
      
    
    </summary>
    
      <category term="ROS" scheme="http://yangbenbo.github.io/categories/ROS/"/>
    
    
      <category term="DNS" scheme="http://yangbenbo.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>相机标定</title>
    <link href="http://yangbenbo.github.io/2020/12/26/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
    <id>http://yangbenbo.github.io/2020/12/26/相机标定/</id>
    <published>2020-12-26T06:54:40.000Z</published>
    <updated>2023-07-08T23:10:12.086Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#相机内参标定">相机内参标定</a><ul><li><a href="#kalib">kalib</a></li><li><a href="#camera-calibration">camera-calibration</a></li></ul></li><li><a href="#相机外参标定手眼标定">相机外参标定(手眼标定)</a><ul><li><a href="#franka-realsense-标定">franka realsense 标定</a></li></ul></li><li><a href="#引用">引用</a></li></ul><!-- /code_chunk_output --><h2 id="相机内参标定"><a href="#相机内参标定" class="headerlink" title="相机内参标定"></a>相机内参标定</h2><p>主要有两种方式</p><ul><li><a href="http://wiki.ros.org/camera_calibration/Tutorials/StereoCalibration" target="_blank" rel="noopener">camera-calibration</a></li><li><a href="https://github.com/ethz-asl/kalibr" target="_blank" rel="noopener">kalibr</a></li></ul><h3 id="kalib"><a href="#kalib" class="headerlink" title="kalib"></a>kalib</h3><ol><li><p>生成标定棋格盘</p><p> 可以使用<a href="https://github.com/ethz-asl/kalibr/wiki/calibration-targets" target="_blank" rel="noopener">kalibr_create_target_pdf</a></p><p> 查看帮助</p><pre><code> kalibr_create_target_pdf --h kalibr_create_target_pdf --type apriltag --nx [NUM_COLS] --ny [NUM_ROWS] --tsize [TAG_WIDTH_M] --tspace [TAG_SPACING_PERCENT]</code></pre><p> 生成A4纸棋盘内部角点个数6x7棋盘格,边长0.030m,打印的时候选择实际大小,否则打印出来的格子可能比较小.可能需要安装模块<code>sudo apt-get install python-pyx</code></p><pre><code>  kalibr_create_target_pdf --type checkerboard --nx 6 --ny 7 --csx 0.030 --csy 0.030</code></pre></li></ol><ol><li><p>录制bag包<br> 首先运行相机驱动</p><p> 可以更改相机话题和频率</p><pre><code> rosrun topic_tools throttle messages /camera/color/image_raw 4.0 /color</code></pre><p> 录制图像</p><pre><code> rosbag record -O camd435 /color</code></pre></li><li><p>标定<br> 一种是使用<code>kalibr_calibrate_cameras</code>标定</p><p> 生成<code>checkerboard.yaml</code>文件</p><pre><code> target_type: &#39;checkerboard&#39; #gridtype targetCols: 6               #number of internal chessboard corners targetRows: 7               #number of internal chessboard corners rowSpacingMeters: 0.03      #size of one chessboard square [m] colSpacingMeters: 0.03      #size of one chessboard square [m]</code></pre><p> 标定</p><pre><code> kalibr_calibrate_cameras --target path/to/checkerboard.yaml --bag path/to/camd435i.bag --models pinhole-equi --topics /color --show-extractio</code></pre><hr><p> 另一种是使用matlab工具箱标定</p><pre><code> %% 读取bag文件 bag = rosbag(&#39;camd435.bag&#39;); geometry_message = select(bag,&#39;Topic&#39;,&#39;/color&#39;); data = readMessages(geometry_message); imshow(readImage(data{1, 1}));  % 显示图片 % 保存图片 for i = 1 : length(data)     im_data = readImage(data{i, 1});         imwrite(im_data, [num2str(i), &#39;.png&#39;]); end %% matlab 工具箱Camera Calibrator(在app里面搜索然后导入图片) 标定后可以生成代码</code></pre></li></ol><h3 id="camera-calibration"><a href="#camera-calibration" class="headerlink" title="camera-calibration"></a>camera-calibration</h3><ol><li><p>安装标定包</p><pre><code> sudo apt-get install ros-kinetic-camera-calibration</code></pre></li><li><p>运行标定程序<br> 会有一个GUI方便操作,将棋盘对着相机朝着左/右/上/下/前/后移动，还需要倾斜棋盘。绿色填满之后点击CALIBRATE按钮,需要等几分钟. 生成的文件在<code>/tmp/calibrationdata.tar.gz</code>中</p><pre><code> rosrun camera_calibration cameracalibrator.py --size 6x7 --square 0.03 image:=/image_raw camera:=/camera</code></pre></li><li><p>获取标定结果</p><pre><code> cd /tmp tar -xvzf calibrationdata.tar.gz mv ost.txt ost.ini # 得到camera.yaml rosrun camera_calibration_parsers convert ost.ini camera.yaml</code></pre></li></ol><h2 id="相机外参标定-手眼标定"><a href="#相机外参标定-手眼标定" class="headerlink" title="相机外参标定(手眼标定)"></a>相机外参标定(手眼标定)</h2><p>这篇文章的图片已经解释的很清楚了<a href="https://blog.csdn.net/yaked/article/details/77161160?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">机器人手眼标定Ax=xB（eye to hand和eye in hand）及平面九点法标定</a></p><ol><li>eye-in-hand<br> 两次运动,机器人底座和标定板的位恣关系不变,求解相机和机器人末端的位姿关系<br> <img src="/2020/12/26/相机标定/eye-in-hand.png" alt="eye-in-hand">    </li><li>eye-on-base<br> 两次运动,机器人末端和标定板的位恣关系不变,求解相机和机器人基座之间的位恣关系<br> <img src="/2020/12/26/相机标定/eye-on-base.png" alt="eye-on-base"></li></ol><h3 id="franka-realsense-标定"><a href="#franka-realsense-标定" class="headerlink" title="franka realsense 标定"></a>franka realsense 标定</h3><p>主要使用了三个包:</p><ul><li><a href="https://github.com/pal-robotics/aruco_ros" target="_blank" rel="noopener">aruco_ros</a>, 相机获取二维码位恣,二维码可通过<a href="https://chev.me/arucogen/" target="_blank" rel="noopener">ArUco markers generator!</a>生成,记得一定要选择<em>Original ArUco</em><br>ID和size根据需要选择,这两个参数在之后的launch文件中使用,这里选用的是ID:582,size:50</li><li><a href="https://github.com/IFL-CAMP/easy_handeye" target="_blank" rel="noopener">easy_handeye</a>, 结合moveit标定的包</li><li><a href="https://github.com/IntelRealSense/realsense-ros" target="_blank" rel="noopener">realsense-ros</a>, realsense ros驱动</li></ul><p>则有标定launch文件如下,标定后得到camera_link到panda_link0的位恣变换,然后在launch文件中使用tf2_ros中的static_transform_publisher发布出来即可使用</p><pre><code>    &lt;?xml version=&quot;1.0&quot; ?&gt;    &lt;launch&gt;        &lt;!--  franka --&gt;        &lt;arg name=&quot;robot_ip&quot; default=&quot;192.168.10.102&quot;/&gt;        &lt;arg name=&quot;move_group&quot; default=&quot;panda_arm&quot; /&gt;        &lt;arg name=&quot;robot_base_frame&quot; default=&quot;panda_link0&quot;/&gt;        &lt;arg name=&quot;robot_effector_frame&quot; default=&quot;panda_EE&quot;/&gt;        &lt;!--  marker  --&gt;        &lt;arg name=&quot;markerId&quot;        default=&quot;582&quot;/&gt;        &lt;arg name=&quot;markerSize&quot;      default=&quot;0.05&quot;/&gt;    &lt;!-- in m --&gt;        &lt;arg name=&quot;marker_frame&quot;    default=&quot;aruco_marker_frame&quot;/&gt;        &lt;arg name=&quot;ref_frame&quot;       default=&quot;camera_link&quot;/&gt;  &lt;!-- leave empty and the pose will be published wrt param parent_name --&gt;        &lt;arg name=&quot;camera_frame&quot;    default=&quot;camera_color_optical_frame&quot;/&gt;        &lt;arg name=&quot;corner_refinement&quot; default=&quot;LINES&quot; /&gt; &lt;!-- NONE, HARRIS, LINES, SUBPIX --&gt;        &lt;!--  launch franka  --&gt;        &lt;include file=&quot;$(find franka_control)/launch/franka_control.launch&quot;&gt;            &lt;arg name=&quot;robot_ip&quot; value=&quot;$(arg robot_ip)&quot; /&gt;            &lt;arg name=&quot;load_gripper&quot; value=&quot;true&quot; /&gt;        &lt;/include&gt;        &lt;include file=&quot;$(find panda_moveit_config)/launch/panda_moveit.launch&quot;&gt;            &lt;arg name=&quot;load_gripper&quot; value=&quot;true&quot; /&gt;        &lt;/include&gt;        &lt;!--  panda_link0 to world TF  --&gt;        &lt;node pkg=&quot;tf2_ros&quot; type=&quot;static_transform_publisher&quot; name=&quot;virtual_joint_broadcaster_1&quot; args=&quot;0 0 0 0 0 0 world panda_link0&quot; /&gt;        &lt;!--  realsense  --&gt;        &lt;include file=&quot;$(find realsense2_camera)/launch/rs_camera.launch&quot;/&gt;        &lt;!--  marker  --&gt;        &lt;node pkg=&quot;aruco_ros&quot; type=&quot;single&quot; name=&quot;aruco_single&quot;&gt;            &lt;remap from=&quot;/camera_info&quot; to=&quot;/camera/color/camera_info&quot; /&gt;            &lt;remap from=&quot;/image&quot; to=&quot;/camera/color/image_raw&quot; /&gt;            &lt;param name=&quot;image_is_rectified&quot; value=&quot;True&quot;/&gt;            &lt;param name=&quot;marker_size&quot;        value=&quot;$(arg markerSize)&quot;/&gt;            &lt;param name=&quot;marker_id&quot;          value=&quot;$(arg markerId)&quot;/&gt;            &lt;param name=&quot;reference_frame&quot;    value=&quot;$(arg ref_frame)&quot;/&gt;   &lt;!-- frame in which the marker pose will be refered --&gt;            &lt;param name=&quot;camera_frame&quot;       value=&quot;$(arg camera_frame)&quot;/&gt;            &lt;param name=&quot;marker_frame&quot;       value=&quot;$(arg marker_frame)&quot; /&gt;            &lt;param name=&quot;corner_refinement&quot;  value=&quot;$(arg corner_refinement)&quot; /&gt;        &lt;/node&gt;        &lt;node pkg=&quot;image_view&quot; type=&quot;image_view&quot; name=&quot;iamge_view&quot; args=&quot;image:=/aruco_single/result&quot; /&gt;        &lt;!--  easy hand eye calibrate  --&gt;        &lt;include file=&quot;$(find easy_handeye)/launch/calibrate.launch&quot;&gt;            &lt;arg name=&quot;eye_on_hand&quot; value=&quot;false&quot;/&gt;            &lt;arg name=&quot;move_group&quot; value=&quot;$(arg move_group)&quot; /&gt;            &lt;!-- fill in the following parameters according to your robot&#39;s published tf frames --&gt;            &lt;arg name=&quot;robot_base_frame&quot; value=&quot;$(arg robot_base_frame)&quot;/&gt;            &lt;arg name=&quot;robot_effector_frame&quot; value=&quot;$(arg robot_effector_frame)&quot;/&gt;            &lt;!-- fill in the following parameters according to your tracking system&#39;s published tf frames --&gt;            &lt;arg name=&quot;tracking_base_frame&quot; value=&quot;$(arg ref_frame)&quot;/&gt;            &lt;arg name=&quot;tracking_marker_frame&quot; value=&quot;$(arg marker_frame)&quot;/&gt;        &lt;/include&gt;    &lt;/launch&gt;</code></pre><p>遇到的问题:</p><ol><li><p>import cv2的版本不对(<code>pip3 install opencv-python</code> <code>pip install opencv-contrib-python</code> 安装位置在~/.local下)</p><pre><code> # 查看cv2的路径 发现对的cv2在~/.local下 import cv2 help(cv2)  # 是cv2.so文件 可以通过locate定位(根据需要进行updatedb) # 查看python path信息 import sys sys.path    # &#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;在前面, 而对的cv2在~/.local,排在后面 # 在需要用到cv2的地方如下处理即可 import sys sys.path.remove(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;) import cv2 sys.path.append(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;)</code></pre></li><li><p>无法显示rqt_gui界面的gui操作框<br>可能是由于conda环境冲突,切换回系统对应的环境就可以了(最开始是把libqt5*卸载之后再安装依赖就可以,之后发现还是得切换回之前的环境)</p></li><li><p>相机对反光敏感<br> 相机外参标定好之后在rviz中查看点云,人站在相机正前方走动会产生其它地方的点云(机械臂附近),造成干扰</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/yaked/article/details/77161160?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">机器人手眼标定Ax=xB（eye to hand和eye in hand）及平面九点法标定</a></li><li><a href="https://mp.weixin.qq.com/s/nJx1dlpBXaL2_iT_J4W5Kg" target="_blank" rel="noopener">3D 视觉之手眼标定</a></li><li><a href="https://blog.csdn.net/qq_34935373/article/details/103727968" target="_blank" rel="noopener">通过ROS控制真实机械臂(15) —- 视觉抓取之手眼标定</a></li><li><a href="https://blog.csdn.net/AnChenliang_1002/article/details/109775356" target="_blank" rel="noopener">Inter Realsense D435i标定过程步骤记录（超详细）</a></li><li><a href="https://blog.csdn.net/qq_42688495/article/details/107640826" target="_blank" rel="noopener">视觉SLAM | RealsenseD435i相机标定</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;
&lt;!-- code_chunk_output --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#相机内参标定&quot;&gt;相机内参标定&lt;/a
      
    
    </summary>
    
      <category term="ROS" scheme="http://yangbenbo.github.io/categories/ROS/"/>
    
    
      <category term="标定" scheme="http://yangbenbo.github.io/tags/%E6%A0%87%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>pyhton 代码规范</title>
    <link href="http://yangbenbo.github.io/2020/12/12/pyhton-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yangbenbo.github.io/2020/12/12/pyhton-代码规范/</id>
    <published>2020-12-12T09:01:28.000Z</published>
    <updated>2023-07-08T23:10:11.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ol><li>缩进<br> 缩进必须使用4个空格，而不是tab，否则容易出现pylint:<code>bad-indentation.</code><br> vscode可以将tab转化为空格<br> F1 -&gt; 输入indentation space -&gt; 回车  (查看是空格还是tab可以通过选中对应行或者全选)</li></ol><h2 id="c-vscode-自动格式化"><a href="#c-vscode-自动格式化" class="headerlink" title="c++  vscode 自动格式化"></a>c++  vscode 自动格式化</h2><ul><li><p>设置 -&gt; 搜索 clang format -&gt; 在Clang_format_path 中输入</p><pre><code>  { BasedOnStyle: Google, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Custom, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 100, AccessModifierOffset: -3 }</code></pre></li><li>设置 -&gt; 搜索 save format -&gt; 勾选Format on Save</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编码风格&quot;&gt;&lt;a href=&quot;#编码风格&quot; class=&quot;headerlink&quot; title=&quot;编码风格&quot;&gt;&lt;/a&gt;编码风格&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;缩进&lt;br&gt; 缩进必须使用4个空格，而不是tab，否则容易出现pylint:&lt;code&gt;bad-indentat
      
    
    </summary>
    
      <category term="Program" scheme="http://yangbenbo.github.io/categories/Program/"/>
    
    
      <category term="代码规范" scheme="http://yangbenbo.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>四元数</title>
    <link href="http://yangbenbo.github.io/2020/11/25/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    <id>http://yangbenbo.github.io/2020/11/25/四元数/</id>
    <published>2020-11-25T07:36:23.000Z</published>
    <updated>2023-07-08T23:10:12.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><p>四元数是由爱尔兰数学家威廉·卢云·哈密顿在1843年创立出的数学概念.速度更快、提供平滑插值、有效避免万向锁问题、存储空间较小.</p><script type="math/tex; mode=display">q=a+b i+c j+d k \quad(a, b, c, d \in \mathbb{R})</script><p>其中</p><script type="math/tex; mode=display">i^{2}=j^{2}=k^{2}=i j k=-1</script><h2 id="罗德里格旋转公式-Rodrigues’-rotation-formula"><a href="#罗德里格旋转公式-Rodrigues’-rotation-formula" class="headerlink" title="罗德里格旋转公式(Rodrigues’ rotation formula)"></a>罗德里格旋转公式(Rodrigues’ rotation formula)</h2><p>罗德里格旋转公式是在给定转轴和旋转角度后,旋转一个向量的有效算法.公式如下,具体推导参考图片(<a href="https://commons.wikimedia.org/w/index.php?curid=43943835" target="_blank" rel="noopener">By Maschen - Own work, CC0</a>)</p><p><img src="/2020/11/25/四元数/rodrigues_rotation_formula.svg" alt="rodrigues rotation formula"></p><script type="math/tex; mode=display">\mathbf{v}_{\mathrm{rot}}=\mathbf{v} \cos \theta+(\mathbf{k} \times \mathbf{v}) \sin \theta+\mathbf{k}(\mathbf{k} \cdot \mathbf{v})(1-\cos \theta)</script><h2 id="四元数基本运算"><a href="#四元数基本运算" class="headerlink" title="四元数基本运算"></a>四元数基本运算</h2><ul><li><p>模长</p><script type="math/tex; mode=display">  \|q\|=\sqrt{a^{2}+b^{2}+c^{2}+d^{2}}</script></li><li><p>加减法</p><script type="math/tex; mode=display">  q_{1} \pm q_{2}=[s \pm t, \mathbf{v} \pm \mathbf{u}]</script></li><li><p>乘法<br>  对任意四元数 $q_{1}=[s, \mathbf{v}], q_{2}=[t, \mathbf{u}]$ 有</p><script type="math/tex; mode=display">  q_{1} q_{2}=[s t-\mathbf{v} \cdot \mathbf{u}, s \mathbf{u}+t \mathbf{v}+\mathbf{v} \times \mathbf{u}]</script></li><li><p>逆</p><script type="math/tex; mode=display">  q^{-1}=\frac{q^{*}}{\|q\|^{2}}</script><script type="math/tex; mode=display">  q_{1}^{*} q_{2}^{*}=\left(q_{2} q_{1}\right)^{*}</script></li><li><p>旋转公式</p><script type="math/tex; mode=display">  v^{\prime}=q v q^{*}=q v q^{-1}</script><p>  可借助罗德里格旋转公式,分别对垂直旋转轴和平行旋转轴的向量进行旋转.</p><p>  或者借助$\mathbf{a} \times(\mathbf{b} \times \mathbf{c})=(\mathbf{a} \cdot \mathbf{c}) \mathbf{b}-(\mathbf{a} \cdot \mathbf{b}) \mathbf{c}$直接推导</p><script type="math/tex; mode=display">  q v q^{*}=[0, \cos (\theta) \mathbf{v}+(1-\cos (\theta))(\mathbf{u} \cdot \mathbf{v}) \mathbf{u}+\sin (\theta)(\mathbf{u} \times \mathbf{v})]</script><p>  注意:可以证明<strong>即使v不是实部为0的纯四元数,旋转公式所得结果的向量部分也相同</strong></p></li></ul><h2 id="双倍覆盖"><a href="#双倍覆盖" class="headerlink" title="双倍覆盖"></a>双倍覆盖</h2><p>四元数q与-q表示同一个旋转,轴正方向旋转$\theta $,与反方向旋转$2\pi  - \theta $等价</p><h2 id="四元数插值"><a href="#四元数插值" class="headerlink" title="四元数插值"></a>四元数插值</h2><ol><li><p>两个四元数之间中间变换<br> 两个四元数之间的中间变换可以通过对空间中一个向量的变换来理解.<br> 四元数${q_0}$到${q_1}$的变换</p><script type="math/tex; mode=display"> \begin{aligned} \Delta q &=q_{1} q_{0}^{*} \\ &=\left[\cos \left(\theta_{1}\right), \sin \left(\theta_{1}\right) \mathbf{u}_{1}\right]\left[\cos \left(\theta_{0}\right),-\sin \left(\theta_{0}\right) \mathbf{u}_{0}\right] \\ &=\left[\cos \left(\theta_{0}\right) \cos \left(\theta_{1}\right)-\left(\sin \left(\theta_{1}\right) \mathbf{u}_{1}\right) \cdot\left(-\sin \left(\theta_{0}\right) \mathbf{u}_{0}\right), \ldots\right] \\ &=\left[\cos \left(\theta_{0}\right) \cos \left(\theta_{1}\right)+\left(\sin \left(\theta_{1}\right) \mathbf{u}_{1}\right) \cdot\left(\sin \left(\theta_{0}\right) \mathbf{u}_{0}\right), \ldots\right] \end{aligned}</script><p> $\Delta q$的角度看实部就可以了,实部就是两个四元数的点乘${q_0} \cdot {q_1}$的结果,由于两个都是单位四元数,所以中间变换$\Delta q$在三维空间中实际旋转的角度就是两个四元数之间夹角的两倍</p></li><li><p>常用插值算法</p><ul><li>正规化线性插值（Normalized Linear Interpolation）,沿着直线进行差值,在差值角度比较大会出现角速度不均匀</li><li><p>球面线性插值 ( Spherical Linear Interpolation), 最常用的姿态差值算法, 运算会多一点,较慢, 小角度通常选用Nlerp,效果差不多, 还能避免除以0的错误, 实际算法中可以检测四元数之间的夹角, 小角度用Nlerp,大角度用Slerp</p><p><strong>同时由于双倍覆盖的问题,在进行姿态插值时需要先计算两个四元数之间夹角是否大于90°,如果大于可以把其中一个四元素反转,即-q</strong>       </p></li></ul></li></ol><h2 id="四元数在不同坐标系下变换"><a href="#四元数在不同坐标系下变换" class="headerlink" title="四元数在不同坐标系下变换"></a>四元数在不同坐标系下变换</h2><ol><li><p>求${q}$姿态对应坐标系下z轴在极坐标系下的表示如下,只需要把全局坐标系中z轴(0,0,1)进行对应变换就可以(同旋转矩阵一样,可以理解为旋转算子或者姿态)</p><script type="math/tex; mode=display">q \cdot z \cdot {q^ * }</script></li><li><p>求两个四元素之间的中间变换对应的轴,比如${q_1}$到${q_0}$,</p><p> ${q_0}q_1^*$,然后取出旋转轴就可以.如果想把轴转换到${q_0}$坐标系下,则旋转回来再提取轴</p><p> 另外在<a href="https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/src/cartesian_impedance_example_controller.cpp" target="_blank" rel="noopener">franka程序</a>    中看到换了成了$q_0^ * {q_1}$ ,然后增加负号并旋转变换到基坐标系下,这里推导<strong>只针对向量部分</strong>,即旋转轴,借助前面的结论<strong>普通四元数与纯四元数使用旋转公式后向量部分同</strong><br> 这里还使用了单位四元数的共轭就是逆,即把向量部分取负号</p><script type="math/tex; mode=display">{q_0}( - q_0^ * {q_1})q_0^ *  = {q_0}{(q_0^ * {q_1})^{ - 1}}q_0^ *  = {q_0}q_1^ * {q_0}q_0^ *  = {q_0}q_1^ *</script></li></ol><h2 id="四元数可视化"><a href="#四元数可视化" class="headerlink" title="四元数可视化"></a>四元数可视化</h2><p>参考3blue1brown的教程,四元数变换可以理解为对四维空间的变换然后投影到三维空间成我们见到的.</p><p>变换的形象理解是拉伸和旋转,考虑一个四元数对另一个四元数的作用(变换),简单理解就是对四元数的基1,i,j,k作用看效果</p><ul><li>把位于原点的1拉伸到四元数乘子所在位置</li><li>绕轴旋转对应的角度</li></ul><p>文章:<a href="https://eater.net/quaternions" target="_blank" rel="noopener">Visualizing quaternions</a></p><p>视频:</p><ul><li><a href="https://www.bilibili.com/video/BV1SW411y7W1?from=search&amp;seid=14501682529068922403" target="_blank" rel="noopener">四元数的可视化</a></li><li><a href="https://www.bilibili.com/video/BV1Lt411U7og?from=search&amp;seid=14501682529068922403" target="_blank" rel="noopener">四元数和三维转动，可互动的探索式视频（请看链接）</a></li></ul><h2 id="重点参考"><a href="#重点参考" class="headerlink" title="重点参考"></a>重点参考</h2><p>文章内有对四元数的详细介绍,四元数插值部分也讲得非常清楚</p><div class="row">    <embed src="quaternion.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%85%83%E6%95%B8" target="_blank" rel="noopener">四元数</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E5%BE%B7%E9%87%8C%E6%A0%BC%E6%97%8B%E8%BD%AC%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">罗德里格旋转公式</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=2650216092&amp;idx=1&amp;sn=7f99fc0bc70293a3c5719ca864ece4ca&amp;chksm=f1fb2db0c68ca4a674760ce8c8bda1c3c4c6bcace1def7bb6eb132bc14c916669fb736377296&amp;mpshare=1&amp;scene=23&amp;srcid=1125JzIIUJ2yJphL2dc91Yay&amp;sharer_sharetime=1606291414222&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51#rd" target="_blank" rel="noopener">干货 | 欧拉角，四元数？晕头转向的空间姿态表示法（下篇）</a></li><li><a href="https://krasjet.github.io/quaternion/" target="_blank" rel="noopener">quaternion by krasjet</a></li><li><a href="https://www.qiujiawei.com/understanding-quaternions/" target="_blank" rel="noopener">Understanding Quaternions 中文翻译《理解四元数》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;四元数&quot;&gt;&lt;a href=&quot;#四元数&quot; class=&quot;headerlink&quot; title=&quot;四元数&quot;&gt;&lt;/a&gt;四元数&lt;/h1&gt;&lt;p&gt;四元数是由爱尔兰数学家威廉·卢云·哈密顿在1843年创立出的数学概念.速度更快、提供平滑插值、有效避免万向锁问题、存储空间较小.&lt;/
      
    
    </summary>
    
      <category term="Math" scheme="http://yangbenbo.github.io/categories/Math/"/>
    
    
      <category term="四元数" scheme="http://yangbenbo.github.io/tags/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>逆运动学</title>
    <link href="http://yangbenbo.github.io/2020/11/23/%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
    <id>http://yangbenbo.github.io/2020/11/23/逆运动学/</id>
    <published>2020-11-23T05:37:45.000Z</published>
    <updated>2023-07-08T23:10:12.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆运动学"><a href="#逆运动学" class="headerlink" title="逆运动学"></a>逆运动学</h1><p>逆运动学是已知机械臂末端的位姿求解关节角度的过程,通常有两种方法:</p><ul><li>解析法.使用代数或者几何法求解,可以求得当前位姿对应的所有解,需要选择离当前位置最近的关节角解缺点是机械臂需要满足一定的要求.</li><li>优化法.把问题转化为优化问题(很多问题都可以转化为优化问题),缺点是只能获得一个解,耗时相对较长</li></ul><h2 id="优化法"><a href="#优化法" class="headerlink" title="优化法"></a>优化法</h2><ol><li><p>雅克比逆(牛顿-拉夫森法, Newton-Raphson Method)<br> 逆运动学就是求解方程$f(\theta)=0$,目标是找到关节坐标满足$x_{d}-f\left(\theta_{d}\right)=0$,使用泰勒展开,即</p><script type="math/tex; mode=display"> x_{d}=f\left(\theta_{d}\right)=f\left(\theta_{0}\right)+\underbrace{\left.\frac{\partial f}{\partial \theta}\right|_{\theta_{0}}}_{J\left(\theta_{0}\right)} \underbrace{\left(\theta_{d}-\theta_{0}\right)}_{\Delta \theta}+\mathrm{h.o.t.}</script><p> 只保留泰勒级数到第一项,简化为</p><script type="math/tex; mode=display"> J\left(\theta_{0}\right) \Delta \theta=x_{d}-f\left(\theta_{0}\right)</script><p> 如果作则雅克比矩阵可逆,则有</p><script type="math/tex; mode=display"> \Delta \theta=J^{-1}\left(\theta_{0}\right)\left(x_{d}-f\left(\theta_{0}\right)\right)</script><p> 如果正向运行学$f(\theta)$是$\theta$的线性函数,泰勒级数没有高阶项,新的估计值$\theta_{1}=\theta_{0}+\Delta \theta$精确满足运动学方程,<br> 相反,如果运动学是非线性函数,那么新的估计值将会更接近真实值,迭代不断重复,直到$\theta$收敛,如下图所示<br> <img src="/2020/11/23/逆运动学/niudun.png" alt="牛顿-拉夫森法"><br> 如果逆运动学存在多组解,则只会找到最近的解.在实际使用中,矩阵求逆很耗费计算资源,通常是借鉴$A x=b$,使用矩阵的LU分解.</p><p> 如果雅克比不可逆,则使用矩阵伪逆(Moore-Penrose),伪逆求法:</p><ul><li>SVD分解, 然后求逆</li><li>行满秩,右逆 $J^{\dagger}=J^{T}\left(J J^{T}\right)^{-1}$</li><li><p>列满秩,左逆 $J^{\dagger}=\left(J^{T} J\right)^{-1} J^{T}$<br>使用伪逆得到的解不会精确满足方程,但从最小二乘的层面会尽可能接近这个条件,求线性方程组或者拟合的时候经常用到.伪逆推导就是求解</p><script type="math/tex; mode=display">\begin{array}{c}\min _{\dot{q}}\|\dot{q}\|^{2} \\\text {subject to } \dot{x}=J \dot{q}\end{array}</script><p>然后使用<strong>拉格朗日乘数法（Lagrange Multiplier）</strong> 变成</p><script type="math/tex; mode=display">\min _{\dot{q}} \frac{1}{2}\|\dot{q}\|^{2}+\lambda^{T}(\dot{x}-J \dot{q})</script><p>分别对两个变量求导等与0得到两个方程求解就得到了右伪逆.<br>顺带说一下雅克比的零空间(null space),把关节速度投影到”零空间内”,对末端运动没有影响,公式如下,可以参考我的另一篇文章<a href="/2020/02/19/雅克比矩阵零空间/" title="雅克比矩阵零空间">雅克比矩阵零空间</a>    </p><script type="math/tex; mode=display">\forall \dot{q}_{0}, J\left(I-J^{+} J\right) \dot{q}_{0}=0</script><p>上述方法只是针对机械臂的末端位置求解,如果增加姿态,则不能只是直接简单相减,使用雅克比我们可以先求出末端的线速度和角速度(物体的速度旋量)</p><p>首先计算相对物体坐标系的期望位形</p><script type="math/tex; mode=display">T_{b d}\left(\theta_{i}\right)=T_{s b}^{-1}\left(\theta_{i}\right) T_{s d}=T_{b s}\left(\theta_{i}\right) T_{s d}</script><p>其中b指代body,即当前末端位恣,d指代destination.然后使用矩阵对数求解旋量</p><script type="math/tex; mode=display">\left[\mathcal{V}_{b}\right]=\log T_{b d}\left(\theta_{i}\right)</script><p>然后迭代求解</p><script type="math/tex; mode=display">\theta_{i+1}=\theta_{i}+J_{b}^{\dagger}\left(\theta_{i}\right) \mathcal{V}_{b}</script><p>注意这里使用的是物体雅克比(Body Jacobian)和对应的物体运动旋量(Body Twist),如果使用空间雅克比和空间运动旋量需要转换一下,$\mathcal{V}_{s}=\left[\mathrm{Ad}_{T_{s b}}\right] \mathcal{V}_{b}$</p><p>雅克比逆的方法也可以理解从当前点到目标点的速度,然后用雅克比逆求解关节角速度,使用到下一个关节角度的叠加,<br>只是这种理解关节角度角度变化不能太大,否则雅克比不准(和关节构型有关,是变化的)</p></li></ul></li><li><p>雅克比转置(梯度下降法)<br> 逆解的目标是当前的位置距离目标位置尽可能近,转化为一个最小值问题</p><script type="math/tex; mode=display"> \min _{q} \frac{1}{2}\left\|x_{d}-x_{c}\right\|^{2}</script><p> 这里有系数只是为了求导后没有系数,不影响结果,将当前位置带入方程得</p><script type="math/tex; mode=display"> \min _{q} \frac{1}{2}\left\|x_{d}-f(q)\right\|^{2}</script><p> 这个时候可以使用梯度下降法,每一步都沿着下降最快的方向走,方向为梯度的反方向</p><script type="math/tex; mode=display"> \begin{aligned} \Delta q &=-\alpha \nabla\left(\frac{1}{2}\left\|x_{d}-f(q)\right\|^{2}\right) \\ &=\alpha\left(\left(x_{d}-x\right)^{T} \frac{\partial f(q)}{\partial q}\right)^{T} \\ &=\alpha J^{T}\left(x_{d}-x\right)=\alpha J^{T} \Delta x \end{aligned}</script><p> 其中$\alpha$是梯度下降法的一个系数,步长(step size)或这学习效率(learning rate).步长太大导致”走过头”甚至多绕弯路,<br> 最终迭代速度慢(甚至无法收敛),步长太小导致迭代速度太慢.</p><p> 雅克比转置方法不需要求逆,不过收敛速度反而慢一点,使用这个方法控制机械臂,离end effector较远的关节常常需要输出更大的扭矩。</p></li><li><p>阻尼最小二平方法(DLS, Damped Least Square)<br> 雅克比奇异导致关节速度过大,这显然是我们不希望看到的,现在也有很多避奇异的方法,DLS就是一种限制关节速度的方法,<br> 这时我们需要最小化的目标是</p><script type="math/tex; mode=display"> \|J \Delta \theta-\overrightarrow{\mathrm{e}}\|^{2}+\lambda^{2}\|\Delta \theta\|^{2}</script><p> 即把关节变化量放进最小化的目标函数,方程可等价于</p><script type="math/tex; mode=display"> \left\|\left(\begin{array}{c} J \\ \lambda I \end{array}\right) \Delta \theta-\left(\begin{array}{c} \overrightarrow{\mathrm{e}} \\ 0 \end{array}\right)\right\|</script><p> 借鉴线性方程组$A x=b$求解(伪逆)</p><script type="math/tex; mode=display"> \left(\begin{array}{c} J \\ \lambda I \end{array}\right)^{T}\left(\begin{array}{c} J \\ \lambda I \end{array}\right) \Delta \boldsymbol{\theta}=\left(\begin{array}{c} J \\ \lambda I \end{array}\right)^{T}\left(\begin{array}{l} \overrightarrow{\mathbf{e}} \\ \mathbf{0} \end{array}\right)</script><p> 进而得到</p><script type="math/tex; mode=display"> \left(J^{T} J+\lambda^{2} I\right) \Delta \boldsymbol{\theta}=J^{T} \overrightarrow{\mathbf{e}}</script><p> 由于左侧矩阵非奇异,则有</p><script type="math/tex; mode=display"> \Delta \boldsymbol{\theta}=\left(J^{T} J+\lambda^{2} I\right)^{-1} J^{T} \overrightarrow{\mathbf{e}}</script><p> 同时有$\left(J^{T} J+\lambda^{2} I\right)^{-1} J^{T}=J^{T}\left(J J^{T}+\lambda^{2} I\right)^{-1}$ 可以左右两侧同时乘$J^{T} J+\lambda^{2} I$<br> 则有</p><script type="math/tex; mode=display"> \Delta \boldsymbol{\theta}=J^{T}\left(J J^{T}+\lambda^{2} I\right)^{-1} \overrightarrow{\mathbf{e}}</script><p> 这就是DLS方法的迭代方程</p><p> 在编程实现中,通常是直接处理雅克比矩阵奇异值分解后对奇异值操作,这是等效的,首先奇异值分解</p><script type="math/tex; mode=display"> J=U D V^{T}</script><p> 然后化简得到</p><script type="math/tex; mode=display">{J^T}{\left( {J{J^T} + {\lambda ^2}I} \right)^{ - 1}} = V{D^T}{\left( {D{D^T} + {\lambda ^2}I} \right)^{ - 1}}{U^T} = VE{U^T}</script><p> 从这里可以看出E为对称矩阵,而且值为(雅克比矩阵svd分解后奇异值为$\sigma_$,求逆之后为倒数)</p><script type="math/tex; mode=display"> e_{i, i}=\frac{\sigma_{i}}{\sigma_{i}^{2}+\lambda^{2}}</script><p> 所以一种比较简单的方式就是直接处理奇异值,<a href="https://github.com/CentroEPiaggio/kuka-lwr/blob/master/lwr_controllers/include/utils/pseudo_inversion.h" target="_blank" rel="noopener">kuka-lwr</a>就是这样处理的</p></li></ol><p>总结: DLS方法可以看成是两种方法的结合,<br>当$\lambda$很小时,根据SVD分解奇异值可以看出来就是牛顿-拉夫森法(矩阵逆),<br>当$\lambda$很大, $J{J^T}$为对阵矩阵,可以分解为<script type="math/tex">J{J^T} = Q\Lambda {Q^T}</script>,由于分解后的特征值相对$\lambda$ 很小,则最后直接成为下式,其实就是前面的梯度法  </p><script type="math/tex; mode=display">\Delta \boldsymbol{\theta}=J^{T}\left(\lambda^{2} \right)^{-1} \overrightarrow{\mathbf{e}}</script><p>逆解参考Samuel R. Buss的Introduction to Inverse Kinematics with Jacobian Transpose, Pseudoinverse and Damped Least Squares methods<br><div class="row">    <embed src="iksurvey.pdf" width="100%" height="550" type="application/pdf"></div></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>使用<a href="https://bitbucket.org/traclabs/trac_ik/src/master/" target="_blank" rel="noopener">trac-ik</a>求解motoman逆运动学的时候容易求到距离当前关节较远的位置<br>通过判断关节角度差来决定是否需要重新逆解即可</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402440005&amp;idx=1&amp;sn=6fd6f3dab8d2a5859100b8d432b4bc57&amp;chksm=7bf084694c870d7fc3cda2050951d2464f2bf8d3a3fe53a5793b8c4853e7907f64d2f61c252e&amp;mpshare=1&amp;scene=1&amp;srcid=1122bJnzmLv4PJaTr2MAtKsn&amp;sharer_sharetime=1606046642935&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=Ax1h1mIg50AJIvm3eB93%2F%2B8%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd" target="_blank" rel="noopener">干货 | “逆运动学”——从操作空间到关节空间（上篇）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402732106&amp;idx=1&amp;sn=49072186c7c893a6e09801f11e8ffd78&amp;chksm=740d0f66437a86702b645b1e9a79d809e9c5feae53bdbbf39a81932c163c5bf1643f0da193ae&amp;mpshare=1&amp;scene=1&amp;srcid=1122mBBiPmcRYHdHnoQr8iQ9&amp;sharer_sharetime=1606046650729&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=A1IFM3SHYDEbQt4WRKd233w%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd" target="_blank" rel="noopener">干货 | “逆运动学”——从操作空间到关节空间（下篇）</a></li><li><a href="http://hades.mech.northwestern.edu/index.php/Modern_Robotics" target="_blank" rel="noopener">MODERN ROBOTICS MECHANICS, PLANNING, AND CONTROL</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆运动学&quot;&gt;&lt;a href=&quot;#逆运动学&quot; class=&quot;headerlink&quot; title=&quot;逆运动学&quot;&gt;&lt;/a&gt;逆运动学&lt;/h1&gt;&lt;p&gt;逆运动学是已知机械臂末端的位姿求解关节角度的过程,通常有两种方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析法.使用代数或者几何法求解
      
    
    </summary>
    
      <category term="Math" scheme="http://yangbenbo.github.io/categories/Math/"/>
    
    
      <category term="机器人" scheme="http://yangbenbo.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yangbenbo.github.io/2020/11/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yangbenbo.github.io/2020/11/14/多线程/</id>
    <published>2020-11-14T13:07:02.000Z</published>
    <updated>2023-07-08T23:10:12.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-使用线程注意事项"><a href="#c-使用线程注意事项" class="headerlink" title="c++ 使用线程注意事项"></a>c++ 使用线程注意事项</h2><ol><li><p>限定符避免编译器优化<br> <a href="/2019/10/06/c++记录/" title="参考限定符部分">参考限定符部分</a>,不过没用好像也没什么问题   </p><pre><code> // 线程操作对象需要增加volatile,避免编译器优化(直接从变量地址读取而不是上次的值) volatile int val;</code></pre></li><li><p>锁同一个对象需要同一个锁,如全局变量或类对象        </p><pre><code> std::mutex mut   //构造函数加锁,析构函数解锁,避免程序意外终止结果没来得及解锁 lock_guard&lt;mutex&gt; lock (mut);  </code></pre></li><li><p>sleep_for,线程休眠指定时间后唤醒,不过由于线程调度等原因,实际睡眠时间可能更长</p><pre><code> std::this_thread::sleep_for( std::chrono::milliseconds(2000) );        </code></pre></li><li>线程销毁 <ul><li>thread::join()调用后,调用它的线程会被block，直到线程的执行被完成.如果一个c++线程对象销毁时还可以join就会抛出异常</li><li>thread::detach()函数被调用后,执行的线程从线程对象中被分离,已不再被一个线程对象所表达—这是两个独立的事情.</li><li>执行到析构函数时要么join,要么detach线程</li></ul></li></ol><h2 id="c-11院子操作-atomic-operation"><a href="#c-11院子操作-atomic-operation" class="headerlink" title="c++11院子操作(atomic operation)"></a>c++11院子操作(atomic operation)</h2><p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义.确保同一时刻只有唯一的线程对指定的全局资源进行访问,<br>类似互斥锁,但是原子操作更加接近底层，因而效率更高.</p><p>使用非常简单,只是类型不一样,且不用加锁就能保证线程访问的安全性,类型包括atomic_bool,atomic_int等常用简单类型</p><pre><code>#include &lt;atomic&gt;      atomic_long total(0);total++;</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/fawdlstty/article/details/49492197?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf" target="_blank" rel="noopener">C++11：多线程与锁</a></li><li><a href="https://blog.csdn.net/fengbingchun/article/details/73521630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf" target="_blank" rel="noopener">C++11中std::mutex的使用</a></li><li><a href="https://blog.csdn.net/xibeichengf/article/details/71173543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf" target="_blank" rel="noopener">thread中join和detach的区别</a></li><li><a href="https://blog.csdn.net/yockie/article/details/8838686?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control" target="_blank" rel="noopener">C++11中的原子操作（atomic operation）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;c-使用线程注意事项&quot;&gt;&lt;a href=&quot;#c-使用线程注意事项&quot; class=&quot;headerlink&quot; title=&quot;c++ 使用线程注意事项&quot;&gt;&lt;/a&gt;c++ 使用线程注意事项&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;限定符避免编译器优化&lt;br&gt; &lt;a href=&quot;/
      
    
    </summary>
    
      <category term="Program" scheme="http://yangbenbo.github.io/categories/Program/"/>
    
    
      <category term="多线程" scheme="http://yangbenbo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电脑小问题记录</title>
    <link href="http://yangbenbo.github.io/2020/11/12/%E7%94%B5%E8%84%91%E5%B0%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yangbenbo.github.io/2020/11/12/电脑小问题记录/</id>
    <published>2020-11-12T00:43:35.000Z</published>
    <updated>2023-08-06T08:46:48.983Z</updated>
    
    <content type="html"><![CDATA[<p>电脑的问题有时候是硬件问题,需要细心排查</p><h2 id="电脑无法正常启动"><a href="#电脑无法正常启动" class="headerlink" title="电脑无法正常启动"></a>电脑无法正常启动</h2><ol><li>电脑上电之后马上自己断电,如此反复<br> 把线头紧一下,内存条拿下来擦一下就可以了,可能是线头送了或者之前打扫的时候灰尘太大影响的主板</li><li>双系统电脑开机之后没有ubuntu grub启动项选项,直接进入ubuntu,进系统前显示屏一直没有信号输入<br> 电脑显示器插头松了.另一种可能是需要把内存条拿下来擦一下    <h2 id="中文输入法下使用英文标点"><a href="#中文输入法下使用英文标点" class="headerlink" title="中文输入法下使用英文标点"></a>中文输入法下使用英文标点</h2><code>Ctrl + ,</code>进行切换,需要在语言栏未打开的情况下才能使用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;电脑的问题有时候是硬件问题,需要细心排查&lt;/p&gt;
&lt;h2 id=&quot;电脑无法正常启动&quot;&gt;&lt;a href=&quot;#电脑无法正常启动&quot; class=&quot;headerlink&quot; title=&quot;电脑无法正常启动&quot;&gt;&lt;/a&gt;电脑无法正常启动&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;电脑上电之后马上自己断电
      
    
    </summary>
    
      <category term="Linux" scheme="http://yangbenbo.github.io/categories/Linux/"/>
    
    
      <category term="软硬件" scheme="http://yangbenbo.github.io/tags/%E8%BD%AF%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>python 装饰器</title>
    <link href="http://yangbenbo.github.io/2020/11/10/python-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yangbenbo.github.io/2020/11/10/python-装饰器/</id>
    <published>2020-11-10T06:00:30.000Z</published>
    <updated>2023-07-08T23:10:11.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python装饰器-property"><a href="#python装饰器-property" class="headerlink" title="python装饰器 @property"></a>python装饰器 @property</h2><p>绑定属性时有时候我们只想只读类的属性值,或者有限制的更改类的属性值</p><p>可以使用get()和set()方法,但是略显复杂,使用装饰器可以更简单,python内置的@property装饰器负责把方法变成属性调用</p><pre><code>class Student(object):    @property    def score(self):        return self._score    @score.setter    def score(self, value):        if not isinstance(value, int):            raise ValueError(&#39;score must be an integer!&#39;)        if value &lt; 0 or value &gt; 100:            raise ValueError(&#39;score must between 0 ~ 100!&#39;)        self._score = value</code></pre><p>把getter方法变成属性时只需要@property,@score.setter负责把setter方法变成属性赋值,对于只读属性可只定义getter方法</p><p><strong>这种方式对于单个值设置只读是很有帮助的,但是对于列表,numpy数组等就无法防止对列表中单个数据的修改</strong></p><pre><code>import numpy as npclass testnp(object):    def __init__(self):        self._data = [1, 1]        self._npdata = np.asarray([1, 1, 1])    @property    def data(self):        return self._data    @property    def npdata(self):        return self._npdata        # return self.get_readOnly_view(self._npdata)    def get_readOnly_view(self, data):        res = data.view()        res.flags.writeable = False        return restest = testnp()print &quot;初始值:&quot;print test.dataprint test.npdatadata = test.datanpdata = test.npdata# 测试赋值前# 可以单独修改# test.data[0] = 10 # 原始数据修改 [10,1]# test.npdata[0] = 10     # 原始数据修改 [10, 1, 1]# 整体无法修改# test.data = [10,10] # AttributeError: can&#39;t set attribute# test.npdata = np.asarray([10, 10, 10])  # AttributeError: can&#39;t set attribute# 测试赋值后# 新变量整体操作不影响# data = [10,10]  # 原始数据保留# npdata = np.asarray([10, 10, 10])   # 原始数据保留# 新变量操作元素改变数据# data[0] = 10    #   原始数据修改 [10, 1]# npdata[0] = 10  # 原始数据修改 [10, 1, 1]</code></pre><p>使用@property</p><ul><li>只作用于赋值前的数据.如果赋值给新变量,那么新变量可以再赋值,不过不会影响到原始数据(新变量是一个新的对象)</li><li>只能作用于整个变量.对于列表和<code>numpy</code>数组,能够防止对于整体数据的修改,如果对列表中元素修改会修改到原始数据,不论是赋值前后</li></ul><p>从装饰器也可以看出来返回的值就是对象数据本身,虽然整体值不让改,但是元素的值可以改;</p><ul><li>list:python中一般会使用写时复制功能,所以新变量赋值再更改之后就是另一个变量,和之前的数据没有关系,变量名可以看成是指向了另一块内存区域</li><li>numpy数组:numpy自身优化了效率,需要调用<code>numpy.copy</code>才能深度拷贝成为另一个变量,否则即使赋值给变量,对新变量的操作还是对同一块内存区域的操作</li></ul><p>解决办法:</p><ul><li>列表可以返回一个拷贝<code>return self._data[:]</code>,如果数据量大是很不利的</li><li>numpy可以返回一个只读属性的view,见上面测试代码.为了利用@property把获取数据的方法变成属性使用,可以直接把返回的只读numpy数组使用@property再次封装.这样整体和单独变量都不会被修改,如果需要修改,那么深度拷贝返回值即可<code>numpy.copy(test.npdata)</code></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208" target="_blank" rel="noopener">廖雪峰python教程 使用@property</a></li><li><a href="https://stackoverflow.com/questions/60810463/is-this-a-correct-way-to-create-a-read-only-view-of-a-numpy-array" target="_blank" rel="noopener">Is this a correct way to create a read-only view of a numpy array?</a>          </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python装饰器-property&quot;&gt;&lt;a href=&quot;#python装饰器-property&quot; class=&quot;headerlink&quot; title=&quot;python装饰器 @property&quot;&gt;&lt;/a&gt;python装饰器 @property&lt;/h2&gt;&lt;p&gt;绑定属性
      
    
    </summary>
    
      <category term="Program" scheme="http://yangbenbo.github.io/categories/Program/"/>
    
    
      <category term="python" scheme="http://yangbenbo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>解决conda和ros库不兼容问题,libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用</title>
    <link href="http://yangbenbo.github.io/2020/11/10/%E8%A7%A3%E5%86%B3libapr-1-so-0%EF%BC%9A%E5%AF%B9%E2%80%98uuid-generate-UUID-1-0%E2%80%99%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://yangbenbo.github.io/2020/11/10/解决libapr-1-so-0：对‘uuid-generate-UUID-1-0’未定义的引用/</id>
    <published>2020-11-10T03:05:40.000Z</published>
    <updated>2023-07-08T23:10:12.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要是因为conda和ros兼容的问题"><a href="#主要是因为conda和ros兼容的问题" class="headerlink" title="主要是因为conda和ros兼容的问题"></a>主要是因为conda和ros兼容的问题</h2><ol><li>问题关键词： <strong>libapr-1.so.0</strong>和<strong>uuid</strong></li><li><p>locate第一个关键词: </p><pre><code> $ locate libapr-1.so.0  /usr/lib/x86_64-linux-gnu/libapr-1.so.0 /usr/lib/x86_64-linux-gnu/libapr-1.so.0.5.2</code></pre></li><li><p>查看该库对第二个关键字的依赖包位置</p><pre><code> $ ldd /usr/lib/x86_64-linux-gnu/libapr-1.so.0 |grep uuid libuuid.so.1 =&gt; /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f3588aab000)</code></pre><p> 这是ros系统所使用的库依赖，报错是因为anaconda中也有libuuid.so.1,但是版本不同</p></li><li><p>locate第二个关键词</p><pre><code>$ locate libuuid.so.1  /home/yang/anaconda3/envs/franka/lib/libuuid.so.1/home/yang/anaconda3/envs/franka/lib/libuuid.so.1.0.0/home/yang/anaconda3/lib/libuuid.so.1/home/yang/anaconda3/lib/libuuid.so.1.0.0/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1.0.0/lib/i386-linux-gnu/libuuid.so.1/lib/i386-linux-gnu/libuuid.so.1.3.0/lib/x86_64-linux-gnu/libuuid.so.1/lib/x86_64-linux-gnu/libuuid.so.1.3.0/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1.3.0/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1.3.0</code></pre><p>可以看出,ros使用的是/lib/x86_64-linux-gnu/libuuid.so.1,由于anaconda的存在,我使用的库是/home/yang/anaconda3/envs/franka/lib/libuuid.so.1<br>对比两个版本</p><pre><code>$ ll /lib/x86_64-linux-gnu/ |grep uuid   lrwxrwxrwx  1 root root      16 Jan 27  2020 libuuid.so.1 -&gt; libuuid.so.1.3.0-rw-r--r--  1 root root   18976 Jan 27  2020 libuuid.so.1.3.0$ ll ~/anaconda3/envs/franka/lib |grep uuid-rw-rw-r--  3 yang yang    26398 Jan 12  2018 libuuid.a-rwxrwxr-x  1 yang yang      978 Nov  9 16:05 libuuid.la*lrwxrwxrwx  1 yang yang       16 Nov  9 16:05 libuuid.so -&gt; libuuid.so.1.0.0*lrwxrwxrwx  1 root root       34 Nov 10 09:35 libuuid.so.1 -&gt; libuuid.so.1.0.0*-rwxrwxr-x  3 yang yang    18472 Jan 12  2018 libuuid.so.1.0.0*可以看出系统库是1.3.0版本,anaconda使用的是1.0.0版本</code></pre></li><li><p>把anaconda库链接到系统的库(比较简单,可以先把anaconda对应库备份一下,也可以考虑升级anaconda对应库,但是我没找到)</p><pre><code> mv ~/anaconda3/envs/franka/lib/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1.back        sudo ln -s /lib/x86_64-linux-gnu/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1</code></pre></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/qq_36013249/article/details/103311001" target="_blank" rel="noopener">解决libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主要是因为conda和ros兼容的问题&quot;&gt;&lt;a href=&quot;#主要是因为conda和ros兼容的问题&quot; class=&quot;headerlink&quot; title=&quot;主要是因为conda和ros兼容的问题&quot;&gt;&lt;/a&gt;主要是因为conda和ros兼容的问题&lt;/h2&gt;&lt;ol&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://yangbenbo.github.io/categories/Linux/"/>
    
    
      <category term="anaconda" scheme="http://yangbenbo.github.io/tags/anaconda/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yangbenbo.github.io/2020/05/22/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yangbenbo.github.io/2020/05/22/python基础/</id>
    <published>2020-05-22T08:52:49.000Z</published>
    <updated>2023-07-16T23:11:31.989Z</updated>
    
    <content type="html"><![CDATA[<p>很多简单模块容易忘,在此记录一下</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><ol><li><p>查看帮助文档</p><pre><code> import os # 主要有3中类型 ,也可以针对具体函数 dir(os) help(os)  os.__doc__</code></pre></li><li><p>查看变量内存地址</p><pre><code> # 需要注意有时候变量的复制是浅拷贝,地址相同的 # 使用pybullet获取机械臂位置就是这样,机械臂运动之后地址才变了 print(id(object))</code></pre></li><li><p>查看当前路径</p><pre><code> import os os.getcwd()</code></pre></li><li><p>copy模块</p><ul><li><p>注意python具有即时复制的功能</p><pre><code>  a = 1  b = a  print(id(a), id(b))  b = 2  print(id(a), id(b))</code></pre></li><li><p>有些模块如numpy没有特别设置不会深拷贝,通常配合copy.deepcopy()</p></li></ul></li><li><p>python3中@<br> 矩阵乘法</p><pre><code> Op    Precedence/associativity    Methods @    Same as *                    __matmul__, __rmatmul__ @=    n/a                            __imatmul__</code></pre></li><li><p>numpy数组交换行列</p><pre><code> a = np.array([[1,2,3],[2,3,4],[1,6,5], [9,3,4]]) a[:,[1,0,2]]</code></pre></li></ol><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><ol><li><p>常用安装命令</p><pre><code> # 安装 conda环境可以使用conda install xxx pip install package_name pip install package_name==package_version # 更新 pip install -U package_name # 显示模块的信息 pip show package_name # 查看对应包简单信息 pip list |grep package_name # 卸载建议这种方式,不会会有残留文件(针对pip install -e .) pip uninstall package_name  </code></pre></li><li><p>pip install -e . VS python setup.py install</p><pre><code> Editable   pip                    setup.py yes        pip install -e .       python setup.py develop     no         pip install .          python setup.py install   </code></pre></li></ol><ul><li><p>可编辑模式安装(develop,可以在当前文件基础上修改)</p><p>这种方式会在site-packages下创建一个文件指向项目目录,并不会复制对应代码;<br>在项目根目录(setup.py所在)会生成egg-info 文件夹包含这个包的主要信息;<br>查看sys.path会发现里面多了一个项目根目录的路径</p><pre><code>  pip install -e /path/to/your/setup.py  # 项目根目录                  </code></pre></li><li>install 这种方式会在site-packages生成egg文件,里面包含对应的函数和模块,无法修改</li></ul><h2 id="python2和3用法区别"><a href="#python2和3用法区别" class="headerlink" title="python2和3用法区别"></a>python2和3用法区别</h2><ol><li><p>super函数<br> super() 函数是用于调用父类(超类)的一个方法。<br> super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p><p> python3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx :</p><pre><code> #!/usr/bin/python # -*- coding: UTF-8 -*- class A(object):   # Python2.x 记得继承 object     def add(self, x):          y = x+1          print(y) class B(A):     def add(self, x):         super(B, self).add(x)  # python3 直接super().add(x) b = B() b.add(2)  # 3</code></pre></li></ol><h2 id="pybullet-结合-ROS"><a href="#pybullet-结合-ROS" class="headerlink" title="pybullet 结合 ROS"></a>pybullet 结合 ROS</h2><p>将pybullet中获取的图像通过变换获得对应的点云图<br><div class="row">    <embed src="OPGL_pointcloud.pdf" width="100%" height="550" type="application/pdf"></div></p><ol><li><p>Image  numpy array to sensor_msgs/Image</p><pre><code> from cv_bridge import CvBridge import numpy as np from sensor_msgs.msg import Image # 确保能都找到正确的opencv2的位置 import sys sys.path.remove(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;) import cv2 rgb_np_arr, depth_np_arr, seg_mask_np_arr, point_cloud = self.camera.get_camera_frame() bridge = CvBridge() image_message = bridge.cv2_to_imgmsg(rgb_np_arr[:, :, [2, 1, 0, 3]].astype(&#39;uint8&#39;))  # default bgra8</code></pre></li><li><p>Pointcloud numpy to sensor_msgs/PointCloud2     </p><pre><code> import ros_numpy import numpy as np from sensor_msgs.msg import PointCloud2, PointField number = point_cloud.shape[0] * point_cloud.shape[1] point_cloud_arr = point_cloud.reshape([number, 3]) data = np.zeros(number, dtype=[     (&#39;x&#39;, np.float32),     (&#39;y&#39;, np.float32),     (&#39;z&#39;, np.float32) ]) data[&#39;x&#39;] = point_cloud_arr[:, 0] data[&#39;y&#39;] = point_cloud_arr[:, 1] data[&#39;z&#39;] = point_cloud_arr[:, 2] cloud_msg = ros_numpy.msgify(PointCloud2, data) cloud_msg.header.frame_id = &quot;map&quot;</code></pre></li><li><p>pointcloud from image deepth<br> reshape 默认是按行排列, 按列需要order=’F’</p><p> 矩阵求逆 np.linalg.inv(x)</p><p> 矩阵乘积 np.matmul(a, b)</p><pre><code> stepX = 10 stepY = 10 pointCloud = np.empty([np.int(self.img_height/stepY), np.int(self.img_width/stepX), 4]) projectionMatrix = np.asarray(self.projection_matrix).reshape([4,4],order=&#39;F&#39;) viewMatrix = np.asarray(view_matrix).reshape([4,4],order=&#39;F&#39;) tran_pix_world = np.linalg.inv(np.matmul(projectionMatrix, viewMatrix)) for h in range(0, self.img_height, stepY):     for w in range(0, self.img_width, stepX):         x = (2*w - self.img_width)/self.img_width         y = -(2*h - self.img_height)/self.img_height  # be careful！ deepth and its corresponding position         z = 2*depth_np_arr[h,w] - 1         pixPos = np.asarray([x, y, z, 1])         position = np.matmul(tran_pix_world, pixPos)         pointCloud[np.int(h/stepY),np.int(w/stepX),:] = position / position[3]          </code></pre></li></ol><h2 id="python代码中查看当前编译器版本"><a href="#python代码中查看当前编译器版本" class="headerlink" title="python代码中查看当前编译器版本"></a>python代码中查看当前编译器版本</h2><pre><code>import sysprint(sys.version)  # python2      </code></pre><h2 id="脚本中指定编译器"><a href="#脚本中指定编译器" class="headerlink" title="脚本中指定编译器"></a>脚本中指定编译器</h2><p>相当于写死了python3路径;</p><pre><code>#!/usr/bin/python3</code></pre><p>去环境设置寻找python3目录,推荐这种写法</p><pre><code>#!/usr/bin/env python3      </code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>使用正则表达式可以非常方便从文本中获取到需要的值, 相对matlab速度更快<br><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式 - 教程</a>, 验证正则表达式是否正确参考<a href="https://c.runoob.com/front-end/854/" target="_blank" rel="noopener">正则表达式在线测试|菜鸟工具</a></p><ul><li>字符匹配<br>普通字符：普通字符按照字面意义进行匹配，例如匹配字母 “a” 将匹配到文本中的 “a” 字符。<br>元字符：元字符具有特殊的含义，例如 \d 匹配任意数字字符，\w 匹配任意字母数字字符，. 匹配任意字符（除了换行符）等。</li><li>量词<br>*：匹配前面的模式零次或多次。<br>+：匹配前面的模式一次或多次。<br>?：匹配前面的模式零次或一次。<br>{n}：匹配前面的模式恰好 n 次。<br>{n,}：匹配前面的模式至少 n 次。<br>{n,m}：匹配前面的模式至少 n 次且不超过 m 次。</li><li>字符类<br>[ ]：匹配括号内的任意一个字符。例如，[abc] 匹配字符 “a”、”b” 或 “c”。<br><sup><a href="#fn_ " id="reffn_ "> </a></sup>：匹配除了括号内的字符以外的任意一个字符。例如，<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup> 匹配除了字符 “a”、”b” 或 “c” 以外的任意字符。</li><li>边界匹配<br>^：匹配字符串的开头。<br>$：匹配字符串的结尾。<br>\b：匹配单词边界。<br>\B：匹配非单词边界。</li><li>分组和捕获<br>( )：用于分组和捕获子表达式。<br>(?: )：用于分组但不捕获子表达式。</li><li>特殊字符<br>\：转义字符，用于匹配特殊字符本身。<br>.：匹配任意字符（除了换行符）。<br>|：用于指定多个模式的选择。</li></ul><p>常用正则:</p><ul><li>数字匹配并分组<code>(-?\d+\.?\d*(?:e[+-]?\d+)?)</code></li><li>匹配所有<code>[\s\S]</code>, <code>\s</code>匹配所有空白符, 包括换行, <code>\S</code>非空白符，不包括换行</li><li><p>匹配一个数字字符<code>\d</code>, 等价于 [0-9]</p><pre><code>  # 匹配带字符`UT: a0: 数字`  import re  a0Reg = re.compile(r&quot;[\s\S]+UT: a0: (-?\d+\.?\d*(?:e[+-]?\d+)?)&quot;)  line = &quot;fhdsa UT: a0: 1.23&quot;  m = a0Reg.match(line)  if m:          print(float(m.group(i + 1))) # 索引0 对应整个字符串, 1开始为分组内部的内容</code></pre></li></ul><p>python中可视化可以用<code>matplot</code>, 如果想要更好的绘图可以使用matlab, 这是只是用python提取数据, 存放在txt可以用<code>numpy</code>, 先创建list, 然后转换numpy格式</p><pre><code>class GetData:def __int__(self):    self.version = 1.0@staticmethoddef get_joint(data_file, data_reg, num_jnt):    &quot;&quot;&quot;Get several data from file with regular expression    Used for analyze data    Args:        data_file (str): The path of the file to read        data_reg (Pattern object): regular expression pattern        num_jnt (int): number of data    Returns:        t_arr: time in millisecode        jnt_arr: data array    &quot;&quot;&quot;    data_list = []    t = []    with open(data_file, &quot;rt&quot;, encoding=&#39;utf-8&#39;) as fp:        for line in fp:            m = data_reg.match(line)            if m:                datime = line[1:27]                time_array = datetime.datetime.strptime(datime, &quot;%Y-%m-%d %H:%M:%S.%f&quot;)                time_stamp = time.mktime(time_array.timetuple()) + time_array.microsecond / 1e6                t.append(time_stamp)                data_line = []                for i in range(num_jnt):                    data_line.extend([float(m.group(i + 1))])                data_list.append(data_line)    data_arr = np.asarray(data_list)    t_arr = np.asarray(t)    return t_arr, data_arr@staticmethoddef get_matrix(data_file, data_text, data_reg, num_row, num_col):    jnt_list = []    t = []    with open(data_file, &quot;rt&quot;, encoding=&#39;utf-8&#39;) as fp:        for line in fp:            if data_text in line:                next_line = fp.readline()                m = data_reg.match(next_line)                if m:                    datime = line[12:27]                    t_tmp = datetime.datetime.strptime(datime, &quot;%H:%M:%S.%f&quot;)                    t.append(t_tmp)                    jnt = []                    for i in range(num_row * num_col):                        jnt.extend([float(m.group(i + 1))])                    jnt_list.append(jnt)    jnt_arr = np.asarray(jnt_list)    return t, jnt_arr</code></pre><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><p>好的函数注释能够快速确认该如何使用, 特别时对于阅读老代码是非常有用的<br>参考<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="noopener">Google 开源项目风格指南</a></p><ul><li>google推荐  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def func(path, field_storage, temporary):</span><br><span class="line">    &apos;&apos;&apos;基本描述</span><br><span class="line"></span><br><span class="line">    详细描述</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        path (str): The path of the file to wrap</span><br><span class="line">        field_storage (FileStorage): The :class:`FileStorage` instance to wrap</span><br><span class="line">        temporary (bool): Whether or not to delete the file when the File instance is destructed</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        BufferedFileStorage: A buffered writable file descriptor</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li></ul><p>也可以通过库函数跳转到定义, 参考官方的注释方式</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>ImportError: cannot import name ‘PackageFinder’</p><pre><code> curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py &amp;&amp; python get-pip.py</code></pre></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.jb51.cc/python/241778.html" target="_blank" rel="noopener">在virtualenv中设置：<code>pip install -e .</code> vs <code>python setup.py install</code></a></li><li><a href="https://www.jianshu.com/p/9a54e9f3e059" target="_blank" rel="noopener">如何将自己的Python程序打包—setuptools详解</a></li><li><a href="https://blog.csdn.net/qq_35356840/article/details/88557912" target="_blank" rel="noopener">Python Numpy 如何交换两行和两列</a></li><li><a href="http://ksimek.github.io/2012/08/22/extrinsic/" target="_blank" rel="noopener">Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix</a></li><li><a href="https://zhuanlan.zhihu.com/p/73034007" target="_blank" rel="noopener">OpenGL投影矩阵(Projection Matrix)构造方法</a></li><li><a href="https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/" target="_blank" rel="noopener">OpenGL 101: Matrices - projection, view, model</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多简单模块容易忘,在此记录一下&lt;/p&gt;
&lt;h2 id=&quot;基础操作&quot;&gt;&lt;a href=&quot;#基础操作&quot; class=&quot;headerlink&quot; title=&quot;基础操作&quot;&gt;&lt;/a&gt;基础操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看帮助文档&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; import
      
    
    </summary>
    
      <category term="Program" scheme="http://yangbenbo.github.io/categories/Program/"/>
    
    
      <category term="python" scheme="http://yangbenbo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux + Qt5 + ROS配置Qwtplot3d</title>
    <link href="http://yangbenbo.github.io/2020/05/12/Linux-Qt5-ROS%E9%85%8D%E7%BD%AEQwtplot3d/"/>
    <id>http://yangbenbo.github.io/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/</id>
    <published>2020-05-12T12:09:33.000Z</published>
    <updated>2023-07-08T23:10:11.925Z</updated>
    
    <content type="html"><![CDATA[<p>qwtplot3D是一个Qt第三方库,在OpenGL基础上封装了一层可以用来三维绘图.</p><h2 id="Qt项目使用QwtPlot3d"><a href="#Qt项目使用QwtPlot3d" class="headerlink" title="　Qt项目使用QwtPlot3d"></a>　Qt项目使用QwtPlot3d</h2><ol><li>安装OpenGL(QwtPlot3d需要OpenGL作为基础)<br> 这一步网上很多教程,我之前装过,这里略过</li><li><p>下载QwtPlot3d压缩包两种选择,建议选a</p><p> a. 下载分支<a href="https://sourceforge.net/p/qwtplot3d/code/HEAD/tree/branches/multiple_curves_0_2_x/" target="_blank" rel="noopener">multiple_curves_0_2_x</a> 可以一个画面绘制多个图形</p><p> b. 下载<a href="https://sourceforge.net/projects/qwtplot3d/" target="_blank" rel="noopener">qwt-plot3d</a> <a href="https://blog.csdn.net/eastonwoo/article/details/37658141" target="_blank" rel="noopener">修改参考</a></p><p> 第一种方式顺利编译</p><p> 第二种方式,出现的问题 </p><pre><code> ‘gluErrorString’ was not declared in this scope err = gluErrorString(errcode);</code></pre><p> 解决方式</p><pre><code>    在include/qwt3d_openglhelper.h这个文件里添加 #include &lt;GL/glu.h&gt;    打开 qwtplot3d.pro , 在最前面输入下面这一句  LIBS += -lGLU            </code></pre></li><li><p>打开qwtplot3d.pro, 选择Release</p><p> 两种方式都可以编译后在编译文件夹找到4个libqwtplot3d.so*文件</p><p> 复制这四个文件到存放lib文件的目录,可以自己指定,我的是</p><pre><code> /opt/qt59/lib/x86_64-linux-gnu/qtcreator/</code></pre></li><li><p>打开qwtplot3d/examples/simpleplot/simpleplot.pro</p><pre><code> # 将第一句改为这二句 其实就是指定刚才生成的动态链接库的位置 # 其实把库文件放在原本指定的位置../../lib也可以编译成功 unix:LIBS += -lqwtplot3d -L../../lib unix:LIBS += -L/opt/qt59/lib/x86_64-linux-gnu/qtcreator/ -lqwtplot3d</code></pre><p> 其他项目使用需要生成的库文件.so 以及头文件 .h(qwtplot3d/include下),<br> simpleplot只用指定库是因为项目中指定了头文件位置</p><p> 运行程序如下<br> <img src="/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/simpleplot_mult.png" alt="simpleplot">    </p></li></ol><h2 id="ROS-CmakeLists-txt使用QwtPlot3d"><a href="#ROS-CmakeLists-txt使用QwtPlot3d" class="headerlink" title="ROS CmakeLists.txt使用QwtPlot3d"></a>ROS CmakeLists.txt使用QwtPlot3d</h2><pre><code># 把头文件拷贝到include/qwt 下并包含include_directories(${catkin_INCLUDE_DIRS}    include/qwt)# 寻找OpenGL 这是底层库find_package(Qt5 COMPONENTS Core Widgets OpenGL REQUIRED)# 设置库文件路径set(QT_LIBRARIES Qt5::Widgets Qt5::OpenGL)#added# 生成可执行程序并链接库add_executable(qwtdemo  src/traj_graph.cpp)target_link_libraries(qwtdemo ${QT_LIBRARIES} ${catkin_LIBRARIES}    qwtplot3d ) </code></pre><p><strong>特别注意:</strong></p><pre><code>file(GLOB_RECURSE QT_MOC RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} FOLLOW_SYMLINKS    include/qtgui/*.hpp include/qtgui/*.h    )        </code></pre><p>这一句如果直接使用<em>.h,则会在建立的包内匹配</em>h(include src…),b方式即使把提供头文件包含进来也没问题,<br>a方式出错 需要排除qwtplot3d提供的头文件 这里我新建了一个文件include/qwt</p><pre><code>#  a方式出错 error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;/home/yang/project/cam/test/build/qtgui/include/qwt/moc_qwt3d_surfaceplot.cpp:78: error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;</code></pre><p>注意到上面只处理了头文件包含,对于库文件有多种处理方式,库文件又分为静态库和动态库,可参考<a href="https://www.zhihu.com/question/20484931/answer/69553616" target="_blank" rel="noopener">Linux 中的动态链接库和静态链接库是干什么的？</a></p><ol><li><p>指定相对位置(推荐,成功率高)</p><pre><code> # 把库文件.so复制到项目内与src同级目录lib, 然后在CmakeLists.txt指定相对位置 LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/lib)   ## 添加动态库路径</code></pre></li><li><p>指定绝对位置</p><pre><code> # CmakeLists.txt 添加库文件路径(之前存放的路径) LINK_DIRECTORIES(/opt/qt59/lib/x86_64-linux-gnu/qtcreator/)   ## 添加动态库路径</code></pre></li><li><p>添加路径到变量LD_LIBRARY_PATH</p><pre><code> # ~/.bashrc 下添加下面这句,然后重开终端启动qtcreator 但是我没成功 export LD_LIBRARY_PATH=/opt/qt59/lib/x86_64-linux-gnu/qtcreator:${LD_LIBRARY_PATH}</code></pre></li><li><p>修改/etc/ld.so.conf,添加路径,运行sudo ldconfig命令</p><p> 这是一个系统动态链接库路径配置文件,我尝试过/etc/ld.so.conf 添加库文件路径<br> 以及在指定的目录下增加XXX.conf都不行,最后是直接拷贝到包含的一个目录下成功的(/usr/lib/x86_64-linux-gnu/)</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://blog.csdn.net/qq_41800188/article/details/87891586" target="_blank" rel="noopener">Ubuntu Linux 16.04 LTS + Qt5.5.1 + Qwtplot3d配置安装</a></li><li><a href="https://blog.csdn.net/EastonWoo/article/details/37658141" target="_blank" rel="noopener">QT5 r 加入qwtplot3d 三维库</a></li><li><a href="https://blog.csdn.net/zxh2075/article/details/54629318?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">linux下添加动态链接库路径的方法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;qwtplot3D是一个Qt第三方库,在OpenGL基础上封装了一层可以用来三维绘图.&lt;/p&gt;
&lt;h2 id=&quot;Qt项目使用QwtPlot3d&quot;&gt;&lt;a href=&quot;#Qt项目使用QwtPlot3d&quot; class=&quot;headerlink&quot; title=&quot;　Qt项目使用QwtP
      
    
    </summary>
    
      <category term="Linux" scheme="http://yangbenbo.github.io/categories/Linux/"/>
    
    
      <category term="Qt" scheme="http://yangbenbo.github.io/tags/Qt/"/>
    
      <category term="ROS" scheme="http://yangbenbo.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://yangbenbo.github.io/2020/04/21/mysql/"/>
    <id>http://yangbenbo.github.io/2020/04/21/mysql/</id>
    <published>2020-04-21T15:15:25.000Z</published>
    <updated>2023-07-08T23:10:11.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><pre><code>-- 显示数据库show databases;-- 显示表格show tables;-- 创建一个名称为car的数据库。create database car;-- 使用数据库 caruse car;-- 删除数据库car-- drop database car;-- 显示表格内容select * from tableName;-- 创建表create table brand (id int primary key auto_increment, factory varchar(255), name varchar(255), price int, sum int, sell int, last int);-- 删除brand表-- drop table brand;-- 插入数据insert into brand(factory,name,price,sum, sell, last) values(&#39;一汽大众&#39;, &#39;奥迪A6&#39;, 36, 50, 8, 42);-- 更新数据-- update brand set sell=5 , last=70 where factory=&#39;上海大众&#39; and name=&#39;桑塔纳&#39;;</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="无法插入中文"><a href="#无法插入中文" class="headerlink" title="无法插入中文"></a>无法插入中文</h3><ol><li><p>临时修改</p><ul><li><p>查看客户端 编码字符 状态</p><pre><code>  status;  // Client characterset: utf8  #Server characterset 和 Db     characterset 都是utf8</code></pre></li><li><p>查看所有编码字符</p><pre><code>  show variables like&#39;%char%&#39;;</code></pre></li><li><p>修改设置(gbk 也是支持中文)            </p><pre><code>  set character_set_database=utf8;  set character_set_server=utf8;</code></pre></li></ul></li><li><p>永久修改修改配置文件</p><ul><li><p>针对未创建的表</p><pre><code>  sudo vim /etc/mysql/my.cnf  # 末尾添加  [client]  default-character-set=utf8  [mysqld]  character-set-server=utf8</code></pre><p>  /etc/init.d/mysql restart  #重启服务</p></li><li><p>针对已经创建的表</p><pre><code>  alter table `tablename` convert to character set utf8;</code></pre></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用语句&quot;&gt;&lt;a href=&quot;#常用语句&quot; class=&quot;headerlink&quot; title=&quot;常用语句&quot;&gt;&lt;/a&gt;常用语句&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;-- 显示数据库
show databases;

-- 显示表格
show tables;

-- 创建一
      
    
    </summary>
    
      <category term="Program" scheme="http://yangbenbo.github.io/categories/Program/"/>
    
    
      <category term="mysql" scheme="http://yangbenbo.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
